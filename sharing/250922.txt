오케이—모델 로딩 중 “응답없음” 걸리는 걸 먼저 풀고, 로딩창(오버레이) 관련 코드는 전부 배제, WBS 생성이 메인스레드를 붙잡지 않도록 “타임아웃 방지”만 아주 최소로 넣었습니다. 아래 파일을 그대로 교체해서 써주세요. (변경점은 주석 // ✅ 로 표시)


---

// /wwwroot/js/main.js  (freeze 방지 최소 수정판)

// ── Imports (경로/이름 변경 흡수용: namespace import 후 안전 별칭 매핑) ──
import { initTabs } from "./sidebar/init-tabs.js";
import { initTree } from "./sidebar/init-tree.js";
import * as Panel2 from "./sidebar/task-wbs/panel2.js";
import { initViewer, loadModel } from "./viewer/init-viewer.js";
import * as Panel2Buttons from "./sidebar/task-wbs/panel2-buttons.js";
import * as WbsLoader from "./sidebar/task-wbs/wbs/loader.js";
import * as Panel2Resizer from "./sidebar/task-wbs/layout/panel-resizer.js";
import * as Panel2Helpers from "./sidebar/task-wbs/panel2-ui-helpers.js";

// ── 메서드 이름 안전 별칭 ──
const initPanel2Content =
  Panel2.initPanel2Content || Panel2.initPanel2 || Panel2.default;

const initTaskListButtons =
  Panel2Buttons.initTaskListButtons || Panel2Buttons.initButtons || Panel2Buttons.default;

const setSavedTaskData =
  Panel2Buttons.setSavedTaskData || Panel2Buttons.setTaskData || (() => {});

const buildWbsTreeData =
  WbsLoader.buildWbsTreeData || WbsLoader.buildWbsTree || WbsLoader.default;

const bindPanel2Resizer =
  Panel2Resizer.bindPanel2Resizer || Panel2Resizer.bindResizer || Panel2Resizer.default;

const updateWBSHighlight =
  Panel2Helpers.updateWBSHighlight || Panel2Helpers.refreshWBSHighlight || (() => {});

const disableViewerEscReset =
  Panel2Helpers.disableViewerEscReset || Panel2Helpers.disableEscReset || (() => {});

// ===== Viewer 준비 상태 대기 유틸 =====
function onceViewer(viewer, type) {
  return new Promise((resolve) => {
    const h = () => { viewer.removeEventListener(type, h); resolve(); };
    viewer.addEventListener(type, h);
  });
}
function hasObjectTree(viewer) {
  return !!(viewer.model?.getData?.()?.instanceTree);
}
async function waitObjectTree(viewer) {
  if (hasObjectTree(viewer)) return;
  await onceViewer(viewer, Autodesk.Viewing.OBJECT_TREE_CREATED_EVENT);
}
// ✅ GEOMETRY_LOADED_EVENT 무한대기 방지: 0.8s 초과 시 계속 진행
async function waitGeometry(viewer) {
  const got = new Promise((r) =>
    viewer.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, () => r(), { once: true })
  );
  await Promise.race([got, new Promise((r) => setTimeout(r, 800))]);
}
function waitIdle(timeout = 60) {
  return new Promise((resolve) => {
    if (typeof window.requestIdleCallback === 'function') {
      window.requestIdleCallback(() => resolve(), { timeout });
    } else {
      setTimeout(resolve, timeout);
    }
  });
}
async function waitViewerReady(viewer) {
  await waitObjectTree(viewer);
  await waitGeometry(viewer);
  await waitIdle(60);
}

// ✅ 간단 타임아웃 유틸: 무거운 비동기(step)가 오래 걸리면 건너뛰기
async function withTimeout(promise, ms, fallback = null){
  let to;
  const timeout = new Promise((resolve) => { to = setTimeout(() => resolve({ __timeout:true }), ms); });
  const res = await Promise.race([promise, timeout]).catch(()=>({ __error:true }));
  clearTimeout(to);
  if (res && (res.__timeout || res.__error)) return fallback;
  return res;
}

// 전면 하이라이트 게이트: 초기엔 OFF
window.__ALLOW_WBS_UPDATE = false;

// --- Repaint Gantt on window resize (throttled) ---
window.addEventListener('resize', _.throttle(() => {
  try {
    if (window.gantt && window.taskTree) {
      window.gantt.renderFromTrees(window.taskTree, window.wbsTree);
    }
  } catch (e) {
    console.warn('[gantt] resize redraw failed', e);
  }
}, 200));

const login = document.getElementById("login");
let taskData = []; // 현재 모델의 Task 데이터 (트리용)

// 샘플 데이터 (서버에 데이터 없을 때 사용)
const SAMPLE_TASK_DATA = [
  {
    no: "1",
    selectOptions: ["시공", "가설", "철거"],
    selectedOption: "시공",
    title: "Task A",
    start: "2024-06-25",
    end: "2024-07-01",
    linkedObjects: [{ urn: "SAMPLE_URN", dbId: 1001, text: "벽체1" }],
    children: [
      {
        no: "1.1",
        selectOptions: ["시공", "가설", "철거"],
        selectedOption: "시공",
        title: "Subtask A1",
        start: "2024-06-26",
        end: "2024-06-30",
        linkedObjects: [{ urn: "SAMPLE_URN", dbId: 1002, text: "벽체2" }]
      }
    ],
  },
  { no: "2", selectOptions: ["시공", "가설", "철거"], selectedOption: "시공", title: "Task B", start: "", end: "", linkedObjects: [] },
];

// URN을 특수문자 없는 safe key로 변환
function safeUrn(urn) {
  return urn.replace(/[^a-zA-Z0-9]/g, "_");
}

// taskData의 모든 linkedObjects에 urn 채워넣기
function fillUrnRecursive(task, defaultUrn) {
  if (Array.isArray(task.linkedObjects)) {
    task.linkedObjects.forEach(obj => { if (!obj.urn) obj.urn = defaultUrn || window.CURRENT_MODEL_URN; });
  }
  if (Array.isArray(task.children)) {
    task.children.forEach(child => fillUrnRecursive(child, defaultUrn));
  }
}

// -------- 앱 전체 초기화 IIFE ---------
(async function () {
  try {
    // 1. 로그인 상태 확인
    const resp = await fetch("/api/auth/profile", { credentials: "include" });
    if (!resp.ok) {
      window.location.replace("/api/auth/login");
      return;
    }
    const user = await resp.json();
    login.innerText = `Logout (${user.name})`;
    login.onclick = () => {
      const iframe = document.createElement("iframe");
      iframe.style.visibility = "hidden";
      iframe.src = "https://accounts.autodesk.com/Authentication/LogOut";
      document.body.appendChild(iframe);
      iframe.onload = () => {
        window.location.replace("/api/auth/logout");
        document.body.removeChild(iframe);
      };
    };

    // 2. 기본 레이아웃 표시
    const Sidebar = document.getElementById("sidebar");
    const Header = document.getElementById("header");
    const Preview = document.getElementById("preview");
    const sidebarResizer = document.getElementById("sidebar-resizer");
    const Loading = document.getElementById("loading");

    Sidebar.style.display = "";
    Sidebar.style.width = "500px";
    sidebarResizer.style.display = "";
    sidebarResizer.style.left = "500px";
    Preview.style.display = "";
    Preview.style.left = Sidebar.style.width;
    Preview.style.right = "0";
    Preview.style.top = "3em";
    Preview.style.bottom = "0";
    Header.style.display = "";
    Loading.style.display = "none"; // ✅ 로딩창(웰컴) 강제 종료 유지
    login.style.visibility = "visible";

    // 3. 뷰어/탭 초기화
    initTabs("#sidebar");
    const viewer = await initViewer(document.getElementById("viewer-host"));
    disableViewerEscReset(viewer);

    // ✅ 렌더링 옵션 살짝 낮춰 초기 로딩 안정화 (없어도 되지만 무해)
    try { viewer.setProgressiveRendering?.(true); } catch {}
    try { viewer.setLightPreset?.(0); } catch {}

    // 4. 프로젝트 트리 초기화: 모델 선택 시 콜백
    initTree("#tree", async (versionId) => {
      destroyTaskPanel();

      const urn = window.btoa(versionId).replace(/=/g, "");
      window.CURRENT_MODEL_URN = urn;
      window.CURRENT_MODEL_SAFE_URN = safeUrn(urn);

      taskData.length = 0;
      setSavedTaskData([]);
      await loadTaskDataIfExists();
      taskData.forEach((t) => fillUrnRecursive(t, urn));

      console.log("[main.js] 모델 선택!", versionId, urn);

      // ── 모델 로드 (단일 await, 실패해도 앱이 죽지 않도록 보호)
      try {
        await loadModel(viewer, urn);
      } catch (e) {
        console.warn("[main.js] loadModel 실패:", e);
      }

      // ✅ 뷰어 로딩 완료 + idle 보장 (이벤트 타임아웃이 있어 멈춤 방지)
      await waitViewerReady(viewer);

      // ── 여기부터는 무거운 일(=WBS 생성)로 인해 메인스레드가 붙잡히면
      //     '로딩 중 멈춤'처럼 보이므로, 반드시 타임아웃/양보를 둔다.

      // ✅ 아주 짧게 양보
      await waitIdle(50);

      // ✅ WBS 데이터 생성: 4초 넘으면 생략하고 빈 배열로(뷰어 멈춤 방지)
      let wbsData = [];
      try {
        const build = buildWbsTreeData(viewer);
        wbsData = await withTimeout(build, 4000, []);  // ← 핵심
        if (wbsData === null) wbsData = [];
      } catch (e) {
        console.warn("[main.js] WBS 데이터 생성 실패(생략):", e);
        wbsData = [];
      }

      // 패널 초기화는 예외 흡수 (한 군데 에러로 전체 멈추지 않게)
      try { initTaskListButtons(); } catch(e){ console.warn("[panel2] buttons init fail:", e); }
      try { initPanel2Content(taskData, wbsData); } catch(e){ console.warn("[panel2] content init fail:", e); }
      try { bindPanel2Resizer(); } catch(e){ console.warn("[panel2] resizer bind fail:", e); }

      window.dispatchEvent(new Event("panel2-ready"));

      // 간트 1회 렌더(부하 적게)
      requestAnimationFrame(() => {
        try { window.gantt?.renderFromTrees(window.taskTree, window.wbsTree); } catch (_) {}
      });

      // 🔶 초기 하이라이트: DOM 안정화 후 1회만
      await waitIdle(60);
      if (window.taskTree && window.wbsTree) {
        try { window.taskTree.render(true, true); } catch{}
        window.__ALLOW_WBS_UPDATE = true;
        try { updateWBSHighlight(); } catch(e) { console.warn('[wbs] first HL failed', e); }
      }
    });

  } catch (err) {
    alert("Could not initialize the application. See console for more details.");
    console.error(err);
  }
})();

// ----- Task 데이터 (서버 or 샘플) 불러오는 함수 -----
async function loadTaskDataIfExists() {
  try {
    const safeUrnVal = window.CURRENT_MODEL_SAFE_URN;
    const url = `/api/tasks?urn=${safeUrnVal}`;
    const resp = await fetch(url, { credentials: "include" });
    if (resp.ok) {
      const data = await resp.json();
      taskData.length = 0;
      if (Array.isArray(data) && data.length > 0) {
        data.forEach((item) => taskData.push(item));
        setSavedTaskData(taskData);
      } else {
        SAMPLE_TASK_DATA.forEach((item) => taskData.push(structuredClone(item)));
        setSavedTaskData(taskData);
      }
    } else {
      taskData.length = 0;
      SAMPLE_TASK_DATA.forEach((item) => taskData.push(structuredClone(item)));
      setSavedTaskData(taskData);
    }
  } catch (err) {
    taskData.length = 0;
    SAMPLE_TASK_DATA.forEach((item) => taskData.push(structuredClone(item)));
    setSavedTaskData(taskData);
    console.warn("task 데이터를 불러오지 못했습니다. 샘플로 초기화:", err);
  }
}

// ----- Task/WBS 패널 전체 제거 및 DOM 재생성 -----
function destroyTaskPanel() {
  console.log("[destroy] panel2 destroy & 재생성");
  try { $.ui.fancytree.getTree("#treegrid")?.destroy(); } catch (e) {}
  window.taskTree = null;
  window.wbsTree = null;
  try { window.gantt?.drawFromRows?.([]); } catch(_) {}

  $("#wbs-group-content").empty();
  $("#panel2").html(`
    <div id="vertical-split-container">
      <div id="task-list-panel">
        <div class="panel-header">
          <span class="title">Task List</span>
          <div class="button-group">
            <button id="btn-add">추가</button>
            <button id="btn-delete">삭제</button>
            <button id="btn-select">객체 선택</button>
            <button id="btn-link">데이터 연결</button>
            <button id="btn-unlink">연결 해제</button>
            <button id="btn-date">공정현황</button>
            <button id="btn-test">테스트</button>
            <button id="btn-update">저장</button>
          </div>
        </div>
        <table id="treegrid" style="width: 100%" class="fancytree-ext-table">
          <colgroup>
            <col width="40px" />
            <col width="60px" />
            <col width="260px" />
            <col width="100px" />
            <col width="100px" />
            <col width="100px" />
            <col width="60px" />
          </colgroup>
          <thead>
            <tr>
              <th>No.</th>
              <th>구분</th>
              <th>작업명</th>
              <th>시작일</th>
              <th>소요시간(Day)</th>
              <th>완료일</th>
              <th>객체개수</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div id="resizer"></div>
      <div class="sidebar-panel" id="wbs-group-list-panel">
        <div class="panel-header">
          <span class="title">WBS Group List</span>
        </div>
        <div class="panel-content" id="wbs-group-content">
          <div id="wbs-tree"></div>
        </div>
      </div>
    </div>
  `);
}

왜 이게 “멈춤”을 풀어주나?

WBS 빌드가 무거울 때 메인스레드를 오래 점유 → “응답없음”처럼 보입니다. withTimeout(..., 4000, []) 로 최대 4초만 시도하고, 넘기면 일단 건너뜁니다. (뷰어는 정상 작동, WBS는 빈상태라도 UI가 살아있음)

모델 로딩 이벤트 대기는 타임아웃이 포함되어 있어서, 특정 환경에서 이벤트가 안 오더라도 진행됩니다.

로딩(오버레이) 코드는 애초에 없었고, 페이지 웰컴 “Loading”은 계속 강제 display:none 처리합니다.


필요하면, WBS가 비었을 때 나중에 버튼으로 “WBS 새로 고침”을 따로 붙여주는 식으로 점진 로딩을 넣을 수 있어요. 우선은 뷰어 멈춤(프리즈) 이슈부터 이것으로 끊겠습니다.

