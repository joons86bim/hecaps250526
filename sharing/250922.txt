// provider에서 루트 기준 BFS로 pathKey 수집
async function collectKeysForRoots(provider, { maxDepth = 3, cap = 5000 } = {}) {
  const roots = (await provider.roots()) || [];
  const q = roots.map(r => ({ path: [r.text], depth: 0 }));
  const keys = new Set();
  let seen = 0;

  while (q.length && seen < cap) {
    const { path, depth } = q.shift();
    keys.add(toKey(path));
    let kids = [];
    try { kids = await provider.childrenByPath(path) || []; } catch {}
    seen += kids.length;

    if (depth < maxDepth) {
      for (const ch of kids) {
        const np = ch.__path || [...path, ch.text];
        q.push({ path: np, depth: depth + 1 });
      }
    }
  }
  return Array.from(keys);
}



// (중략) provider 생성/prime/seed 끝난 뒤, 여기서부터

-     // 기존: taskData.forEach(fillUrnRecursive) → setSavedTaskData → (바로) FancyTree 초기화
-     // NEW: 태스크 반영 → initMatrix(단 1회) → WBS 키/DBID 선계산 → paint → 그 다음 FancyTree

+     // 1) 태스크에 URN 보정 + 저장
+     taskData.forEach((t) => fillUrnRecursive(t, urn));
+     setSavedTaskData(taskData);
+     await waitIdle(0); // 1틱만 쉬어서 저장 스냅샷 접근 가능하게

+     // 2) 매트릭스 초기화 (단 1회)
+     const PRIMARY = ["HEC.WBS","HEC.Level","HEC.Zone"];
+     await initMatrix({ primaryOrder: PRIMARY, provider: wbsProvider });
+     window.__MATRIX_READY = true;

+     // 3) WBS 루트 전체(깊이<=3) 키를 먼저 만들어 상태 계산을 선행
+     const preKeys = await collectKeysForRoots(wbsProvider, { maxDepth: 3, cap: 6000 });
+     await bulkEnsureForVisible(preKeys);
+     preKeys.forEach(computePathState);

+     // (선택) sanity log: 첫 렌더 전에 루트별 c/t/d 확인
+     try {
+       const roots = (await wbsProvider.roots()) || [];
+       console.log("[precompute] roots=", roots.length);
+       roots.forEach(r => {
+         const k = toKey([r.text]);
+         console.log("[precompute] root", r.text, getCounts(k));
+       });
+     } catch {}



// 통합 워밍업: childrenByPath + getDbIdsForPath 섞어서 BFS
async function warmupProvider(provider, { maxDepth = 3, cap = 6000 } = {}) {
  const roots = (await provider.roots()) || [];
  const q = roots.map(r => ({ path: [r.text], depth: 0 }));
  let visited = 0;
  while (q.length && visited < cap) {
    const { path, depth } = q.shift();
    // 경로→dbId 맵을 어차피 bulkEnsure에서 다시 쓰지만, provider 내부 캐시를 예열
    try { provider.getDbIdsForPath?.(path, { includeDescendants:true, allowUnbuilt:true }); } catch {}
    if (depth < maxDepth) {
      let kids = [];
      try { kids = await provider.childrenByPath(path) || []; } catch {}
      visited += kids.length;
      for (const ch of kids) {
        const np = ch.__path || [...path, ch.text];
        q.push({ path: np, depth: depth + 1 });
      }
    }
  }
}