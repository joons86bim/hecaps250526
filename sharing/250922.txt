// ── [추가] Property DB 대기
async function waitPropertyDb(viewer, timeoutMs = 120000) {
  // 2D는 prop DB가 다르게 동작할 수 있으니, 있으면 바로 통과
  try {
    if (viewer?.model?.getPropertyDb?.()) return;
  } catch {}
  await new Promise((resolve) => {
    let done = false;
    const h = () => {
      if (done) return;
      done = true;
      try { viewer.removeEventListener(Autodesk.Viewing.PROPERTY_DB_CREATED_EVENT, h); } catch {}
      resolve();
    };
    viewer.addEventListener(Autodesk.Viewing.PROPERTY_DB_CREATED_EVENT, h, { once: true });
    // 타임아웃 폴백
    setTimeout(h, timeoutMs);
  });
}

// ── [수정] waitViewerReady: PROPERTY_DB까지 포함해 모두 끝날 때까지 기다림
async function waitViewerReady(viewer) {
  await Promise.all([
    waitObjectTree(viewer),   // 인스턴스 트리
    waitPropertyDb(viewer),   // 프로퍼티 DB
    waitGeometry(viewer)      // 지오메트리
  ]);
  await waitIdle(60);
}

// ── [추가] 카메라 포커싱(=fitToView 포함) 후 안정화까지 대기
async function focusCameraAndWait(viewer) {
  return new Promise((resolve) => {
    const onCam = () => {
      try { viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, onCam); } catch {}
      // 한 프레임 더 밀어서 렌더 파이프라인 안정화
      requestAnimationFrame(() => resolve());
    };
    viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, onCam, { once: true });
    // reset 내부에서 fitToView 호출: 카메라 이동 이벤트를 트리거
    resetViewerInputAndCamera(viewer);
  });
}



const myToken = ++__MODEL_RUN_TOKEN;  // 이 호출 시점의 세션 토큰

await loadModel(viewer, urn);
await waitViewerReady(viewer);        // 트리+프로퍼티DB+지오메트리까지

// ⚠️ 빠른 모델 전환 레이스 방지
if (myToken !== __MODEL_RUN_TOKEN) return;

// 카메라 포커싱이 실제로 끝날 때까지 대기 (fitToView → CAMERA_CHANGE_EVENT)
await focusCameraAndWait(viewer);
viewer.resize();

// ⚠️ 여기서도 한 번 더 레이스 체크
if (myToken !== __MODEL_RUN_TOKEN) return;

// ─────────────────────────────────────────────
// [STEP 3~6] ← 카메라 안정화 이후로 이동 (여기부터 패널/데이터 초기화 시작)
// 기존 WBS 트리 있으면 파괴 후 비우기
try { $.ui.fancytree.getTree("#wbs-tree")?.destroy(); } catch {}
$("#wbs-group-content").empty();

// STEP 3: provider 생성 (모델 기반으로!)
let wbsProvider = null;
try {
  const PRIMARY = ["HEC.WBS","HEC.Level","HEC.Zone"];
  const { provider } = await buildWbsProviderLazy(viewer, {
    primaryOrder: PRIMARY,
    source: "all",
    bucketThreshold: 400,
    bucketSize: 200
  });
  // 중간에 모델이 바뀌었으면 중단
  if (myToken !== __MODEL_RUN_TOKEN) return;

  wbsProvider = provider;
  window.WBS_PROVIDER = provider;
  try {
    const roots = await provider.roots();
    console.log("[WBS] roots:", Array.isArray(roots) ? roots.length : roots);
  } catch (e) {
    console.warn("[WBS] roots() failed:", e);
  }
} catch (e) {
  console.warn("[STEP 3] WBS provider failed:", e);
  wbsProvider = { __provider:true, roots:async()=>[], childrenByPath:async()=>[] };
}

// STEP 4: 워밍업 (아주 작게)
try {
  if (wbsProvider) {
    const roots = await wbsProvider.roots();
    let q = roots.map(r => ({ path: [r.text], depth: 1 }));
    let c = 0;
    while (q.length && c < 200) {
      const { path, depth } = q.shift();
      if (depth >= 2) continue;
      const kids = await wbsProvider.childrenByPath(path);
      c += kids.length;
      kids.forEach(k => q.push({ path: [...path, k.text], depth: depth + 1 }));
    }
    console.log("[STEP 4] WBS warmup OK (depth<=2, cap<=200)");
  }
} catch (e) {
  console.warn("[STEP 4] WBS warmup failed:", e);
}

// 중간 레이스 체크
if (myToken !== __MODEL_RUN_TOKEN) return;

// STEP 5: Fancytree 초기화
try {
  await initWbsPanelWithFancytree(wbsProvider, {
    primaryOrder: ["HEC.WBS","HEC.Level","HEC.Zone"]
  });
  console.log("[STEP 5] WBS fancytree init OK");
} catch (e) {
  console.warn("[STEP 5] WBS fancytree init failed:", e);
}

// STEP 6: 패널2 리사이저 바인딩
try {
  bindPanel2Resizer(viewer);
  console.log("[STEP 6] panel2 resizer bound");
} catch (e) {
  console.warn("[STEP 6] resizer bind failed:", e);
}
// ─────────────────────────────────────────────


