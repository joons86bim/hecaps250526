// /wwwroot/js/task-wbs/task-buttons.js
// Test: 선택 객체만 대상으로 컷플레인 스윕
// 2s 상→하 스윕(사라짐) → 1s 대기 → 2s 하→상 스윕(등장)

export function initTaskWbsButtons(viewer) {
  let btn = document.getElementById('btn-test');
  if (!btn || !viewer) return;

  const clone = btn.cloneNode(true);
  btn.parentNode.replaceChild(clone, btn);
  btn = clone;

  btn.addEventListener('click', async () => {
    try {
      await runTestCutSweep(viewer);
    } catch (e) {
      console.error('[test-btn] error:', e);
    }
  });
}

async function runTestCutSweep(viewer) {
  const sel = getSelectionSmart(viewer);
  if (!sel || !sel.model || !sel.dbIds.length) {
    console.warn('[test-btn] 먼저 객체를 선택하세요.');
    return;
  }
  const { model, dbIds } = sel;

  // 선택만 보이도록(선택 객체만 애니메이션 대상)
  const ISOLATE_SELECTION = true;
  let prevIsolated = null;
  if (ISOLATE_SELECTION) {
    try { prevIsolated = viewer.getIsolatedNodes?.() || null; } catch(_) {}
    viewer.isolate(dbIds);
  }
  viewer.clearSelection();

  // 선택 bbox 계산
  const bbox = computeSelectionBBox(viewer, model, dbIds);
  if (!bbox) {
    console.warn('[test-btn] 바운딩박스를 계산할 수 없습니다.');
    if (ISOLATE_SELECTION) viewer.isolate([]);
    return;
  }

  // 기존 컷플레인 백업
  const originalPlanes = viewer.getCutPlanes ? (viewer.getCutPlanes().slice()) : [];

  const THREE = window.THREE || Autodesk.Viewing.THREE;
  // 컷 방향: Z+
  const dir = new THREE.Vector3(0, 0, 1);

  const minZ = bbox.min.z;
  const maxZ = bbox.max.z;
  const range = Math.max(1e-6, maxZ - minZ);
  const margin = range * 0.05;

  // ★ 핵심: 시작을 '천장 위'로 잡아 처음 프레임에서 아무 것도 잘리지 않게 함
  const startH_top = maxZ + margin;
  const endH_bottom = minZ - margin;

  // THREE.Plane: n·p + c = 0, 뷰어는 양/음 중 한쪽을 클립함
  // 여기서는 start를 위쪽으로 잡고 ↓로 이동시키며 점차 클립되도록 설정
  const sweepPlane = new THREE.Plane(dir.clone(), -startH_top);

  // 상→하 2초: 점점 사라짐(Top→Bottom)
  await animate(2000, (t) => {
    const k = easeInOutSine(t);               // 0→1
    const h = lerp(startH_top, endH_bottom, k);
    sweepPlane.constant = -h;
    viewer.setCutPlanes([...originalPlanes, sweepPlane]);
    viewer.impl.sceneUpdated(true);
  });

  await delay(1000); // 1초 대기

  // 하→상 2초: 다시 나타남(Bottom→Top)
  await animate(2000, (t) => {
    const k = easeInOutSine(t);
    const h = lerp(endH_bottom, startH_top, k);
    sweepPlane.constant = -h;
    viewer.setCutPlanes([...originalPlanes, sweepPlane]);
    viewer.impl.sceneUpdated(true);
  });

  // 원복
  viewer.setCutPlanes(originalPlanes);
  viewer.impl.sceneUpdated(true);

  if (ISOLATE_SELECTION) {
    // 간단 복원: 전체 표시 (필요 시 prevIsolated 복구 로직으로 변경)
    viewer.isolate([]);
  }
}

/* ============== Helpers ============== */

function getSelectionSmart(viewer) {
  const agg = viewer.getAggregateSelection?.();
  if (agg && agg.length > 0) {
    const a = agg[0];
    const ids = (a.selection || []).slice();
    return ids.length ? { model: a.model, dbIds: ids, aggregate: true } : null;
  }
  const ids = viewer.getSelection?.() || [];
  return (ids && ids.length) ? { model: viewer.model, dbIds: ids, aggregate: false } : null;
}

function getFragList(viewer, model) {
  if (model?.getFragmentList) return model.getFragmentList();
  if (viewer?.model?.getFragmentList) return viewer.model.getFragmentList();
  return null;
}

function collectFragIds(model, dbIds) {
  const it = model.getData().instanceTree;
  const fragIds = [];
  dbIds.forEach((dbId) => {
    it.enumNodeFragments(dbId, (fragId) => fragIds.push(fragId), true);
  });
  return fragIds;
}

function computeSelectionBBox(viewer, model, dbIds) {
  const THREE = window.THREE || Autodesk.Viewing.THREE;
  const fragList = getFragList(viewer, model);
  if (!fragList) return null;

  const fragIds = collectFragIds(model, dbIds);
  if (!fragIds.length) return null;

  const box = new THREE.Box3();
  const tmp = new THREE.Box3();
  let init = false;

  for (const fid of fragIds) {
    try {
      fragList.getWorldBounds(fid, tmp);
      if (!init) { box.copy(tmp); init = true; }
      else { box.union(tmp); }
    } catch(_) {}
  }
  return init ? box : null;
}

/* timing & easing */

function lerp(a, b, t) { return a + (b - a) * t; }
function delay(ms) { return new Promise((res) => setTimeout(res, ms)); }

function easeInOutSine(t){ return 0.5 - 0.5 * Math.cos(Math.PI * t); }

function animate(duration, step) {
  return new Promise((resolve) => {
    const start = performance.now();
    function frame(now) {
      const t = Math.min(1, (now - start) / duration);
      step(t);
      if (t < 1) requestAnimationFrame(frame);
      else resolve();
    }
    requestAnimationFrame(frame);
  });
}