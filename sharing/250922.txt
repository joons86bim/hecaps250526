export function apply4DAtMs(viewer, nowMs, config = {}) {
  const cfg = {
    zOffset: 3.0,
    useDateDuration: true,
    fixedDurationSec: 2.0,
    speedDaysPerSec: 1.0,
    // alpha가 이 값 미만이면 엣지까지 완전 숨김(nodeOff)
    edgeNodeOnAlpha: 0.4,
    ...config,
  };
  if (!viewer || !Number.isFinite(nowMs)) return;
  const model = (viewer.getVisibleModels?.()[0]) || viewer.model;
  if (!model) return;

  let state = _globalState.get(model.id);
  if (!state) {
    const schedule = _buildSchedule(model);
    const store = _prepareStore(viewer, model, schedule);
    state = { schedule, store };
    _globalState.set(model.id, state);
  }
  const { schedule, store } = state;
  if (!schedule.allDbIds.size) return;

  const vm = viewer.impl.visibilityManager;

  // 정책 색
  const V4 = (r,g,b,a=1) => (window.THREE ? new window.THREE.Vector4(r,g,b,a) : { r,g,b,a });
  const C_GREEN = V4(0.16, 0.57, 0.20, 1);
  const C_BLUE  = V4(0.12, 0.45, 0.90, 1);
  const C_RED   = V4(0.95, 0.27, 0.23, 1);
  const C_ZERO  = V4(0,0,0,0);

  for (const dbId of schedule.allDbIds) {
    const tl = schedule.byDb.get(dbId) || { installs: [], demolitions: [] };
    const inst = tl.installs;     // [{cat:'C'|'T', startMs, endMs}]
    const demo = tl.demolitions;  // [{startMs, endMs}]

    const firstInstStart = _minStart(inst);
    const lastInstEnd    = _maxEnd(inst);
    const firstDemoStart = _minStart(demo);
    const lastDemoEnd    = _maxEnd(demo);

    const activeInstall  = _findActive(inst, nowMs);
    const activeDemo     = _findActive(demo, nowMs);

    let alpha = 1.0, dz = 0.0, theme = C_ZERO;
    let forceNodeOff = false;

    if (activeDemo) {
      // 철거: 전반부 불투명, 후반부 페이드아웃 / z: 0→+z
      const p = _progress(nowMs, activeDemo.startMs, activeDemo.endMs, cfg);
      const half = (p <= 0.5);
      alpha = half ? 1.0 : (2.0 * (1.0 - p));      // 0.5~1 구간 1→0
      dz    = _lerp(0, cfg.zOffset, p);            // 전체 기간 0→+z
      theme = C_RED;
    } else if (activeInstall) {
      // 가설/시공: 전반부 페이드인, 후반부 불투명 / z: +z→0
      const p = _progress(nowMs, activeInstall.startMs, activeInstall.endMs, cfg);
      const half = (p <= 0.5);
      alpha = half ? (2.0 * p) : 1.0;              // 0~0.5 구간 0→1
      dz    = _lerp(cfg.zOffset, 0, p);            // 전체 기간 +z→0
      theme = (activeInstall.cat === 'T') ? C_BLUE : C_GREEN;
    } else if (firstInstStart != null && nowMs < firstInstStart) {
      // 설치 시작 전: 완전 숨김
      alpha = 0; dz = cfg.zOffset; theme = C_ZERO; forceNodeOff = true;
    } else if (lastDemoEnd != null && nowMs > lastDemoEnd) {
      // 철거 완료 후: 완전 숨김
      alpha = 0; dz = cfg.zOffset; theme = C_ZERO; forceNodeOff = true;
    } else {
      // 설치 완료 ~ 철거 시작 사이(또는 철거만 있고 아직 전): 원상 (불투명, 테마 없음)
      alpha = 1; dz = 0; theme = C_ZERO;
    }

    // 프래그먼트 적용
    const frags = store.fragsByDb.get(dbId);
    if (frags) {
      for (const f of frags) {
        try {
          f.proxy.position.z = f.startPos.z + dz;
          f.proxy.updateAnimTransform();
          _applyFragMatState(f, alpha); // 불투명 시 depthWrite=true, transparent=false
        } catch(_) {}
      }
    }

    // 가시성: alpha가 충분히 오르기 전엔 엣지 포함 완전 숨김
    try {
      const nodeOn = !forceNodeOff && (alpha >= cfg.edgeNodeOnAlpha);
      if (nodeOn) vm.setNodeOn(dbId);
      else vm.setNodeOff(dbId);
    } catch(_) {}

    // 테마: 진행 중일 때만 색 적용, 그 외엔 제거
    try {
      const hasColor = !!activeInstall || !!activeDemo;
      viewer.setThemingColor(dbId, hasColor ? theme : C_ZERO, model);
    } catch(_) {}
  }

  viewer.impl.invalidate?.(true, true, true);
}

/* 머티리얼 상태: 불투명은 깊이쓰기 ON, 투명 페이즈는 깊이쓰기 OFF */
function _applyFragMatState(f, alpha){
  if (!f.cloneMat) return;
  const opaque = alpha >= 0.999;
  f.cloneMat.opacity = alpha;
  f.cloneMat.transparent = !opaque;
  f.cloneMat.depthWrite = opaque;
  f.cloneMat.needsUpdate = true;
}