좋아—세이프 모드에서 안 멈추는 걸 확인했으니, 이제 “어디서 멈추는지”를 단계별로 확실히 좁혀가자. 아래 순서대로 한 단계씩만 해제 → 테스트 해줘. 각 단계는 main.js의 모델 선택 콜백 내부(= initTree("#tree", async (versionId) => { ... }) 안)에서 주석 해제/추가만 하면 돼. 내가 붙여둔 // STEP n: 주석을 그대로 써서 관리하면 편해.


---

1) Task만 켜기 (WBS/간트는 계속 OFF)

하는 곳: initTree 콜백 안, await waitViewerReady(viewer); 바로 아래

// STEP 1: Task 패널만 켠다 (버튼 포함). 실패해도 앱이 죽지 않게 try/catch
try {
  initTaskPanel(taskData);
  initTaskListButtons();
  console.log("[STEP 1] Task panel OK");
} catch (e) {
  console.warn("[STEP 1] Task init failed:", e);
}

여기서 안 멈추면 → 2단계로.



---

2) panel2-ready 이벤트만 켜서 간트 쪽 확인

하는 곳: 같은 콜백, STEP 1 바로 아래

// STEP 2: panel2-ready를 발행해서 index.html의 간트 초기화가 수행되게 한다.
try {
  window.dispatchEvent(new Event("panel2-ready"));
  console.log("[STEP 2] panel2-ready dispatched");
} catch (e) {
  console.warn("[STEP 2] panel2-ready failed:", e);
}

여기서 멈추면 간트 초기화가 원인.

안 멈추면 → 3단계로.



---

3) WBS provider만 생성 (warmup/트리 미실행)

하는 곳: 같은 콜백, STEP 2 아래

// STEP 3: WBS provider만 만든다. 트리/워밍업은 아직 안 함.
let wbsProvider = null;
try {
  const { provider } = await buildWbsProviderLazy(viewer, {
    source: "all",
    bucketThreshold: 400,
    bucketSize: 200
  });
  wbsProvider = provider;
  console.log("[STEP 3] WBS provider OK");
} catch (e) {
  console.warn("[STEP 3] WBS provider failed:", e);
}

여기서 멈추면 provider 빌드가 원인 (속도 이슈 또는 내부 비동기 루프).

안 멈추면 → 4단계로.



---

4) WBS 워밍업을 아주 약하게만 실행

하는 곳: 같은 콜백, STEP 3 아래

// STEP 4: 워밍업 (Depth 2, Cap 200으로 아주 작게)
try {
  if (wbsProvider) {
    const roots = await wbsProvider.roots();
    let q = roots.map(r => ({ path: [r.text], depth: 1 }));
    let c = 0;
    while (q.length && c < 200) {
      const { path, depth } = q.shift();
      if (depth >= 2) continue;
      const kids = await wbsProvider.childrenByPath(path);
      c += kids.length;
      kids.forEach(k => q.push({ path: [...path, k.text], depth: depth + 1 }));
    }
    console.log("[STEP 4] WBS warmup OK (depth<=2, cap<=200)");
  }
} catch (e) {
  console.warn("[STEP 4] WBS warmup failed:", e);
}

여기서 멈추면 워밍업 루프가 원인 → cap/depth 더 줄이고, 나중에 완전 제거도 고려.

안 멈추면 → 5단계로.



---

5) WBS 트리(Fancytree) 초기화 (최소 설정)

> 중요: extensions 배열에 checkbox를 넣지 마세요! 체크박스는 옵션입니다.
extensions: ["table","gridnav"] + checkbox:true 만 두면 됩니다.
예전에 멈춤/에러의 직접 원인이 여기였어요.



하는 곳: 같은 콜백, STEP 4 아래

// STEP 5: Fancytree WBS 초기화 (최소 옵션)
try {
  await initWbsPanelWithFancytree(wbsProvider, {
    primaryOrder: ["HEC.WBS","HEC.Level","HEC.Zone"]
  });
  console.log("[STEP 5] WBS fancytree init OK");
} catch (e) {
  console.warn("[STEP 5] WBS fancytree init failed:", e);
}

여기서 멈추면 트리 초기화/렌더 핸들러가 원인.



---

6) (필요 시) Resizer 다시 활성화

세로 분할 리사이저가 레이아웃 루프를 만들 가능성도 있어서, 맨 마지막에 다시 켭니다.

// STEP 6: 패널2 리사이저 복귀 (문제 없을 때)
try {
  bindPanel2Resizer(viewer);
  console.log("[STEP 6] panel2 resizer bound");
} catch (e) {
  console.warn("[STEP 6] resizer bind failed:", e);
}


---

WBS 트리 쪽 “정지” 예방 패치 (이미 반영했으면 패스)

이건 main.js 외 코드지만, 이전 프리즈의 흔한 두 원인을 한 번에 잡아줍니다.
다음 2가지만 fancy-tree-init.js에서 꼭 확인:

1. extensions에 ‘checkbox’를 넣지 않는다.



$("#wbs-tree").fancytree({
  extensions: ["table", "gridnav"], // ✅ 여기!
  checkbox: true,                   // ✅ 옵션으로만
  selectMode: 3,
  // ...
});

2. tree.renderRows()를 쓰지 말고, 모두 data.tree.render(true, true) 로 바꿔주세요.
(네 코드에서 과거에 이게 있었던 걸 봤어. 없는 메서드라 멈추기도 함)



// (예) 계산 완료 후 전체 갱신
// BAD: tree.renderRows();
data.tree.render(true, true);


---

왜 이 순서인가?

Task만 → 간트만 → Provider만 → 워밍업만 → 트리 → 리사이저
이렇게 켜면 한 번에 원인이 보입니다.

특히 Fancytree는 확장/렌더 타이밍에 무한 다시그리기 루프를 만들 수 있어요.
위의 작은 가이드(checkbox 확장 제거, renderRows 미사용)만으로도 프리즈가 쭉 사라집니다.



---

진행하면서 체크할 콘솔 로그

각 STEP에서 console.log 찍히는지 무조건 확인해줘.

마지막 로그가 어느 STEP인지 알려주면, 그 블록만 파고들어서 고쳐줄게.


필요하면 해당 단계에서 딱 그 파일(예: fancy-tree-init.js)만 붙여줘도 돼.


import { toKey } from "../core/path-key.js";
import {
  initMatrix, bulkEnsureForVisible,
  computePathState, getPathState, getCounts,
  markTasksChanged
} from "../core/matrix-index.js";
import { formatObjectLabel } from "../core/element-id.js";

const HIDDEN_KEYS = new Set();

function buildPathFromNode(node){
  const out = [];
  let cur = node;
  while (cur && !cur.isRoot()) { out.unshift(cur.title); cur = cur.parent; }
  return out;
}
function stateToClass(st){
  if (st === "C") return "wbs-c";
  if (st === "TD") return "wbs-td";
  return "";
}

// 눈알 SVG
const Eye = `
<svg viewBox="0 0 24 24" aria-hidden="true">
  <path d="M12 5c5 0 9 4 10 7-1 3-5 7-10 7S3 15 2 12c1-3 5-7 10-7Zm0 3a4 4 0 100 8 4 4 0 000-8Z"/>
</svg>`;
const EyeOff = `
<svg viewBox="0 0 24 24" aria-hidden="true">
  <path d="M3 3l18 18M10.58 10.58A4 4 0 0012 16a4 4 0 002.83-6.83M12 5c5 0 9 4 10 7-.43 1.28-1.33 2.7-2.6 3.98M6.62 6.62C4.62 8.05 3.28 9.94 2 12c1 3 5 7 10 7 1.28 0 2.5-.22 3.62-.62"/>
</svg>`;

// 경로→dbId 수집 (click/dblclick 때만 호출: 초기 렌더에는 안 돌게)
async function getAllDbIdsForPath(provider, path){
  let ids = provider.getDbIdsForPath(path, { includeDescendants:true, allowUnbuilt:true });
  if (ids != null) return ids;
  try { await provider.childrenByPath(path); } catch {}
  ids = provider.getDbIdsForPath(path, { includeDescendants:true, allowUnbuilt:true });
  if (ids != null) return ids;
  return provider.getDbIdsForPath(path, { includeDescendants:true, allowUnbuilt:false }) || [];
}

function calcEyeStateForNode(node){
  const key = node.data?.pathKey;
  if (!key) return "none";
  let anyHidden = false;
  let allHidden = true;
  node.visit(n => {
    const k = n.data?.pathKey;
    if (!k) return;
    const hid = HIDDEN_KEYS.has(k);
    anyHidden = anyHidden || hid;
    allHidden = allHidden && hid;
  });
  if (!anyHidden) return "none";
  return allHidden ? "hidden" : "mixed";
}

export async function initWbsWithFancytree(provider, { primaryOrder } = {}) {
  await initMatrix({ primaryOrder, provider });

  // 테이블 뼈대(개수 가운데 정렬: th에 text-center)
  const host = document.getElementById("wbs-group-content");
  host.innerHTML = `
    <table id="wbs-tree" class="table table-sm wbs-table">
      <colgroup>
        <col class="col-title" />
        <col class="col-count" />
        <col class="col-status" />
      </colgroup>
      <thead>
        <tr>
          <th>항목</th>
          <th class="text-center">개수</th>
          <th>현황</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  `;

  $("#wbs-tree").fancytree({
    extensions: ["table", "gridnav"],   // ❗ checkbox 확장 넣지 마세요
    checkbox: true,                     // 체크박스는 옵션으로만
    selectMode: 3,

    // ✅ source: jQuery Deferred로 안전하게
    source: function(event, data){
      const d = new $.Deferred();
      provider.roots()
        .then(nodes => {
          d.resolve(nodes.map(ch => ({
            title: ch.text,
            lazy: ch.children === true,
            data: {
              __path: ch.__path || [ch.text],
              pathKey: toKey(ch.__path || [ch.text]),
              leafCount: ch.leafCount || 0,
              dbId: ch.dbId,
              elementId: ch.elementId
            }
          })));
        })
        .catch(() => d.resolve([]));
      data.result = d.promise();
    },

    // ✅ lazyLoad: 역시 Deferred로
    lazyLoad: function(event, data){
      const node = data.node;
      const path = node.data?.__path || buildPathFromNode(node);
      const d = new $.Deferred();
      provider.childrenByPath(path)
        .then(children => {
          const rows = children.map(ch => {
            const __path = ch.__path || [...path, ch.text];
            return {
              title: ch.text,
              lazy: ch.children === true,
              data: {
                __path,
                pathKey: toKey(__path),
                leafCount: ch.leafCount || 0,
                dbId: ch.dbId,
                elementId: ch.elementId
              }
            };
          });
          d.resolve(rows);
        })
        .catch(() => d.resolve([]));
      data.result = d.promise();
    },

    table: { indentation: 14, nodeColumnIdx: 0 },

    // ❗ 초기 렌더에서는 '계산'을 유발하지 않는다 (프리즈 방지)
    renderColumns: function(event, data) {
      const node  = data.node;
      const $tds  = $(node.tr).find(">td");

      // 0) 타이틀 칼럼: 문서 아이콘 자리에 눈알
      const $titleCell = $tds.eq(0);
      const $nodeSpan  = $titleCell.find("> .fancytree-node");
      const $iconSpan  = $nodeSpan.find("> .fancytree-icon");
      const eyeState   = calcEyeStateForNode(node);
      $iconSpan.replaceWith(
        $(`<span class="eye-toggle ${eyeState}" title="가시성 토글">${
          eyeState === "hidden" ? EyeOff : Eye
        }</span>`)
      );

      // 1) 개수 칼럼: 항상 가운데 정렬
      const $cntCell = $tds.eq(1).removeClass("text-end").addClass("text-center");
      if (node.data?.dbId != null) {
        $cntCell.text("");
      } else {
        const cnt = node.data?.leafCount;
        $cntCell.text((typeof cnt === "number") ? String(cnt) : "…");
      }

      // 2) 현황 칼럼: 값만 표시, 계산은 expand/초기 배치에서
      const $statusCell = $tds.eq(2);
      if (node.data?.dbId != null) {
        $statusCell.text(
          formatObjectLabel({ elementId: node.data.elementId, dbId: node.data.dbId })
        );
      } else {
        // 현재 계산된 값이 있으면 클래스/숫자 적용
        const st   = getPathState(node.data?.pathKey);
        const cls  = stateToClass(st);
        $(node.tr).removeClass("wbs-c wbs-td");
        if (cls) $(node.tr).addClass(cls);

        const counts = getCounts(node.data?.pathKey);
        if (counts) {
          $statusCell.html(`
            <div class="wbs-status">
              <div class="nums">
                <span class="b c" title="시공">${counts.c ?? 0}</span>
                <span class="b t" title="가설">${counts.t ?? 0}</span>
                <span class="b d" title="철거">${counts.d ?? 0}</span>
                <span class="b td" title="혼합">${counts.td ?? 0}</span>
                <span class="b total" title="총계">${counts.total ?? 0}</span>
              </div>
            </div>
          `);
        } else {
          $statusCell.text("…");
        }
      }
    },

    // 확장할 때만: 보이는 경로들 계산 → 테이블 전체 1회 리렌더
    expand: async function(event, data) {
      try {
        const keys = [];
        data.node.visit(n => { if (n.data?.pathKey && n.lazy !== false) keys.push(n.data.pathKey); });
        await bulkEnsureForVisible(keys);
        keys.forEach(k => computePathState(k));
      } catch(e) {
        console.warn("[WBS] expand compute failed:", e);
      } finally {
        data.tree.render(true, true);
      }
    },

    // 더블클릭: 해당 경로 선택/해제 (기존 동작 유지)
    dblclick: function(event, data){
      const node = data.node;
      (async ()=>{
        const viewer = window.viewer;
        if (!viewer) return;
        let ids = [];
        if (node.data?.dbId != null) {
          ids = [node.data.dbId];
        } else {
          const path = node.data?.__path || buildPathFromNode(node);
          ids = await getAllDbIdsForPath(provider, path);
        }
        try {
          const cur = viewer.getSelection();
          const same = (cur?.length === ids.length) && cur.every((v,i)=>v===ids[i]);
          viewer.clearSelection();
          if (!same && ids?.length) viewer.select(ids);
        } catch {}
      })();
    },

    // 클릭: 확장/체크 외엔 기본 무시 (expander로만 펼치기)
    click: function(event, data){
      const t = data.targetType; // expander | title | icon | checkbox
      if (t === "expander" || t === "checkbox") return; // 기본 동작 허용
      event.preventDefault();
      return false;
    },

    // 초기 데이터가 로드되고 DOM이 안정된 뒤, 보이는 루트만 ‘한 번’ 계산
    init: function(event, data){
      setTimeout(async () => {
        try {
          const tree = data.tree;
          const keys = [];
          tree.getRootNode().children?.forEach(n => { if (n.data?.pathKey) keys.push(n.data.pathKey); });
          if (keys.length) {
            await bulkEnsureForVisible(keys);
            keys.forEach(k => computePathState(k));
            tree.render(true, true);
          }
        } catch(e) {
          console.warn("[WBS] initial compute failed:", e);
        }
      }, 0);
    }
  });

  // 눈알 토글: 위임
  $("#wbs-tree").on("click", ".eye-toggle", async (e) => {
    e.stopPropagation();
    const el = e.currentTarget;
    const node = $.ui.fancytree.getNode(el);
    if (!node) return;

    const viewer = window.viewer;
    if (!viewer) return;

    const path = node.data?.__path || buildPathFromNode(node);
    const key  = node.data?.pathKey;
    if (!key) return;

    const isHidden = HIDDEN_KEYS.has(key);
    const ids = await getAllDbIdsForPath(provider, path);
    if (!ids || !ids.length) return;

    try {
      if (isHidden) {
        viewer.show(ids);
        HIDDEN_KEYS.delete(key);
      } else {
        viewer.hide(ids);
        HIDDEN_KEYS.add(key);
      }
    } finally {
      // 자신/부모/자식 아이콘 상태 갱신
      node.visit(n => n.render(true));
      node.getParentList(false, true).forEach(p => p.render(true));
      const tree = $.ui.fancytree.getTree("#wbs-tree");
      tree.render(true, true);
    }
  });

  // Task 갱신 → 현황 반영(배치 1회)
  window.__WBS_MARK_TASKS_CHANGED = function(){
    try {
      markTasksChanged();
      const tree = $.ui.fancytree.getTree("#wbs-tree");
      const keys = [];
      tree.getRootNode().visit(n => { if (n.data?.pathKey) keys.push(n.data.pathKey); });
      bulkEnsureForVisible(keys).then(() => {
        keys.forEach(k => computePathState(k));
        tree.render(true, true);
      });
    } catch(e) {
      console.warn("[WBS] tasks changed failed:", e);
    }
  };
}
