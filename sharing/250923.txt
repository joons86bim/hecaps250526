-export function countAt(pathArr){
-  if (!Array.isArray(pathArr)) return 0;
-  if (!WbsStore.isReady) rebuildIndexFromVisibleTree();
-  const SEP = "\u0001";
-  const key = pathArr.join(SEP);
-  const ids = WbsStore.pathKeyToDbIds.get(key);
-  return Array.isArray(ids) ? ids.length : 0;
-}
+export function countAt(pathArr){
+  if (!Array.isArray(pathArr)) return 0;
+  // 아직 인덱스가 준비되지 않았으면 안전하게 0을 반환(참조 에러 방지)
+  if (!WbsStore.isReady) return 0;
+  const key = pathArr.join(SEP);
+  const ids = WbsStore.pathKeyToDbIds.get(key);
+  return Array.isArray(ids) ? ids.length : 0;
+}


// 외부 호환용(과거 코드에서 호출해도 에러 안 나게)
export function rebuildIndexFromVisibleTree() {
  // 이 스토어는 초기화 시 전체 인덱싱을 수행하므로 여기선 아무 것도 안 함
  // 필요하면 initWbsStore({eager:'tree'|'provider'})를 다시 호출하세요.
  return true;
}



-async function ensureCountsForSubtree(provider, node){
+async function ensureCountsForSubtree(provider, node, { noRender = false } = {}){
  const key  = node?.data?.pathKey;
  const path = node?.data?.__path || buildPathFromNode(node);
  if (!key || !path) return;

  if (_subtreeBusy.has(key)) return; // 중복 실행 방지
  _subtreeBusy.add(key);

  try {
    const keys = await collectAllPathKeys(provider, path);
    const uniq = Array.from(new Set(keys.length ? keys : [key]));

    if (uniq.length) {
      await bulkEnsureForVisible(uniq);
      uniq.forEach(k => computePathState(k));

      const levels = new Map();
      for (const k of uniq){
        const c = getCounts(k);
        if (c && sum3(c) > 0){
          const d = keyDepth(k);
          if (!levels.has(d)) levels.set(d, []);
          levels.get(d).push(c);
        }
      }

      let totals = { c: 0, t: 0, d: 0 };
      if (levels.size){
        const depths = Array.from(levels.keys()).sort((a,b)=>a-b);
        const deepest = depths[depths.length - 1];
        for (const raw of (levels.get(deepest) || [])) {
          const disp = toDisplayCounts(raw);
          addCounts(totals, disp);
        }
      }
      node.data.__aggCounts = totals;
    }

-    try { node.render(true); } catch {}
+    // 여기서는 렌더하지 않음(noRender 옵션으로 제어)
+    if (!noRender) {
+      const tree = node.tree;
+      // 콜스택을 벗어난 뒤 테이블 전체 1회 배치 렌더
+      setTimeout(() => { try { tree.render(true); } catch {} }, 0);
+    }
  } finally {
    setTimeout(() => _subtreeBusy.delete(key), 50);
  }
}


-    loadChildren: async function(event, data){
-      try {
-        await ensureCountsForSubtree(provider, data.node);
-      } catch (e) {
-        console.warn("[WBS] loadChildren compute failed:", e);
-      }
-    },
+    loadChildren: async function(event, data){
+      try {
+        // 계산만 하고(렌더 금지)
+        await ensureCountsForSubtree(provider, data.node, { noRender: true });
+      } catch (e) {
+        console.warn("[WBS] loadChildren compute failed:", e);
+      } finally {
+        // 콜스택을 벗어난 뒤에 테이블 전체 렌더 1회
+        const tree = data.tree;
+        setTimeout(() => { try { tree.render(true); } catch {} }, 0);
+      }
+    },


-    expand: async function(event, data) {
-      try {
-        await ensureCountsForSubtree(provider, data.node);
-      } catch(e) {
-        console.warn("[WBS] expand compute failed:", e);
-      }
-    },
+    expand: async function(event, data) {
+      try {
+        await ensureCountsForSubtree(provider, data.node, { noRender: true });
+      } catch(e) {
+        console.warn("[WBS] expand compute failed:", e);
+      } finally {
+        const tree = data.tree;
+        setTimeout(() => { try { tree.render(true); } catch {} }, 0);
+      }
+    },


-          if (!node.data.__countsRequested && key) {
+          if (!node.data.__countsRequested && key) {
             node.data.__countsRequested = true;
-            ensureCountsForNode(node)
-              .then(() => { try { node.render(true); } catch {} })
-              .finally(() => { node.data.__countsRequested = false; });
+            ensureCountsForNode(node)
+              .then(() => {
+                const tree = $.ui.fancytree.getTree("#wbs-tree");
+                setTimeout(() => { try { tree.render(true); } catch {} }, 0);
+              })
+              .finally(() => { node.data.__countsRequested = false; });
           }





