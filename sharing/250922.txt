// --- helpers for counts/state -------------------------------------------------

// 노드 1개(자기 자신만) 보장+계산
async function ensureCountsForNode(node){
  const key = node?.data?.pathKey;
  if (!key) return;
  // 이미 계산돼 있으면 스킵
  if (getCounts(key)) return;
  await bulkEnsureForVisible([key]);
  computePathState(key);
}

// provider를 통해 서브트리 전체 pathKey 수집
async function collectAllPathKeys(provider, startPath, cap = 20000) {
  const keys = [];
  const q = [startPath];
  const seen = new Set();
  while (q.length && cap > 0) {
    const p = q.shift();
    const k = toKey(p);
    if (seen.has(k)) continue;
    seen.add(k);
    keys.push(k);
    let children = [];
    try { children = await provider.childrenByPath(p) || []; } catch {}
    cap -= children.length;
    for (const ch of children) {
      const cp = ch.__path || [...p, ch.text];
      q.push(cp);
    }
  }
  return keys;
}

// 브랜치(자기+자식) 보장+계산 후, 그 브랜치만 리렌더
async function ensureCountsForSubtree(provider, node){
  const path = node?.data?.__path || buildPathFromNode(node);
  if (!path) return;

  const keys = await collectAllPathKeys(provider, path);
  const uniq = Array.from(new Set(keys));
  if (!uniq.length && node?.data?.pathKey) uniq.push(node.data.pathKey);

  if (uniq.length) {
    await bulkEnsureForVisible(uniq);
    uniq.forEach(k => computePathState(k));
  }

  try { node.render(true); } catch {}
}

// 초기 1회: 모든 루트의 전 서브트리 보장+계산 후 전체 리렌더
async function ensureCountsForAllRoots(tree, provider){
  const roots = tree.getRootNode().children || [];
  const all = [];
  for (const r of roots){
    const p = r.data?.__path || [r.title];
    const ks = await collectAllPathKeys(provider, p);
    all.push(...ks);
  }
  const uniq = Array.from(new Set(all));
  if (uniq.length) {
    await bulkEnsureForVisible(uniq);
    uniq.forEach(k => computePathState(k));
  }
  try { tree.render(true, true); } catch {}
}