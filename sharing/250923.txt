// /wwwroot/js/sidebar/task-wbs/core/wbs-store.js
// 목적: 첫 로딩시에 WBS "전체"를 인덱싱(경로 <-> dbId 맵)하여
//       이후에는 UI 확장/프로바이더 없이도 즉시 조회 가능.
// 지원 소스:
//  1) provider가 있으면 provider.roots()/childrenByPath() BFS로 전체 수집
//  2) provider가 없으면 Fancytree를 보이지 않게 deep-load 해서 전체 수집

export const WbsStore = {
  tree: null,            // Fancytree instance
  provider: null,        // { roots?, childrenByPath?, getDbIdsForPath? }
  isReady: false,

  // 인덱스
  nodesInOrder: [],      // Fancytree Node[] in document order (로깅/디버그용)
  pathKeyToDbIds: new Map(), // "A␁B␁C" -> [dbId...](자손 leaf 포함, 정렬 유지)
  dbIdToPath: new Map(),     // dbId -> ["A","B","C"]

  // 경로 → 노드 title 규칙: title > key > data.text
  normalizeLabel(n) {
    return String(n?.title ?? n?.key ?? n?.data?.text ?? "").trim();
  },
};

const SEP = "\u0001";

// === Public API ==============================================================
export async function initWbsStore({ tree, provider, eager = "auto" } = {}) {
  if (tree) WbsStore.tree = tree;
  if (provider) WbsStore.provider = provider;

  resetWbsStore();

  // 전체 인덱스 선구축
  if (eager === "provider" || (eager === "auto" && provider)) {
    await buildFullIndexFromProvider();
  } else if (eager === "tree" || (eager === "auto" && tree)) {
    await buildFullIndexFromFancytree();
  }

  // UI 이벤트에 맞춰 필요시 재색인(선택/확장 변화에 영향없도록 가볍게)
  try {
    const $root = $(WbsStore.tree?.$div || "#wbs-tree");
    $root.off(".wbsstore");
    $root.on(
      "fancytreechange.wbsstore fancytreeexpand.wbsstore fancytreecollapse.wbsstore",
      debounce(() => { /* 선택/렌더 변화: 전체 인덱스는 이미 준비돼 있으므로 noop */ }, 150)
    );
  } catch (_) {}

  WbsStore.isReady = true;
}

export function setProvider(provider) {
  WbsStore.provider = provider || null;
}

export function refreshWbsStore() {
  // 필요 시 재구축(여기서는 안전상 provider 우선)
  return initWbsStore({ tree: WbsStore.tree, provider: WbsStore.provider, eager: "auto" });
}

export function resetWbsStore() {
  WbsStore.nodesInOrder = [];
  WbsStore.pathKeyToDbIds.clear();
  WbsStore.dbIdToPath.clear();
  WbsStore.isReady = false;
}

export function pathOfNode(n) {
  const out = [];
  let cur = n;
  while (cur && typeof cur.isRoot === "function" && !cur.isRoot()) {
    out.unshift(WbsStore.normalizeLabel(cur));
    cur = cur.parent;
  }
  return out;
}

// 선택 노드(체크) 수집: includePartsel=true면 부분선택도 포함
export function getCheckedNodesInOrder({ includePartsel = true } = {}) {
  const t = WbsStore.tree;
  if (!t) return [];
  const nodes = t.getSelectedNodes?.(false) || [];
  return nodes.filter(n => (includePartsel ? true : !n.partsel));
}

/** 체크된 노드들로부터 dbId들을 "인덱스(사전 구축)"에서 바로 회수 */
export async function getOrderedDbIdsFromSelection({ includePartsel = true } = {}) {
  if (!WbsStore.isReady) await refreshWbsStore();

  const selected = getCheckedNodesInOrder({ includePartsel });
  // 문서 순서 정렬
  selected.sort((a, b) => a.getIndexHier().localeCompare(b.getIndexHier(), undefined, { numeric: true }));

  const orderedDbIds = [];
  const pathByDbId = new Map();
  const seen = new Set();

  for (const node of selected) {
    const pathArr = pathOfNode(node);
    const key = pathArr.join(SEP);
    const ids = WbsStore.pathKeyToDbIds.get(key) || [];
    for (const id of ids) {
      if (!seen.has(id)) {
        seen.add(id);
        orderedDbIds.push(id);
        pathByDbId.set(id, pathArr.slice());
      }
    }
  }
  return { orderedDbIds, pathByDbId };
}

/** (호환용) 정확히 체크(V)만 대상으로 수집 */
export async function getOrderedDbIdsFromCheckedExact() {
  return getOrderedDbIdsFromSelection({ includePartsel: false });
}

/** 특정 경로의 모든 자손 leaf dbId 반환(이미 인덱스에 있음) */
export async function getAllDescendantDbIdsByPath(pathArr) {
  if (!Array.isArray(pathArr) || !pathArr.length) return [];
  if (!WbsStore.isReady) await refreshWbsStore();
  return (WbsStore.pathKeyToDbIds.get(pathArr.join(SEP)) || []).slice();
}

// === Internal: Build Index ====================================================

async function buildFullIndexFromProvider() {
  const p = WbsStore.provider;
  if (!p || typeof p.childrenByPath !== "function") return;

  resetWbsStore();

  let roots = [];
  try {
    roots = (typeof p.roots === "function") ? (await p.roots()) : (await p.childrenByPath([]));
  } catch (_) { roots = []; }

  const queue = [];
  for (const r of (roots || [])) {
    const label = String(r?.text ?? r?.name ?? "").trim();
    const rPath = Array.isArray(r?.__path) ? r.__path : (label ? [label] : null);
    if (rPath) queue.push(rPath);
  }

  const SEP = "\u0001";

  while (queue.length) {
    const cur = queue.shift();
    const key = cur.join(SEP);

    // 가능하면 한 번에 자손 dbId를 받아서 저장(빠르고 정확)
    let got = [];
    try { got = p.getDbIdsForPath?.(cur, { includeDescendants:true, allowUnbuilt:true }) || []; } catch {}
    if (Array.isArray(got) && got.length) {
      const merged = uniqKeepOrder([...(WbsStore.pathKeyToDbIds.get(key) || []), ...got]);
      WbsStore.pathKeyToDbIds.set(key, merged);
      // dbId → leaf 경로는 children loop에서 보강됨
    }

    // children 순회로 leaf 경로/하위 큐 적재
    let children = [];
    try { children = await p.childrenByPath(cur); } catch { children = []; }

    for (const ch of (children || [])) {
      const label = String(ch?.text ?? ch?.name ?? "").trim();
      const id = Number(ch?.dbId ?? ch?.data?.dbId);
      const chPath = Array.isArray(ch?.__path) ? ch.__path : (label ? cur.concat(label) : null);

      if (Number.isFinite(id)) {
        // leaf: dbId → 정확한 경로 매핑
        if (chPath) WbsStore.dbIdToPath.set(id, chPath);
      } else if (chPath) {
        queue.push(chPath);
      }
    }
  }

  WbsStore.isReady = true;
}

async function buildFullIndexFromFancytree() {
  const t = WbsStore.tree;
  if (!t) return;

  resetWbsStore();

  // 1) 전체 로드(보이지 않게). lazy 노드는 load(true) 사용
  const root = t.getRootNode?.();
  if (!root) return;

  await deepLoadNode(root);

  // 2) 로드된 전체 트리를 순회하여 인덱싱
  root.visit(n => {
    WbsStore.nodesInOrder.push(n);
    const hasKids = (n.hasChildren && n.hasChildren());
    const id = Number(n.data?.dbId ?? n.dbId);
    if (!hasKids && Number.isFinite(id)) {
      const path = pathOfNode(n);
      WbsStore.dbIdToPath.set(id, path);
    }
  });

  // 그룹 경로마다 자손 leaf 집계
  root.visit(n => {
    const hasKids = (n.hasChildren && n.hasChildren());
    if (!hasKids) return;
    const path = pathOfNode(n);
    const key = path.join(SEP);
    const acc = [];
    n.visit(c => {
      if (c === n) return;
      const leaf = !(c.hasChildren && c.hasChildren());
      const id = Number(c.data?.dbId ?? c.dbId);
      if (leaf && Number.isFinite(id)) acc.push(id);
    });
    if (acc.length) WbsStore.pathKeyToDbIds.set(key, uniqKeepOrder(acc));
  });

  WbsStore.isReady = true;
}

// Fancytree: lazy node들을 실제로 children까지 모두 로드(확장하지 않고)
async function deepLoadNode(node) {
  // node.load(true): 데이터만 로드(렌더/확장 X) — 없으면 setExpanded 시도 후 다시 닫기
  if (node.lazy && !node.children && typeof node.load === "function") {
    try { await node.load(true); } catch(_) {}
  } else if (node.lazy && !node.children) {
    const wasExpanded = node.expanded;
    try { await node.setExpanded(true, { noAnimation: true, noEvents: true }); } catch(_) {}
    if (!wasExpanded) {
      try { await node.setExpanded(false, { noAnimation: true, noEvents: true }); } catch(_) {}
    }
  }

  if (node.children && node.children.length) {
    // chunked load 방지: 순차 await
    for (const ch of node.children) {
      await deepLoadNode(ch);
    }
  }
}

// === Utils ===================================================================
function uniqKeepOrder(arr) {
  const s = new Set(); const out = [];
  for (const x of arr) if (!s.has(x)) { s.add(x); out.push(x); }
  return out;
}

function debounce(fn, ms) {
  let t = 0;
  return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
}

// === expose to window for console/debug ======================================
if (typeof window !== "undefined") {
  window.__WBS_STORE__ = {
    WbsStore,
    initWbsStore,
    setProvider,
    refreshWbsStore,
    pathOfNode,
    getCheckedNodesInOrder,
    getOrderedDbIdsFromSelection,
    getOrderedDbIdsFromCheckedExact,
    getAllDescendantDbIdsByPath,
  };
}

export function countAt(pathArr){
  if (!Array.isArray(pathArr)) return 0;
  if (!WbsStore.isReady) rebuildIndexFromVisibleTree();
  const SEP = "\u0001";
  const key = pathArr.join(SEP);
  const ids = WbsStore.pathKeyToDbIds.get(key);
  return Array.isArray(ids) ? ids.length : 0;
}

//wwwroot/js/sidebar/task-wbs/ui/fancy-tree-init.js
import { toKey } from "../core/path-key.js";
import {
  initMatrix, 
  bulkEnsureForVisible,
  computePathState, 
  //getPathState, 
  getCounts,
  markTasksChanged
} from "../core/matrix-index.js";
//import { formatObjectLabel } from "../core/element-id.js";
//import e from "express";

const HIDDEN_KEYS = new Set();
const _subtreeBusy = new Set();
// --- 현황 계산 헬퍼 ---
function keyDepth(k){ return (k?.split("¦") || []).length; }

function addCounts(dst, src){
  if (!src) return;
  dst.c = (dst.c || 0) + Number(src.c || 0);
  dst.t = (dst.t || 0) + Number(src.t || 0);
  dst.d = (dst.d || 0) + Number(src.d || 0);
}

// 화면 표시용으로 td를 T/D에 반영
function toDisplayCounts(raw){
  if (!raw) return null;
  const td = Number(raw.td || 0);
  return {
    c: Number(raw.c || 0),
    t: Number(raw.t || 0) + td,
    d: Number(raw.d || 0) + td,
  };
}

// “데이터가 있나?” 판정할 때 td도 포함해야 함
function sum3(x){
  return Number(x?.c || 0) + Number(x?.t || 0) + Number(x?.d || 0) + Number(x?.td || 0);
}
function calcStateByCounts(counts) {
  if (!counts) return "";
  if ((counts.t || 0) > 0 && (counts.d || 0) > 0) return "TD";
  if ((counts.c || 0) > 0) return "C";
  if ((counts.t || 0) > 0) return "T";
  if ((counts.d || 0) > 0) return "D";
  return "";
}

async function ensureCountsForNode(node){
  const key = node?.data?.pathKey;
  if (!key) return;
  // 이미 계산돼 있으면 스킵
  if (getCounts(key)) return;
  await bulkEnsureForVisible([key]);
  computePathState(key);
}

function normalizeSeg(s) {
  //문자열화
  let x = (s ?? "").toString();
  //좌우 공백 제거 + 내부 연속 공백 1칸으로
  x = x.replace(/\s+/g, " ").trim();
  //유사 하이픈 (ㅡ - 등) → 일반 하이픈(-)으로 통일
  x = x.replace(/[\u2010-\u2015\u2212\u2043]/g, "-");
  //눈에 안보이는 제어문자 제거
  x = x.replace(/[\u200B-\u200D\uFEFF]/g, "");
  return x;
}

function normalizePath(pathArr) {
  return (pathArr || []).map(normalizeSeg);
}

// 브랜치(자기+자식) 보장+계산 후, 그 브랜치만 리렌더
async function ensureCountsForSubtree(provider, node){
  const key  = node?.data?.pathKey;
  const path = node?.data?.__path || buildPathFromNode(node);
  if (!key || !path) return;

  if (_subtreeBusy.has(key)) return; // 중복 실행 방지
  _subtreeBusy.add(key);

  try {
    const keys = await collectAllPathKeys(provider, path);
    const uniq = Array.from(new Set(keys.length ? keys : [key]));

    if (uniq.length) {
      // 1) 보장 + 상태계산
      await bulkEnsureForVisible(uniq);
      uniq.forEach(k => computePathState(k));

      // 2) 가장 깊은 레벨의 counts만 모아서 합산 (중복합산 방지)
      const levels = new Map(); // depth -> rawCounts[]
      for (const k of uniq){
        const c = getCounts(k);
        if (c && sum3(c) > 0){
          const d = keyDepth(k);
          if (!levels.has(d)) levels.set(d, []);
          levels.get(d).push(c);
        }
      }

      let totals = { c: 0, t: 0, d: 0 };
      if (levels.size){
        const depths = Array.from(levels.keys()).sort((a,b)=>a-b);
        const deepest = depths[depths.length - 1];

        // 화며 표시 기준: td를 T/D 양쪽에 더해준다
        for (const raw of (levels.get(deepest) || [])) {
          const disp = toDisplayCounts(raw);
          addCounts(totals, disp);
        }
      }
      node.data.__aggCounts = totals; // 폴백 합계 저장
    }

    try { node.render(true); } catch {}
  } finally {
    setTimeout(() => _subtreeBusy.delete(key), 50);
  }
}

async function ensureCountsForAllRoots(tree, provider){
  const roots = tree.getRootNode().children || [];
  const all = [];
  for (const r of roots){
    const p = r.data?.__path || [r.title];
    const ks = await collectAllPathKeys(provider, p);
    all.push(...ks);
  }
  const uniq = Array.from(new Set(all));
  if (uniq.length) {
    await bulkEnsureForVisible(uniq);
    uniq.forEach(k => computePathState(k));
  }
  try { tree.render(true, true); } catch {}
}

// -----------------------------------------------------------------------------------

// 서브트리 pathKey 전부 수집 (트리 확장 여부와 무관)
async function collectAllPathKeys(provider, startPath, cap = 20000) {
  const keys = [];
  const q = [normalizePath(startPath)];
  const seen = new Set();
  while (q.length && cap > 0) {
    const p = q.shift();
    const k = toKey(p);
    if (seen.has(k)) continue;
    seen.add(k);
    keys.push(k);
    let children = [];
    try { children = await provider.childrenByPath(p) || []; } catch {}
    cap -= children.length;
    for (const ch of children) {
      const cp = ch.__path ? normalizePath(ch.__path) : [...p, normalizeSeg(ch.text)];
      q.push(cp);
    }
  }
  return keys;
}

// 토글 전용: 미구축이면 서브트리를 강제 구축 후, 완전한 id 목록을 반환
async function getAllDbIdsForPathStrict(provider, node, path){
  const out = new Set();
  const q = [path];
  let guard = 0;
  while (q.length && guard < 50000) {
    const p = q.shift();
    //현재 경로의 직접 매핑 강제 확보
    let here = provider.getDbIdsForPath(p, { includeDescendants:false, allowUnbuilt:true }) || [];
    if (!here.length) {
      //그룹노드 보정: 자손 매핑이라도 즉시 반영
      here = provider.getDbIdsForPath(p, { includeDescendants:true, allowUnbuilt:true }) || [];
    }
    for (const id of here) out.add(id);
    //자식 로드 & 큐잉
    let children = [];
    try { children = await provider.childrenByPath(p) || []; } catch {}
    for (const ch of children) {
      const cp = ch.__path || [...p, ch.text];
      q.push(cp);
    }
    guard += children.length + here.length;
  }
  //마지막으로 '완전체'가 있으면 합쳐서 반환
  const all = provider.getDbIdsForPath(path, { includeDescendants:true, allowUnbuilt:true }) || [];
  for (const id of all) out.add(id);
  return Array.from(out);
}

// 지정 경로의 자손들을 제한적으로 미리 로드 (BFS)
async function warmupDescendants(provider, path, maxDepth = 6, cap = 1200) {
  const q = [{ path, depth: 0 }];
  let seen = 0;
  while (q.length && seen < cap) {
    const { path: p, depth } = q.shift();
    let children = [];
    try { children = await provider.childrenByPath(p) || []; } catch {}
    seen += children.length;
    if (depth >= maxDepth) continue;
    for (const ch of children) {
      if (ch?.children === true) {
        const np = ch.__path || [...p, ch.text];
        q.push({ path: np, depth: depth + 1 });
      }
    }
  }
}

// 현재 노드의 눈알 아이콘(class/markup)만 즉시 갱신
function updateEyeDom(n) {
  if (!n?.span) return;
  const s = calcEyeStateForNode(n);
  const $nodeSpan = $(n.span);                              // .fancytree-node 자체
  let $eye = $nodeSpan.children(".eye-toggle");             // 직계의 eye-toggle
  const icon = (s === "none") ? Eye : EyeOff; // 아이콘 결정

  if ($eye.length === 0) {
    const $icon = $nodeSpan.children(".fancytree-icon");    // 기본 아이콘
    $icon.hide().addClass("eye-hidden");
    $eye = $(`<span class="eye-toggle ${s}" title="가시성 토글">${icon}</span>`);
    $icon.before($eye);                                     // 아이콘 앞에 삽입
  } else {
    $eye.removeClass("mixed none").addClass(s).html(icon);   // 상태만 갱신
  }
}

function buildPathFromNode(node){
  const out = [];
  let cur = node;
  while (cur && !cur.isRoot()) {
     out.unshift(normalizeSeg(cur.title));
     cur = cur.parent; 
  }
  return out;
}
function stateToClass(st){
  if (st === "C") return "wbs-c";
  // if (st === "T") return "wbs-t";
  // if (st === "D") return "wbs-d";
  if (st === "TD" || st === "T" || st === "D") return "wbs-td";
  return "";
}

//값이 Promise든 배열이든/undefined든 전부 Promise로 감싸서 처리
function asPromise(v){
  return (v && typeof v.then === "function") ? v : Promise.resolve(v);
}

// 눈알 SVG
const Eye = `
<svg viewBox="0 0 24 24" aria-hidden="true">
  <path d="M12 5c5 0 9 4 10 7-1 3-5 7-10 7S3 15 2 12c1-3 5-7 10-7Zm0 3a4 4 0 100 8 4 4 0 000-8Z"/>
</svg>`;
const EyeOff = `
<svg viewBox="0 0 24 24" aria-hidden="true">
  <path d="M3 3l18 18M10.58 10.58A4 4 0 0012 16a4 4 0 002.83-6.83M12 5c5 0 9 4 10 7-.43 1.28-1.33 2.7-2.6 3.98M6.62 6.62C4.62 8.05 3.28 9.94 2 12c1 3 5 7 10 7 1.28 0 2.5-.22 3.62-.62"/>
</svg>`;

// 경로→dbId 수집 (click/dblclick 때만 호출: 초기 렌더에는 안 돌게)
async function getAllDbIdsForPath(provider, path){
  let ids = provider.getDbIdsForPath(path, { includeDescendants:true, allowUnbuilt:true });
  if (ids != null) return ids;
  try { await warmupDescendants(provider, path, 6, 1200); } catch {}
  ids = provider.getDbIdsForPath(path, { includeDescendants:true, allowUnbuilt:true });
  if (ids != null) return ids;
  return provider.getDbIdsForPath(path, { includeDescendants:true, allowUnbuilt:false }) || [];
}

function calcEyeStateForNode(node){
  const key = node.data?.pathKey;
  if (!key) return "none";
  if (HIDDEN_KEYS.has(key)) return "mixed"; //자기자신이 숨김 상태면, 자식 로드 여부와 무관하게 'mixed'로 취급

  // 1) 부모중 하나라도 숨김이면 이 노드는 mixed으로 처리
  const ancestors = node.getParentList(false, true) || [];
  for (const p of ancestors) {
    const k = p.data?.pathKey;
    if (k && HIDDEN_KEYS.has(k)) return "mixed";
  }

  // 2) 자손 기준으로 혼합/숨김 판정
  let anyHidden = false;
  node.visit(n => {
    const k = n.data?.pathKey;
    if (!k) return;
    if (HIDDEN_KEYS.has(k)) {
      anyHidden = true;
    }
  });
  return anyHidden ? "mixed" : "none";
}

export async function initWbsWithFancytree(provider, { primaryOrder } = {}) {
  if(!window.__MATRIX_READY) {
    await initMatrix({ primaryOrder, provider });
    window.__MATRIX_READY = true;
  }
  // 테이블 뼈대(개수 가운데 정렬: th에 text-center)
  const host = document.getElementById("wbs-group-content");
  host.innerHTML = `
    <table id="wbs-tree" class="table table-sm wbs-table">
      <colgroup>
        <col class="col-title" />
        <col class="col-count" />
        <col class="col-status" />
      </colgroup>
      <thead>
        <tr>
          <th>항목</th>
          <th class="text-center">개수</th>
          <th>현황</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  `;

  $("#wbs-tree").fancytree({
    extensions: ["table", "gridnav"],   // ❗ checkbox 확장 넣지 마세요
    checkbox: true,                     // 체크박스는 옵션으로만
    selectMode: 3,

    // ✅ source: jQuery Deferred로 안전하게
    source: function(event, data){
      const d = new $.Deferred();
      try{
        asPromise(provider?.roots?.()).then((nodes) => {
          const arr = Array.isArray(nodes) ? nodes : [];
          d.resolve(arr.map(ch => {
            const basePath = ch.__path ? normalizePath(ch.__path) : [normalizeSeg(ch.text)];
            return {
              title: ch.text,
              lazy: ch.children === true,
              data: {
                __path: basePath,
                pathKey: toKey(basePath),
                leafCount: ch.leafCount || 0,
                dbId: ch.dbId,
                elementId: ch.elementId
              }
            }
          }));
        }).catch(() => d.resolve([]));
      } catch {
        d.resolve([]);
      }
      return d.promise();
    },

    // ✅ lazyLoad: 역시 Deferred로
    lazyLoad: function(event, data){
      const node = data.node;
      const path = node.data?.__path || buildPathFromNode(node);
      const d = new $.Deferred();
      try {
        asPromise(provider?.childrenByPath?.(path)).then((children)=>{
          const arr = Array.isArray(children) ? children : [];
          d.resolve(arr.map(ch => {
            const seg    = normalizeSeg(ch.text);
            const __path = ch.__path ? normalizePath(ch.__path) : [...path, seg];
            return {
              title: seg,
              lazy: ch.children === true,
              data: {
                __path,
                pathKey: toKey(__path),
                leafCount: ch.leafCount || 0,
                dbId: ch.dbId,
                elementId: ch.elementId
              }
            };  
          }));
        }).catch(() => d.resolve([]));
      } catch {
        d.resolve([]);
      }
      data.result = d.promise();
    },

    loadChildren: async function(event, data){
      try {
        // const rootPath = data.node.data?.__path || buildPathFromNode(data.node);
        // //브랜치 전체 (본인+자손)의 pathKey 수집
        // const allKeys = await collectAllPathKeys(provider, rootPath, 8000);
        // await bulkEnsureForVisible(allKeys);
        // allKeys.forEach(k => computePathState(k));
        // setTimeout(() => {
        //   try { data.node.render(true); } catch {}
        // }
        // , 0);
        await ensureCountsForSubtree(provider, data.node);
      } catch (e) {
        console.warn("[WBS] loadChildren compute failed:", e);
      }
    },

    table: { indentation: 14, nodeColumnIdx: 0 },

    // ❗ 초기 렌더에서는 '계산'을 유발하지 않는다 (프리즈 방지)
    renderColumns: function(event, data) {
      const node  = data.node;
      const $tds  = $(node.tr).find(">td");

      // 0) 타이틀 칼럼: 문서 아이콘 자리에 눈알
      const $titleCell = $tds.eq(0);
      const $nodeSpan  = $(node.span);
      const eyeState   = calcEyeStateForNode(node);
      const $eye       = $nodeSpan.children(".eye-toggle");
      const icon       = (eyeState === "none") ? Eye : EyeOff;

      if ($eye.length) {
        // 이미 눈알 있음 -> 상태 / 아이콘만 업데이트
        $eye
          .removeClass("mixed none")
          .addClass(eyeState)
          .attr("title", "가시성 토글")
          .html(icon);
      } else {
        // 최초 1회: 문서아이콘은 숨기고 (삭제 X), 그 앞에 눈알 삽입
        const $iconSpan  = $nodeSpan.children(".fancytree-icon");
        $iconSpan.hide().addClass("eye-hidden");
        $iconSpan.before(
          $(`<span class="eye-toggle ${eyeState}" title="가시성 토글">${
            icon}</span>`)
        );
      }

      // 1) 개수 칼럼: 항상 가운데 정렬
      const $cntCell = $tds.eq(1).removeClass("text-end").addClass("text-center");
      if (node.data?.dbId != null) {
        $cntCell.text("");
      } else {
        const cnt = node.data?.leafCount;
        $cntCell.text((typeof cnt === "number") ? String(cnt) : "…");
      }

      // 2) 현황 칼럼: 값만 표시, 계산은 expand/초기 배치에서
      const $statusCell = $tds.eq(2);
      if (node.data?.dbId != null) {
        $statusCell.text(""); // 말단은 빈칸
      } else {
        const key = node.data?.pathKey;
      
        // 2-0 숫자 확보: getCounts의 {total,c,t,d,td} → 화면표시용 {c,t,d}로 변환
        //  - td(가설&철거 동시)는 T/D 양쪽에 더해 표기
        const raw = key && getCounts(key);        // { total, c, t, d, td }
        let counts = toDisplayCounts(raw);         // { c, t, d } (td가 t/d에 반영됨)
      
        // 부모 직접값이 0이면 서브트리 집계(__aggCounts)로 폴백
        if ((!counts || sum3(counts) === 0) && node.data?.__aggCounts) {
          counts = node.data.__aggCounts;          // __aggCounts는 이미 {c,t,d}
        }
      
        // 2-1 상태(색칠): counts 기준 (t>0 && d>0 → 'TD')
        const st  = calcStateByCounts(counts);
        const cls = stateToClass(st);
        $(node.tr).removeClass("wbs-c wbs-t wbs-d wbs-td");
        if (cls) $(node.tr).addClass(cls);
      
        // 2-2 숫자 렌더
        if (counts && (typeof counts.c === "number" || typeof counts.t === "number" || typeof counts.d === "number")) {
          $statusCell
            .addClass("text-center")
            .html(`
              <div class="wbs-status" style="justify-content: center;">
                <div class="nums">
                  <span class="b c" title="시공">${counts.c ?? 0}</span>
                  <span class="b t" title="가설">${counts.t ?? 0}</span>
                  <span class="b d" title="철거">${counts.d ?? 0}</span>
                </div>
              </div>
            `);
        } else {
          $statusCell.text("…");
          if (!node.data.__countsRequested && key) {
            node.data.__countsRequested = true;
            ensureCountsForNode(node)
              .then(() => { try { node.render(true); } catch {} })
              .finally(() => { node.data.__countsRequested = false; });
          }
        }
      
        // 2-3 숫자/상태 불일치 자동 복구 (1회)
        if (key) {
          const totalShown = (counts?.c || 0) + (counts?.t || 0) + (counts?.d || 0);
          const likelyWrong =
            ((node.data?.leafCount || 0) > 0) &&
            totalShown === 0 &&
            !node.data.__countsRepairOnce;
      
          if (likelyWrong) {
            node.data.__countsRepairOnce = true;
            ensureCountsForSubtree(provider, node)
              .then(() => { try { node.render(true); } catch {} })
              .finally(() => { node.data.__countsRepairOnce = false; });
          }
        }
      }
    },

    // 확장할 때만: 보이는 경로들 계산 → 테이블 전체 1회 리렌더
    expand: async function(event, data) {
      try {
        await ensureCountsForSubtree(provider, data.node);
      } catch(e) {
        console.warn("[WBS] expand compute failed:", e);
      }
    },

    // 더블클릭: 해당 경로 선택/해제 (기존 동작 유지)
    dblclick: function(event, data){
      const node = data.node;
      (async ()=>{
        const viewer = window.viewer;
        if (!viewer) return;
        let ids = [];
        if (node.data?.dbId != null) {
          ids = [node.data.dbId];
        } else {
          const path = node.data?.__path || buildPathFromNode(node);
          ids = await getAllDbIdsForPath(provider, path);
        }
        try {
          const cur = viewer.getSelection();
          const same = (cur?.length === ids.length) && cur.every((v,i)=>v===ids[i]);
          viewer.clearSelection();
          if (!same && ids?.length) viewer.select(ids);
        } catch {}
      })();
      //기본 더블클릭 동작 (확장/축소) 차단
      if (event?.preventDefault) event.preventDefault();
      if (data?.originalEvent?.preventDefault) data.originalEvent.preventDefault();
      return false;
    },

    // 클릭: 확장/체크 외엔 기본 무시 (expander로만 펼치기)
    click: function(event, data){
      const t = data.targetType; // expander | title | icon | checkbox
      if (t === "expander" || t === "checkbox") return; // 기본 동작 허용
      event.preventDefault();
      return false;
    },

    // 초기 데이터가 로드되고 DOM이 안정된 뒤, 보이는 루트만 ‘한 번’ 계산
    init: function(event, data){
      setTimeout(async () => {
        try {
          // 루트들 전체 서브트리 키를 provider 통해 수집해서 한번에 보장/계산
          await ensureCountsForAllRoots(data.tree, provider);
        } catch(e) {
          console.warn("[WBS] initial compute failed:", e);
        }
      }, 0);
    },

    select: function(event, data){
      //선택 토글 후, 현재 노드 + 상위 경로만 재렌더해서 상태 클래스(wbs-*)를 즉시 복구
      setTimeout(() => {
        try { data.node.render(true);} catch {}
        try {
          const parents = data.node.getParentList(false, true) || [];
          parents.forEach(p => { try { p.render(true);} catch {}})
        } catch {}
      }, 0);
    }

  });

  window.wbsTree = $.ui.fancytree.getTree("#wbs-tree");

  //디버깅
  window.__WBS_DEBUG = {
    tree: () => $.ui.fancytree.getTree("#wbs-tree"),
    provider,
    getCounts,
    computePathState,
    bulkEnsureForVisible,
    collectAllPathKeys,
    ensureCountsForSubtree,
    ensureCountsForNode,
    toKey
  };

  // 눈알 토글: 위임
  $("#wbs-tree").on("click", ".eye-toggle", async (e) => {
    e.stopPropagation();
    const el = e.currentTarget;
    const node = $.ui.fancytree.getNode(el);
    if (!node) return;
  
    const viewer = window.viewer;
    if (!viewer) return;
  
    const state   = calcEyeStateForNode(node);
    const hideAll = (state === "none");         // none → 숨기기, mixed → 보이기
  
    const path   = node.data?.__path || buildPathFromNode(node);
    const idsAll = await getAllDbIdsForPathStrict(provider, node, path);
    if (!idsAll?.length) return;
    const allKeys = await collectAllPathKeys(provider, path);
    
    console.debug("[eye] hideAll=", hideAll, "ids=", idsAll.length, idsAll.slice(0, 10));

    try {
      if (hideAll) {
        viewer.hide(idsAll);
        allKeys.forEach(k => HIDDEN_KEYS.add(k));
      } else {
        viewer.show(idsAll);
        allKeys.forEach(k => HIDDEN_KEYS.delete(k));
      }
    } finally {
      // 즉시 : 자신/자식들 아이콘 갱신 + 해당 행/부모행 재렌더 (행 단위라 안전)
      node.visit(updateEyeDom);
      node.getParentList(false, true)?.forEach(updateEyeDom);
      try { node.render(true); } catch {}
      try { node.getParentList(false, true)?.forEach(p => p.render(true)); } catch {}
    }
  });

  // Task 갱신 → 현황 반영(배치 1회)
  window.__WBS_MARK_TASKS_CHANGED = function(){
    try {
      markTasksChanged();
      const tree = $.ui.fancytree.getTree("#wbs-tree");
      if (!tree) return;
      const keys = [];
      tree.getRootNode().visit(n => { if (n.data?.pathKey) keys.push(n.data.pathKey); });
      bulkEnsureForVisible(keys).then(() => {
        keys.forEach(k => computePathState(k));
        tree.render(true, true);
      });
    } catch(e) {
      console.warn("[WBS] tasks changed failed:", e);
    }
  };
}


