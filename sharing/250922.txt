// wbs-store.js
(function(global){
  const PHASE_MAP = { '시공': 'c', '가설': 't', '철거': 'd' };
  // 창 카테고리로 인정할 목록(현장에 맞게 추가/삭제 가능)
  const WINDOW_WHITELIST = new Set(['Window','Curtain Panel','Generic Models','Curtain Wall Mullion']);

  const norm = (s) => (s ?? '')
    .toString()
    .normalize('NFC')
    .replace(/\s+/g, ' ')
    .trim();

  const makePathKey = (path) => norm(Array.isArray(path) ? path.join(' / ') : path);
  const inc = (obj, k, v=1) => (obj[k] = (obj[k] || 0) + v);

  function makeZero() { return { c:0, t:0, d:0, total:0, dbIds:[] }; }
  function addAgg(dst, src){
    dst.c += src.c; dst.t += src.t; dst.d += src.d; dst.total += src.total;
    if (src.dbIds && src.dbIds.length) dst.dbIds.push(...src.dbIds);
    return dst;
  }

  /**
   * ⚠️ 여기 필드 매핑만 본인 데이터 구조에 맞게 확인하세요.
   * elements: [
   *  { dbId, wbsPath, top, category, familyName, typeName, workPhase }, ...
   * ]
   * - 이름이 다르면 아래 루프 안에서 e.xxx 읽는 부분만 고치면 됩니다.
   */
  function buildIndexes(elements){
    const byPathAgg = new Map();      // path prefix -> 합계(상위노드까지 함께)
    const byFamTypeAgg = new Map();   // "family::type" -> 합계 (창)
    const elementsByPath = new Map(); // leaf 조회용
    const elementsByFamType = new Map();

    for (const e of elements){
      // ▼▼▼▼▼ 여기서 자기 데이터 구조에 맞게 키만 맞춰주세요 ▼▼▼▼▼
      const dbId = e.dbId ?? e.dbid ?? e.id;
      const rawPath = e.wbsPath || e.path || e.wbs_path;  // WBS 경로
      const cat = norm(e.category);
      const top = norm(e.top);
      const family = norm(e.familyName || e.family || e.family_name);
      const type = norm(e.typeName || e.type || e.type_name);
      const phaseKey = PHASE_MAP[e.workPhase] || 'c';
      // ▲▲▲▲▲ 여기까지 ▲▲▲▲▲

      const unit = { c:0, t:0, d:0, total:1, dbIds:[dbId] };
      unit[phaseKey] = 1;

      // 1) 경로 prefix에 누적(상위 노드 집계 자동 보장)
      if (rawPath){
        const parts = norm(rawPath).split('/').map(s=>s.trim()).filter(Boolean);
        let acc = [];
        for (let i=0;i<parts.length;i++){
          acc.push(parts[i]);
          const key = makePathKey(acc);
          const agg = byPathAgg.get(key) || makeZero();
          addAgg(agg, unit);
          byPathAgg.set(key, agg);
        }
        const leafKey = makePathKey(parts);
        const arr = elementsByPath.get(leafKey) || [];
        arr.push({ dbId, top, cat, family, type, phaseKey, rawPath });
        elementsByPath.set(leafKey, arr);
      }

      // 2) 창은 Family+Type 기준 합계도 병행
      if (WINDOW_WHITELIST.has(cat) || top === '창'){
        if (family || type){
          const k = `${family}::${type}`;
          const agg = byFamTypeAgg.get(k) || makeZero();
          addAgg(agg, unit);
          byFamTypeAgg.set(k, agg);

          const arr2 = elementsByFamType.get(k) || [];
          arr2.push({ dbId, top, cat, family, type, phaseKey, rawPath });
          elementsByFamType.set(k, arr2);
        }
      }
    }

    return { byPathAgg, byFamTypeAgg, elementsByPath, elementsByFamType };
  }

  // (누락되어 터지던) 가시 트리 기준 dbId 인덱스 재작성
  function rebuildIndexFromVisibleTree(tree){
    const map = new Map();
    tree.visit(node => {
      let ids = [];
      if (Array.isArray(node.data?.dbIds)) ids = node.data.dbIds.slice();
      if (node.children && node.children.length){
        for (const ch of node.children){
          if (Array.isArray(ch.data?.dbIds)) ids.push(...ch.data.dbIds);
        }
      }
      node.data = node.data || {};
      node.data.dbIds = ids;
      map.set(node.key, ids);
    });
    return map;
  }

  class WbsStore {
    constructor(){
      this.isReady = false;
      this.index = null;
      this.visibleDbIndex = null;
      this._tree = null;
    }
    attachTree(tree){ this._tree = tree; }

    // elements: 위 설명 참조
    refresh(elements){
      this.index = buildIndexes(elements || []);
      this.isReady = true;
      return true;
    }

    // FancytreeNode -> 집계
    countAt(node){
      if (!this.isReady || !this.index) return makeZero();

      const top = norm(node.data?.top || node.parent?.data?.top || node.parent?.title);
      const family = norm(node.data?.family || node.data?.familyName);
      const type = norm(node.data?.type || node.data?.typeName);
      const pathKey = makePathKey(node.data?.path || node.data?.wbsPath || node.data?.titlePath || node.title);

      // 창 leaf: Family+Type 우선
      if (top === '창' && (family || type)){
        const k = `${family}::${type}`;
        const agg = this.index.byFamTypeAgg.get(k);
        if (agg) {
          const ids = (this.index.elementsByFamType.get(k)||[]).map(x=>x.dbId);
          return { ...agg, dbIds: ids };
        }
      }

      // 그 외: 경로 prefix
      if (pathKey){
        const agg = this.index.byPathAgg.get(pathKey);
        if (agg) {
          const ids = (this.index.elementsByPath.get(pathKey)||[]).map(x=>x.dbId);
          return { ...agg, dbIds: ids };
        }
      }

      // 마지막 폴백: 보이는 서브트리 취합
      if (this._tree){
        const ids = [];
        node.visit(n => { if (Array.isArray(n.data?.dbIds)) ids.push(...n.data.dbIds); });
        const uniq = Array.from(new Set(ids));
        return { c:0, t:0, d:0, total:uniq.length, dbIds:uniq };
      }
      return makeZero();
    }

    // 트리 전체에 counts/dbIds를 채움(렌더 호출 안 함)
    populateCountsForTree(tree){
      this.attachTree(tree);
      tree.visit(node => {
        const agg = this.countAt(node);
        node.data = node.data || {};
        node.data.dbIds = agg.dbIds;
        node.data.counts = { c:agg.c, t:agg.t, d:agg.d, total:agg.total };
      });
      this.visibleDbIndex = rebuildIndexFromVisibleTree(tree);
    }
  }

  // 전역 export(기존 코드와 호환)
  const store = new WbsStore();
  global.__WBS_STORE__ = Object.assign(global.__WBS_STORE__ || {}, {
    WbsStore: store,
    refreshWbsStore: (...args) => store.refresh(...args),
    countAt: (node) => store.countAt(node),
    rebuildIndexFromVisibleTree: (tree) => (store.visibleDbIndex = rebuildIndexFromVisibleTree(tree)),
    populateCountsForTree: (tree) => store.populateCountsForTree(tree),
  });
})(window);


// fancy-tree-init.js
// 필요한 경우 상단에 유틸 import
// import $ from "jquery";

function paintCounts(node){
  const counts = node.data?.counts || {c:0,t:0,d:0,total:0};
  const $tr = $(node.tr);
  if (!$tr || !$tr.length) return;
  const $tds = $tr.find(">td");
  // [0]=타이틀, [1]=합계, [2]=상태칸(.b.c/.b.t/.b.d)
  $tds.eq(1).text(counts.total);
  const $status = $tds.eq(2);
  $status.find(".b.c").text(counts.c);
  $status.find(".b.t").text(counts.t);
  $status.find(".b.d").text(counts.d);
}

function ensureCountsForSubtree(node){
  const tree = node.tree;
  tree.enableUpdate(false);
  node.visit(n => {
    const agg = window.__WBS_STORE__?.countAt(n);
    n.data = n.data || {};
    n.data.dbIds = agg.dbIds;
    n.data.counts = { c:agg.c, t:agg.t, d:agg.d, total:agg.total };
    paintCounts(n);
  });
  tree.enableUpdate(true);
}

export const fancytreeOptions = {
  // ...기존 옵션 유지...
  extensions: ["table" /*, ...*/],

  // 컬럼 숫자 채우기 (여기서는 렌더만 한다: 계산 X)
  renderColumns: function(event, data){
    paintCounts(data.node);
  },

  // ⚠️ lazyLoad에서는 절대 node.render()/tree.render() 호출하지 마세요
  lazyLoad: async function(event, data){
    const node = data.node;
    const children = await fetchChildren(node); // ← 기존 비동기 로더 그대로 사용
    data.result = children; // 데이터만 넘김
    // 여기서 DOM 재렌더 호출 금지!
  },

  // 자식 로딩 끝난 뒤, 트리 전체 카운트/DBID 채우고 딱 한 번만 렌더
  loadChildren: function(event, data){
    const tree = data.tree;
    tree.enableUpdate(false);
    window.__WBS_STORE__?.populateCountsForTree(tree); // 계산/주입
    tree.enableUpdate(true);
    tree.render(true); // 한 번만
  },

  // 초기화 시에도 한 번만
  init: function(event, data){
    const tree = data.tree;
    if (window.__WBS_STORE__?.WbsStore?.isReady){
      tree.enableUpdate(false);
      window.__WBS_STORE__?.populateCountsForTree(tree);
      tree.enableUpdate(true);
      tree.render(true);
    }
  }
};

// 필요하면 다른 파일에서 import해서 사용
export { paintCounts, ensureCountsForSubtree };


// main.js
import { paintCounts } from './fancy-tree-init.js';

function countsForPath(node){
  const agg = window.__WBS_STORE__?.countAt(node);
  return agg || { c:0, t:0, d:0, total:0, dbIds:[] };
}

function repaintNode(node){
  const agg = countsForPath(node);
  node.data = node.data || {};
  node.data.dbIds = agg.dbIds;
  node.data.counts = { c:agg.c, t:agg.t, d:agg.d, total:agg.total };
  paintCounts(node); // DOM에 숫자만 반영 (렌더 호출 X)
}

function repaintTree(){
  const tree = $("#wbs").fancytree("getTree");
  tree.enableUpdate(false);
  tree.visit(n => repaintNode(n));
  tree.enableUpdate(true);
}

// 패널 준비 이후 한 번 전체 반영
document.addEventListener('panel2-ready', ()=>{
  const tree = $("#wbs").fancytree("getTree");
  window.__WBS_STORE__?.populateCountsForTree(tree);
  repaintTree();
});
