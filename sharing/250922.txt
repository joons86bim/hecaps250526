// /wwwroot/js/task-wbs/4d/4d-simulation.js
// 공개 API:
//   apply4DAt(viewer, dateISO, config)
//   reset4D(viewer)
//
// config 기본값
// {
//   zOffset: 3.0,              // m 단위(모델이 mm면 3000 등)
//   useDateDuration: true,     // true: 작업 시작~끝 날짜 비율 사용, false: 고정시간 압축
//   fixedDurationSec: 2.0,     // useDateDuration=false일 때 1개 작업의 가상 진행 시간(초)
//   speedDaysPerSec: 1.0,      // 재생속도(초당 며칠) — 참조용
//   syncThemingAlpha: true     // true: in-range 테마 색상의 alpha도 같이 페이드
// }

let _globalState = new Map(); // key: model.id

export function reset4D(viewer) {
  const model = (viewer.getVisibleModels?.()[0]) || viewer.model;
  if (!model) return;
  const st = _globalState.get(model.id);
  if (!st) return;

  const { store } = st;
  const fragList = _getFragList(viewer, model);

  for (const f of store.items) {
    try {
      f.proxy.position.copy(f.startPos);
      f.proxy.updateAnimTransform();

      if (f.originalMat) {
        if (viewer.impl.setMaterial) viewer.impl.setMaterial(model, f.fragId, f.originalMat);
        else if (fragList?.setMaterial) fragList.setMaterial(f.fragId, f.originalMat);
        else if (viewer.impl.setFragmentMaterial) viewer.impl.setFragmentMaterial(f.fragId, f.originalMat);
      }
      if (f.cloneMat?.dispose) f.cloneMat.dispose();
      f.cloneMat = null;
    } catch(_) {}
  }
  viewer.impl.invalidate?.(true, true, true);
  _globalState.delete(model.id);
}

export function apply4DAt(viewer, dateISO, config = {}) {
  const cfg = {
    zOffset: 3.0,
    useDateDuration: true,
    fixedDurationSec: 2.0,
    speedDaysPerSec: 1.0,
    syncThemingAlpha: true,
    ...config,
  };

  if (!viewer || !dateISO) return;
  const model = (viewer.getVisibleModels?.()[0]) || viewer.model;
  if (!model) return;

  // 캐시
  let state = _globalState.get(model.id);
  if (!state) {
    const schedule = _buildScheduleFromTaskTree(model);
    const store = _prepareStore(viewer, model, schedule);
    state = { schedule, store };
    _globalState.set(model.id, state);
  }
  const { schedule, store } = state;
  if (!schedule.items.length) return;

  const nowMs = Date.parse(dateISO);
  const msPerDay = 86400000;

  // 카테고리별 테마 컬러(정책과 동일)
  const V4 = (r,g,b,a=1) => (window.THREE ? new window.THREE.Vector4(r,g,b,a) : { r,g,b,a });
  const cByCat = {
    C: V4(0.16, 0.57, 0.20, 1), // 녹
    T: V4(0.12, 0.45, 0.90, 1), // 청
    D: V4(0.95, 0.27, 0.23, 1), // 적
  };

  for (const it of schedule.items) {
    // 기간 결정(고정시간 모드면 end 대체)
    const endMsEff = cfg.useDateDuration
      ? it.endMs
      : (it.startMs + cfg.fixedDurationSec * 1000 * cfg.speedDaysPerSec); // 재생속도는 참고값

    const denom = Math.max(1, endMsEff - it.startMs);
    const p = _norm01((nowMs - it.startMs) / denom);

    let alpha = 1.0, dz = 0.0;
    const zOff = cfg.zOffset;

    if (it.cat === 'C' || it.cat === 'T') {
      if (nowMs < it.startMs) {
        alpha = 0.0; dz = zOff;
      } else if (nowMs <= endMsEff) {
        alpha = p; dz = _lerp(zOff, 0, p);
      } else {
        alpha = 1.0; dz = 0.0;
      }
    } else { // 'D'
      if (nowMs < it.startMs) {
        alpha = 1.0; dz = 0.0;
      } else if (nowMs <= endMsEff) {
        alpha = 1.0 - p; dz = _lerp(0, zOff, p);
      } else {
        alpha = 0.0; dz = zOff;
      }
    }

    // 대상 dbId → frag 상태 반영
    const fragsByDb = store.byDb;
    for (const dbId of it.dbIds) {
      const frags = fragsByDb.get(dbId);
      if (!frags) continue;

      for (const f of frags) {
        try {
          f.proxy.position.z = f.startPos.z + dz;
          f.proxy.updateAnimTransform();

          if (f.cloneMat) {
            f.cloneMat.opacity = alpha;
            f.cloneMat.transparent = true;
            f.cloneMat.depthWrite = false;
            f.cloneMat.needsUpdate = true;
          }
        } catch(_) {}
      }

      // (선택) 테마 알파 동기화 — 색상은 기존 정책값 유지, 알파만 덮어씀
      if (cfg.syncThemingAlpha) {
        const col = cByCat[it.cat];
        if (col) {
          const vv = V4(col.x ?? col.r, col.y ?? col.g, col.z ?? col.b, alpha);
          try { viewer.setThemingColor(dbId, vv, model); } catch(_) {}
        }
      }
    }
  }

  viewer.impl.invalidate?.(true, true, true);
}

/* ------------------ 내부 구현 ------------------ */

function _buildScheduleFromTaskTree(model) {
  const urnCur = String(window.CURRENT_MODEL_URN || "");
  const tree = window.taskTree;

  const items = [];
  const normCat = (v) => {
    const s = String(v || "").trim();
    if (s === "C" || s.startsWith("시공")) return "C";
    if (s === "T" || s.startsWith("가설")) return "T";
    if (s === "D" || s.startsWith("철거")) return "D";
    return "";
  };
  const isISO = (s) => /^\d{4}-\d{2}-\d{2}$/.test(String(s||""));

  if (tree?.getRootNode) {
    tree.getRootNode()?.visit((n) => {
      const d = n.data || {};
      const cat = normCat(d.selectedOption);
      if (!cat) return;
      if (!isISO(d.start) || !isISO(d.end)) return;

      const objs = Array.isArray(d.linkedObjects) ? d.linkedObjects : [];
      const dbIds = [];
      for (const o of objs) {
        const urn = String(o.urn || urnCur);
        if (urnCur && urn !== urnCur) continue;
        const id = Number(o.dbId);
        if (Number.isFinite(id)) dbIds.push(id);
      }
      if (!dbIds.length) return;

      items.push({
        cat,
        startMs: Date.parse(d.start + "T00:00:00Z"),
        endMs:   Date.parse(d.end   + "T23:59:59Z"),
        dbIds
      });
    });
  }
  return { items };
}

function _prepareStore(viewer, model, schedule) {
  const THREE = window.THREE || Autodesk.Viewing.THREE;
  const matman = viewer.impl.matman ? viewer.impl.matman() : null;
  const fragList = _getFragList(viewer, model);
  const it = model.getData().instanceTree;

  const byDb = new Map();
  const items = [];
  const fragIdToDb = new Map(); // ★ 누락되던 매핑을 직접 구축

  // 1) dbId → fragId 수집 + 매핑 구성
  const uniqDb = new Set();
  for (const s of schedule.items) for (const id of s.dbIds) uniqDb.add(id);

  uniqDb.forEach((dbId) => {
    const list = [];
    it.enumNodeFragments(dbId, (fragId) => {
      list.push(fragId);
      fragIdToDb.set(fragId, dbId); // ★ 직접 매핑
    }, true);
    if (list.length) byDb.set(dbId, []); // 나중에 frag 객체 채움
  });

  // 2) 모든 fragId에 대해 프록시/머티리얼 클론 생성
  const allFragIds = [...fragIdToDb.keys()];
  for (const fragId of allFragIds) {
    const proxy = viewer.impl.getFragmentProxy(model, fragId);
    proxy.getAnimTransform();
    const startPos = new THREE.Vector3(proxy.position.x, proxy.position.y, proxy.position.z);

    const rp = viewer.impl.getRenderProxy(model, fragId);
    const originalMat = rp?.material || null;

    let cloneMat = null;
    if (originalMat) {
      cloneMat = (matman?.cloneMaterial) ? matman.cloneMaterial(originalMat) : originalMat.clone();
      cloneMat.transparent = true;
      cloneMat.opacity = originalMat.opacity ?? 1.0;
      cloneMat.depthWrite = false;
      cloneMat.side = originalMat.side;
      cloneMat.needsUpdate = true;

      if (viewer.impl.setMaterial) viewer.impl.setMaterial(model, fragId, cloneMat);
      else if (fragList?.setMaterial) fragList.setMaterial(fragId, cloneMat);
      else if (viewer.impl.setFragmentMaterial) viewer.impl.setFragmentMaterial(fragId, cloneMat);
    }

    const f = { fragId, proxy, startPos, originalMat, cloneMat };
    items.push(f);

    const dbId = fragIdToDb.get(fragId);
    if (Number.isInteger(dbId) && byDb.has(dbId)) {
      byDb.get(dbId).push(f);
    }
  }

  viewer.impl.invalidate?.(true, true, true);
  return { items, byDb };
}

function _getFragList(viewer, model) {
  if (model?.getFragmentList) return model.getFragmentList();
  if (viewer?.model?.getFragmentList) return viewer.model.getFragmentList();
  return null;
}

function _norm01(x) { return x <= 0 ? 0 : (x >= 1 ? 1 : x); }
function _lerp(a,b,t){ return a + (b - a) * (t < 0 ? 0 : (t > 1 ? 1 : t)); }




// /wwwroot/js/sidebar/task-wbs/ui/current-task-modal.js
import { calendarSvg } from "./calendar-svg.js";
import { apply4DAt, reset4D } from "../../task-wbs/4d/4d-simulation.js";

export function showCurrentTaskModal() {
  if (document.querySelector(".current-task-modal")) return;

  const todayStr = isoToday();

  // UI
  const modal = document.createElement("div");
  modal.className = "current-task-modal";
  modal.tabIndex = 0;
  modal.innerHTML = `
    <div class="current-task-modal-header">
      <span class="modal-title">공정현황</span>
      <button type="button" class="modal-close" title="닫기" aria-label="닫기">×</button>
    </div>
    <div class="current-task-modal-body">
      <div class="current-task-date-row">
        <input type="text" class="current-task-date-input" maxlength="10" placeholder="yyyy-mm-dd" value="${todayStr}" autocomplete="off" />
        <button type="button" class="datepicker-btn" tabindex="-1" title="달력 열기">${calendarSvg}</button>
        <button type="button" class="btn-today" title="오늘로 이동">오늘</button>
      </div>

      <div class="current-task-slider-row">
        <input type="range" class="current-task-slider" min="-15" max="15" value="0" />
      </div>

      <div class="sim-toolbar" aria-label="시뮬레이션 컨트롤">
        <!-- 순서: ㅣ< , ㅁ , > , >ㅣ -->
        <button type="button" class="sim-btn sim-begin" title="5초 뒤로"   aria-label="5초 뒤로">${svgIcon('begin')}</button>
        <button type="button" class="sim-btn sim-stop"  title="정지/맨앞"  aria-label="정지/맨앞">${svgIcon('stop')}</button>
        <button type="button" class="sim-btn sim-play"  title="재생"      aria-label="재생">${svgIcon('play')}</button>
        <button type="button" class="sim-btn sim-end"   title="5초 앞으로" aria-label="5초 앞으로">${svgIcon('end')}</button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);

  applyInlineStyles(modal);
  centerModal(modal);

  // 핸들
  const $input    = modal.querySelector(".current-task-date-input");
  const $btnCal   = modal.querySelector(".datepicker-btn");
  const $btnToday = modal.querySelector(".btn-today");
  const $close    = modal.querySelector(".modal-close");
  const $header   = modal.querySelector(".current-task-modal-header");
  const $slider   = modal.querySelector(".current-task-slider");

  // 컨트롤
  const $btnBegin = modal.querySelector(".sim-begin"); // ㅣ< : 5초 '뒤로'
  const $btnPlay  = modal.querySelector(".sim-play");  // >
  const $btnStop  = modal.querySelector(".sim-stop");  // ㅁ
  const $btnEnd   = modal.querySelector(".sim-end");   // >ㅣ : 5초 '앞으로'

  // 상태 & 파라미터
  const SIM = {
    playing: false,
    raf: 0,
    lastTs: 0,
    stepSec: 5,                                  // 버튼 스텝(초)
    speedDaysPerSec: window.SIM4D_SPEED_DAYS_PER_SEC ?? 1.0,
    zOffset: window.SIM4D_Z_OFFSET ?? 3.0,
    useDateDuration: (window.SIM4D_USE_DATE_DURATION ?? true) === true,
    fixedDurationSec: window.SIM4D_FIXED_DURATION_SEC ?? 2.0,
    minISO: null, maxISO: null,
    minMs: null,  maxMs: null,
    curMs: null
  };

  // 마스크
  let mask = null;
  if (window.IMask) mask = window.IMask($input, { mask: "0000-00-00", lazy: false, autofix: true });
  enforceSmartSelection($input);

  // 달력
  const fp = window.flatpickr($input, {
    dateFormat: "Y-m-d",
    defaultDate: todayStr,
    allowInput: true,
    clickOpens: false,
    onChange: (_, dateStr) => {
      if (!isISO(dateStr)) return;
      setSimMs(Date.parse(dateStr), { apply: true, from: "flatpickr" });
    }
  });

  // 직접 입력
  $input.addEventListener("change", () => {
    const val = $input.value.trim();
    if (!isISO(val)) return;
    setSimMs(Date.parse(val), { apply: true, from: "input-change" });
  });

  // 달력 버튼
  $btnCal.addEventListener("click", (e) => { e.stopPropagation(); fp.open(); });

  // 트리 범위 → ±5일 확장
  const tree = window.taskTree;
  const rawBounds = computeGlobalBoundsFromTaskData(tree?.getRootNode()?.children || []);
  let minISO = rawBounds.minISO, maxISO = rawBounds.maxISO;
  if (isISO(minISO)) minISO = addDaysISO(minISO, -5);
  if (isISO(maxISO)) maxISO = addDaysISO(maxISO, +5);

  SIM.minISO = minISO;
  SIM.maxISO = maxISO;
  SIM.minMs  = isISO(minISO) ? Date.parse(minISO) : null;
  SIM.maxMs  = isISO(maxISO) ? Date.parse(maxISO) : null;

  // 슬라이더 범위도 확장 값으로 세팅
  updateSliderRangeFromBounds(SIM.minISO, SIM.maxISO, $slider);

  // 오늘 버튼 (클램프)
  $btnToday.addEventListener("click", () => {
    const dISO = clampISO(isoToday(), SIM.minISO, SIM.maxISO);
    setSimMs(Date.parse(dISO), { apply: true, from: "today" });
  });

  // 슬라이더: 디바운스 적용
  const debouncedApply = debounce((iso) => applyByPolicy(iso, "slider-input", modal), 40);
  $slider.addEventListener("input", () => {
    const dISO = isoOffsetFromToday(parseInt($slider.value, 10));
    setSimMs(Date.parse(dISO), { apply: false, from: "slider-input" });
    debouncedApply(dISO);
  });
  $slider.addEventListener("change", () => {
    const dISO = isoOffsetFromToday(parseInt($slider.value, 10));
    setSimMs(Date.parse(dISO), { apply: true, from: "slider-change" });
  });

  // 드래그
  enableModalDrag(modal, $header);

  // 닫기(완전 초기화)
  $close.addEventListener("click", (e) => { e.stopPropagation(); resetViewerAndCloseEx(modal, SIM); });
  modal.addEventListener("keydown", (ev) => { if (ev.key === "Escape") resetViewerAndCloseEx(modal, SIM); });

  // 컨트롤
  $btnBegin?.addEventListener("click", () => {
    const next = (SIM.curMs ?? Date.parse($input.value)) - SIM.stepSec * 1000 * SIM.speedDaysPerSec;
    setSimMs(next, { apply: true, from: "nudge-back" });
  });
  $btnEnd?.addEventListener("click", () => {
    const next = (SIM.curMs ?? Date.parse($input.value)) + SIM.stepSec * 1000 * SIM.speedDaysPerSec;
    setSimMs(next, { apply: true, from: "nudge-forward" });
  });
  $btnStop?.addEventListener("click", () => {
    if (SIM.playing) {
      SIM.playing = false;
      if (SIM.raf) cancelAnimationFrame(SIM.raf);
      SIM.raf = 0;
    } else if (SIM.minMs != null) {
      setSimMs(SIM.minMs, { apply: true, from: "stop-reset" });
    }
  });
  $btnPlay?.addEventListener("click", () => {
    if (SIM.playing) return;
    if (SIM.curMs == null) SIM.curMs = Date.parse($input.value);
    if (SIM.maxMs != null && SIM.curMs >= SIM.maxMs) {
      if (SIM.minMs != null) setSimMs(SIM.minMs, { apply: true, from: "play-reset" });
    }
    SIM.playing = true;
    SIM.lastTs = performance.now();
    SIM.raf = requestAnimationFrame(loop);
  });

  // 최초 상태: 오늘(클램프)
  {
    const initISO = clampISO(todayStr, SIM.minISO, SIM.maxISO);
    setSimMs(Date.parse(initISO), { apply: true, from: "init" });
  }

  // 재생 루프
  function loop(now){
    if (!SIM.playing) return;
    const dtSec = Math.max(0, (now - SIM.lastTs) / 1000);
    SIM.lastTs = now;

    let nextMs = (SIM.curMs ?? Date.parse($input.value)) + dtSec * SIM.speedDaysPerSec * 86400000;
    if (SIM.minMs != null) nextMs = Math.max(nextMs, SIM.minMs);
    if (SIM.maxMs != null) nextMs = Math.min(nextMs, SIM.maxMs);

    if (SIM.maxMs != null && nextMs >= SIM.maxMs && SIM.curMs >= SIM.maxMs) {
      SIM.playing = false;
      if (SIM.raf) cancelAnimationFrame(SIM.raf);
      SIM.raf = 0;
      return;
    }
    setSimMs(nextMs, { apply: true, from: "play" });
    SIM.raf = requestAnimationFrame(loop);
  }

  // 내부 시계(ms) → UI/정책/4D 반영
  function setSimMs(ms, { apply = true, from = "" } = {}) {
    if (!Number.isFinite(ms)) return;
    if (SIM.minMs != null && ms < SIM.minMs) ms = SIM.minMs;
    if (SIM.maxMs != null && ms > SIM.maxMs) ms = SIM.maxMs;
    SIM.curMs = ms;

    const iso = msToISO(ms);
    setDateInput(iso, { apply, from });
  }

  // 날짜 입력 값 반영 (색상 정책 + 4D)
  function setDateInput(dateStr, { apply = true, from = "" } = {}) {
    const safe = clampISO(dateStr, SIM.minISO, SIM.maxISO);
    $input.value = safe;
    if (mask) { try { mask.updateValue(); } catch(_) {} }
    syncSliderFromDate($slider, safe);

    if (apply) {
      applyByPolicy(safe, from, modal);
      try {
        apply4DAt(window.viewer, safe, {
          zOffset: SIM.zOffset,
          useDateDuration: SIM.useDateDuration,
          fixedDurationSec: SIM.fixedDurationSec,
          speedDaysPerSec: SIM.speedDaysPerSec,
          syncThemingAlpha: true
        });
      } catch (e) {
        console.warn("[4D] apply error:", e);
      }
    }
  }
}

/* ───────── 정책(원본 유지) ───────── */
function applyByPolicy(dateStr, source, ctxEl){
  const v = window.viewer; const tree = window.taskTree;
  if (!v || !tree || !isISO(dateStr)) return;

  const model = (v.getVisibleModels && v.getVisibleModels()[0]) || v.model;
  if (!model) return;

  const urnCur = String(window.CURRENT_MODEL_URN || "");
  const showSet  = new Set();
  const hideSet  = new Set();
  const themeC   = new Set(); // green
  const themeT   = new Set(); // blue
  const themeD   = new Set(); // red

  const inRange = (d, s, e) => (isISO(s) && isISO(e) && d >= s && d <= e);
  const beforeS = (d, s)     => (isISO(s) && d < s);
  const afterE  = (d, e)     => (isISO(e) && d > e);

  tree.getRootNode()?.visit((n) => {
    const d = n.data || {};
    const cat = normCat(d.selectedOption);
    if (!cat) return;

    const objs = Array.isArray(d.linkedObjects) ? d.linkedObjects : [];
    for (const o of objs) {
      const urn = String(o.urn || urnCur);
      if (!urnCur || urn !== urnCur) continue;
      const id = Number(o.dbId);
      if (!Number.isFinite(id)) continue;

      if (cat === "C") {
        if (beforeS(dateStr, d.start)) { hideSet.add(id); }
        else if (inRange(dateStr, d.start, d.end)) { showSet.add(id); themeC.add(id); }
        else if (afterE(dateStr, d.end)) { showSet.add(id); }
        else { showSet.add(id); }
      } else if (cat === "T") {
        if (beforeS(dateStr, d.start)) { hideSet.add(id); }
        else if (inRange(dateStr, d.start, d.end)) { showSet.add(id); themeT.add(id); }
        else if (afterE(dateStr, d.end)) { showSet.add(id); }
        else { showSet.add(id); }
      } else if (cat === "D") {
        if (beforeS(dateStr, d.start)) { showSet.add(id); }
        else if (inRange(dateStr, d.start, d.end)) { showSet.add(id); themeD.add(id); }
        else if (afterE(dateStr, d.end)) { hideSet.add(id); }
        else { showSet.add(id); }
      }
    }
  });

  for (const id of showSet) hideSet.delete(id);

  try {
    if (!ctxEl.__simVisInit) {
      v.impl?.visibilityManager?.setAllOn?.();
      ctxEl.__simVisInit = true;
    }

    try { v.clearThemingColors?.(model); } catch(_) {}
    try { v.clearThemingColors?.(); } catch(_) {}

    const showArr = [...showSet];
    const hideArr = [...hideSet];
    if (showArr.length) v.show(showArr, model);
    if (hideArr.length) v.hide(hideArr, model);

    const V4 = (r,g,b,a=1) => (window.THREE ? new window.THREE.Vector4(r,g,b,a) : { r,g,b,a });
    const cGreen = V4(0.16, 0.57, 0.20, 1);
    const cBlue  = V4(0.12, 0.45, 0.90, 1);
    const cRed   = V4(0.95, 0.27, 0.23, 1);

    const paintChunk = (ids, color) => {
      const CHUNK = 4000;
      for (let i = 0; i < ids.length; i += CHUNK) {
        const slice = ids.slice(i, i + CHUNK);
        for (let j = 0; j < slice.length; j++) {
          v.setThemingColor(slice[j], color, model);
        }
      }
    };
    if (themeC.size) paintChunk([...themeC], cGreen);
    if (themeT.size) paintChunk([...themeT], cBlue);
    if (themeD.size) paintChunk([...themeD], cRed);

    v.impl?.sceneUpdated?.(true);
    v.impl?.invalidate?.(true, true, true);
  } catch (err) {
    console.warn("[CurrentTask] policy apply error", err);
  }
}

/* ───────── 스타일/유틸 ───────── */
function applyInlineStyles(modal){
  Object.assign(modal.style, {
    zIndex: 10000,
    width: "300px",
    maxWidth: "90vw",
    background: "#fff",
    border: "1px solid #d9d9d9",
    borderRadius: "10px",
    boxShadow: "0 10px 24px rgba(0,0,0,.12)",
    fontFamily: "'Noto Sans KR', system-ui, -apple-system, 'Segoe UI', Arial, sans-serif",
    position: "fixed",
  });

  const header = modal.querySelector(".current-task-modal-header");
  Object.assign(header.style, {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    gap: "6px",
    padding: "6px 8px",
    borderBottom: "1px solid "#eee,
    cursor: "grab",
    userSelect: "none",
    touchAction: "none"
  });

  const close = modal.querySelector(".modal-close");
  Object.assign(close.style, {
    border: "none",
    background: "transparent",
    fontSize: "18px",
    cursor: "pointer",
    lineHeight: "1",
  });

  const body = modal.querySelector(".current-task-modal-body");
  Object.assign(body.style, {
    padding: "8px",
    display: "flex",
    flexDirection: "column",
    gap: "6px"
  });

  const row = modal.querySelector(".current-task-date-row");
  Object.assign(row.style, {
    display: "flex",
    alignItems: "center",
    gap: "6px",
    justifyContent: "center",
    margin: "0"
  });

  const input = modal.querySelector(".current-task-date-input");
  Object.assign(input.style, {
    width: "118px",
    textAlign: "center",
    padding: "4px 6px",
    border: "1px solid #bbb",
    borderRadius: "6px",
    outline: "none",
  });

  const btnCal = modal.querySelector(".datepicker-btn");
  Object.assign(btnCal.style, {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    width: "28px",
    height: "28px",
    borderRadius: "6px",
    border: "1px solid #ddd",
    background: "#fafafa",
    cursor: "pointer",
    padding: "0"
  });

  const calSvg = btnCal.querySelector("svg");
  if (calSvg) { calSvg.setAttribute("width","16"); calSvg.setAttribute("height","16"); }

  const btnToday = modal.querySelector(".btn-today");
  Object.assign(btnToday.style, {
    height: "28px",
    padding: "0 10px",
    borderRadius: "6px",
    border: "1px solid #1976d2",
    background: "#1976d2",
    color: "#fff",
    cursor: "pointer"
  });

  const sliderRow = modal.querySelector(".current-task-slider-row");
  Object.assign(sliderRow.style, {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    padding: "0",
    margin: "0"
  });

  const slider = modal.querySelector(".current-task-slider");
  Object.assign(slider.style, {
    width: "100%",
    maxWidth: "260px",
    display: "block",
    margin: "2px 0"
  });

  const sim = modal.querySelector(".sim-toolbar");
  Object.assign(sim.style, {
    display: "flex",
    justifyContent: "center",
    gap: "6px",
    paddingTop: "4px",
    borderTop: "1px dashed #eee",
    marginTop: "0"
  });
  sim.querySelectorAll(".sim-btn").forEach(btn => {
    Object.assign(btn.style, {
      width: "36px",
      height: "30px",
      borderRadius: "8px",
      border: "1px solid #ddd",
      background: "#f8f9fb",
      cursor: "pointer",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      padding: "0"
    });
  });
}

function centerModal(modal){
  modal.style.visibility = "hidden";
  requestAnimationFrame(() => {
    const { innerWidth: w, innerHeight: h } = window;
    const r = modal.getBoundingClientRect();
    modal.style.left = Math.max(8, (w / 2 - r.width / 2)) + "px";
    modal.style.top  = Math.max(8, (h / 3 - r.height / 2)) + "px";
    modal.style.visibility = "visible";
  });
}

/* ───── 유틸 ───── */
function svgIcon(name){
  const stroke = "currentColor";
  if (name === "play")  return `<svg width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M8 5v14l11-7-11-7z" fill="${stroke}"/></svg>`;
  if (name === "stop")  return `<svg width="16" height="16" viewBox="0 0 24 24" fill="none"><rect x="6" y="6" width="12" height="12" rx="2" fill="${stroke}"/></svg>`;
  if (name === "begin") return `<svg width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M19 6l-7 6 7 6V6z" fill="${stroke}"/><rect x="5" y="6" width="2" height="12" fill="${stroke}"/></svg>`;
  if (name === "end")   return `<svg width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M5 6l7 6-7 6V6z" fill="${stroke}"/><rect x="17" y="6" width="2" height="12" fill="${stroke}"/></svg>`;
  return "";
}

function isISO(s){ return /^\d{4}-\d{2}-\d{2}$/.test(String(s||"")); }
function isoToday(){ return new Date().toISOString().slice(0,10); }
function isoOffsetFromToday(offsetDays){
  const base = new Date();
  base.setDate(base.getDate() + (Number(offsetDays) || 0));
  return base.toISOString().slice(0,10);
}
function msToISO(ms){ return new Date(ms).toISOString().slice(0,10); }
function addDaysISO(iso, days){
  const d = new Date(iso + "T00:00:00Z");
  d.setUTCDate(d.getUTCDate() + (Number(days)||0));
  return d.toISOString().slice(0,10);
}
function clampISO(iso, minISO, maxISO){
  if (!isISO(iso)) return iso;
  let t = Date.parse(iso);
  if (isISO(minISO)) t = Math.max(t, Date.parse(minISO));
  if (isISO(maxISO)) t = Math.min(t, Date.parse(maxISO));
  return new Date(t).toISOString().slice(0,10);
}
function updateSliderRangeFromBounds(minISO, maxISO, sliderEl){
  if (!sliderEl || !isISO(minISO) || !isISO(maxISO)) return;
  const t = isoToday();
  const diffMin = Math.ceil((Date.parse(minISO) - Date.parse(t)) / 86400000);
  const diffMax = Math.ceil((Date.parse(maxISO) - Date.parse(t)) / 86400000);
  sliderEl.min = String(diffMin);
  sliderEl.max = String(diffMax);
  sliderEl.value = clamp01((Date.parse(t) - Date.parse(minISO)) / (Date.parse(maxISO) - Date.parse(minISO))) > 0.5 ? "0" : "0";
}
function computeGlobalBoundsFromTaskData(nodes){
  const all = [];
  (function walk(arr){
    for (const n of arr) {
      const d = n.data || n;
      if (isISO(d.start)) all.push(d.start);
      if (isISO(d.end))   all.push(d.end);
      if (n.children) walk(n.children);
    }
  })(nodes);
  if (!all.length) return { minISO: null, maxISO: null };
  const minISO = all.reduce((a,b)=> a < b ? a : b);
  const maxISO = all.reduce((a,b)=> a > b ? a : b);
  return { minISO, maxISO };
}
function syncSliderFromDate(sliderEl, dateStr){
  if (!sliderEl || !isISO(dateStr) || !isFinite(Number(sliderEl.min))) return;
  const t = isoToday();
  const diff = Math.round((Date.parse(dateStr) - Date.parse(t)) / 86400000);
  const min = Number(sliderEl.min), max = Number(sliderEl.max);
  sliderEl.value = String(Math.min(Math.max(diff, min), max));
}
function normCat(v){
  const s = String(v || "").trim();
  if (s === "C" || s.startsWith("시공")) return "C";
  if (s === "T" || s.startsWith("가설")) return "T";
  if (s === "D" || s.startsWith("철거")) return "D";
  return "";
}
function enforceSmartSelection(input){
  const digitIdx = [0,1,2,3,5,6,8,9];
  const setSel = (pos) => { if (digitIdx.includes(pos)) input.setSelectionRange(pos, pos + 1); };
  const getDigitPos = (pos) => digitIdx.includes(pos) ? pos : (digitIdx.find(d => d > pos) ?? 9);
  const nextDigitIdx = (pos) => { const i = digitIdx.indexOf(pos); return (i !== -1 && i < digitIdx.length - 1) ? digitIdx[i+1] : pos; };
  const prevDigitIdx = (pos) => { const i = digitIdx.indexOf(pos); return (i > 0) ? digitIdx[i-1] : pos; };
  ["focus", "click"].forEach(evt => input.addEventListener(evt, () => setTimeout(() => setSel(getDigitPos(input.selectionStart)), 0)));
  input.addEventListener("keydown", (e) => {
    const pos = input.selectionStart;
    if (e.key === "ArrowLeft"  && pos !== 0)  { e.preventDefault(); setSel(prevDigitIdx(pos)); }
    if (e.key === "ArrowRight" && pos !== 9)  { e.preventDefault(); setSel(nextDigitIdx(pos)); }
  });
  input.addEventListener("input", () => {
    const pos = input.selectionStart;
    if (digitIdx.includes(pos - 1)) setSel(nextDigitIdx(pos - 1));
    else setSel(getDigitPos(pos));
  });
}
function enableModalDrag(modal, handle){
  let dragging = false, pid = null;
  let startX = 0, startY = 0, startLeft = 0, startTop = 0;
  let raf = 0, nextLeft = 0, nextTop = 0;
  const isInteractive = (el) =>
    el.closest?.('.modal-close, .datepicker-btn, .btn-today, .sim-toolbar, .sim-btn, input, button, svg, path, rect, circle');
  const killDrag = (e) => e.preventDefault();
  handle.addEventListener('dragstart', killDrag);
  modal.addEventListener('dragstart', killDrag);
  const onPointerDown = (e) => {
    if (isInteractive(e.target)) return;
    if (e.button !== 0) return;
    e.preventDefault(); e.stopPropagation();
    pid = e.pointerId; handle.setPointerCapture(pid);
    const cs = window.getComputedStyle(modal);
    const l = parseFloat(cs.left); const t = parseFloat(cs.top);
    if (Number.isFinite(l) && Number.isFinite(t)) { startLeft = l; startTop = t; }
    else { const r = modal.getBoundingClientRect(); startLeft = r.left; startTop = r.top; modal.style.left = `${startLeft}px`; modal.style.top = `${startTop}px`; }
    startX = e.clientX; startY = e.clientY; dragging = true; handle.style.cursor = "grabbing";
  };
  const onPointerMove = (e) => {
    if (!dragging) return;
    const dx = e.clientX - startX, dy = e.clientY - startY;
    nextLeft = Math.max(0, Math.round(startLeft + dx));
    nextTop  = Math.max(0, Math.round(startTop  + dy));
    if (!raf) { raf = requestAnimationFrame(() => { raf = 0; modal.style.left = `${nextLeft}px`; modal.style.top = `${nextTop}px`; }); }
  };
  const stopDrag = () => {
    if (!dragging) return;
    dragging = false; if (pid !== null) { try { handle.releasePointerCapture(pid); } catch(_){} } pid = null; handle.style.cursor = "grab";
  };
  handle.addEventListener("pointerdown", onPointerDown);
  handle.addEventListener("pointermove", onPointerMove);
  handle.addEventListener("pointerup", stopDrag);
  handle.addEventListener("pointercancel", stopDrag);
  window.addEventListener("pointerup", stopDrag, { passive: true });
}
function resetViewerAndCloseEx(m, SIM){
  try {
    if (SIM) { SIM.playing = false; if (SIM.raf) cancelAnimationFrame(SIM.raf); SIM.raf = 0; }
    const v = window.viewer;
    try { reset4D(v); } catch(_) {}
    try { v?.clearThemingColors?.(); } catch(_){}
    const vm = v?.impl?.visibilityManager; vm?.setAllOn?.();
    try { v?.setCutPlanes?.([]); } catch(_){}
    v?.impl?.invalidate?.(true, true, true);
  } catch(_){}
  m.remove();
}
function clamp01(x){ return x < 0 ? 0 : (x > 1 ? 1 : x); }