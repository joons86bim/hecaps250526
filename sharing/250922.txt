// wbs-store.js  ──────────────────────────────────────────────────────────────
(function(global){
  const PHASE_MAP = { '시공': 'c', '가설': 't', '철거': 'd' };
  const WINDOW_WHITELIST = new Set(['Window','Curtain Panel','Generic Models','Curtain Wall Mullion']);

  const norm = (s) => (s ?? '')
    .toString()
    .normalize('NFC')
    .replace(/\s+/g, ' ')
    .trim();

  const makePathKey = (path) => norm(Array.isArray(path) ? path.join(' / ') : path);

  const inc = (obj, k, v=1) => (obj[k] = (obj[k] || 0) + v);

  function makeZero() { return { c:0, t:0, d:0, total:0, dbIds:[] }; }
  function addAgg(dst, src){
    dst.c += src.c; dst.t += src.t; dst.d += src.d; dst.total += src.total;
    if (src.dbIds && src.dbIds.length) dst.dbIds.push(...src.dbIds);
    return dst;
  }

  // elements: [{dbId, wbsPath, top, category, familyName, typeName, workPhase}, ...]
  function buildIndexes(elements){
    const byPathAgg = new Map();      // 정규화된 pathKey(모든 prefix 포함) -> 집계
    const byFamTypeAgg = new Map();   // "fam::type" -> 집계 (창 전용)
    const elementsByPath = new Map(); // leaf 직접연결이 필요하면 사용
    const elementsByFamType = new Map();

    for (const e of elements){
      const dbId = e.dbId ?? e.dbid ?? e.id;
      const phaseKey = PHASE_MAP[e.workPhase] || 'c'; // 기본은 시공
      const unit = { c:0, t:0, d:0, total:1, dbIds:[dbId] };
      unit[phaseKey] = 1;

      // 1) Path 기반 집계 (모든 prefix에 누적: 상위노드도 항상 값이 나옴)
      const rawPath = e.wbsPath || e.path || e.wbs_path;
      if (rawPath){
        const parts = norm(rawPath).split('/').map(s=>s.trim()).filter(Boolean);
        let acc = [];
        for (let i=0;i<parts.length;i++){
          acc.push(parts[i]);
          const key = makePathKey(acc);
          const agg = byPathAgg.get(key) || makeZero();
          addAgg(agg, unit);
          byPathAgg.set(key, agg);
        }
        // leaf 직접조회용
        const leafKey = makePathKey(parts);
        const arr = elementsByPath.get(leafKey) || [];
        arr.push(e);
        elementsByPath.set(leafKey, arr);
      }

      // 2) 창: Family+Type 집계
      const cat = norm(e.category);
      if (WINDOW_WHITELIST.has(cat) || norm(e.top) === '창'){
        const fam = norm(e.familyName || e.family || e.family_name);
        const typ = norm(e.typeName || e.type || e.type_name);
        if (fam || typ){
          const k = `${fam}::${typ}`;
          const agg = byFamTypeAgg.get(k) || makeZero();
          addAgg(agg, unit);
          byFamTypeAgg.set(k, agg);

          const arr2 = elementsByFamType.get(k) || [];
          arr2.push(e);
          elementsByFamType.set(k, arr2);
        }
      }
    }

    return { byPathAgg, byFamTypeAgg, elementsByPath, elementsByFamType };
  }

  // 가시 트리에서 subtree -> dbIds 재구성 (선택 하이라이트 등에 사용)
  function rebuildIndexFromVisibleTree(tree){
    const map = new Map(); // node.key -> dbId[]
    tree.visit(node => {
      let ids = [];
      // 이미 노드에 모아둔 게 있으면 사용
      if (Array.isArray(node.data?.dbIds)) ids = node.data.dbIds.slice();
      // 자식에서 끌어올림
      if (node.children && node.children.length){
        for (const ch of node.children){
          if (Array.isArray(ch.data?.dbIds)) ids.push(...ch.data.dbIds);
        }
      }
      node.data = node.data || {};
      node.data.dbIds = ids;
      map.set(node.key, ids);
    });
    return map;
  }

  class WbsStore {
    constructor(){
      this.isReady = false;
      this.index = null;
      this.visibleDbIndex = null;
      this._tree = null;
    }

    attachTree(tree){ this._tree = tree; }

    refresh(elements){
      this.index = buildIndexes(elements || []);
      this.isReady = true;
      return true;
    }

    // node: FancytreeNode
    countAt(node){
      if (!this.isReady || !this.index) return makeZero();

      const top = norm(node.data?.top || node.parent?.data?.top || node.parent?.title);
      const family = norm(node.data?.family || node.data?.familyName);
      const type = norm(node.data?.type || node.data?.typeName);
      const pathKey = makePathKey(node.data?.path || node.data?.wbsPath || node.data?.titlePath);

      // 창: Family+Type leaf 우선
      if (top === '창' && (family || type)){
        const k = `${family}::${type}`;
        const agg = this.index.byFamTypeAgg.get(k);
        if (agg) return { ...agg, dbIds: (this.index.elementsByFamType.get(k)||[]).map(e=>e.dbId ?? e.id) };
      }

      // 공통: path prefix 기준 집계
      if (pathKey){
        const agg = this.index.byPathAgg.get(pathKey);
        if (agg) return { ...agg, dbIds: (this.index.elementsByPath.get(pathKey)||[]).map(e=>e.dbId ?? e.id) };
      }

      // 마지막 폴백: 로컬 visible subtree에서 끌어오기
      if (this._tree){
        const ids = [];
        node.visit(n => {
          if (Array.isArray(n.data?.dbIds)) ids.push(...n.data.dbIds);
        });
        const uniq = Array.from(new Set(ids));
        return { c:0, t:0, d:0, total:uniq.length, dbIds:uniq };
      }
      return makeZero();
    }

    // DOM을 건드리지 않고 각 노드 data에 집계와 dbIds만 채워둠
    populateCountsForTree(tree){
      this.attachTree(tree);
      tree.visit(node => {
        const agg = this.countAt(node);
        node.data = node.data || {};
        node.data.dbIds = agg.dbIds;
        node.data.counts = { c:agg.c, t:agg.t, d:agg.d, total:agg.total };
      });
      // 가시트리 인덱스도 최신화
      this.visibleDbIndex = rebuildIndexFromVisibleTree(tree);
    }
  }

  // 전역 export (기존 호출과 호환)
  const store = new WbsStore();
  global.__WBS_STORE__ = Object.assign(global.__WBS_STORE__ || {}, {
    WbsStore: store,
    refreshWbsStore: (...args) => store.refresh(...args),
    countAt: (node) => store.countAt(node),
    rebuildIndexFromVisibleTree: (tree) => (store.visibleDbIndex = rebuildIndexFromVisibleTree(tree)),
    populateCountsForTree: (tree) => store.populateCountsForTree(tree),
  });

})(window);



// fancy-tree-init.js  ───────────────────────────────────────────────────────

// (중요) renderColumns에서 칸(시공/가설/철거)만 채움. 여기서 재렌더 금지!
const options = {
  // ... 기존 옵션 유지 ...
  extensions: ["table", /* ... */],
  renderColumns: function(event, data){
    const node = data.node;
    const $tds = $(node.tr).find(">td");
    // [0]=타이틀, [1]=합계, [2]=상태칸(시공/가설/철거)라고 가정
    const counts = node.data?.counts || {c:0,t:0,d:0,total:0};
    $tds.eq(1).text(counts.total);
    const $status = $tds.eq(2);
    $status.find(".b.c").text(counts.c);
    $status.find(".b.t").text(counts.t);
    $status.find(".b.d").text(counts.d);
  },

  // lazyLoad에서는 데이터만 반환. 여기서 render 호출하지 마세요.
  lazyLoad: async function(event, data){
    const node = data.node;
    // children data 만들어서 넘기기
    const children = await fetchChildren(node); // <- 기존 비동기 로더
    data.result = children;
    // ★ 여기서 node.render()/tree.render(true) 호출 금지!
  },

  // loadChildren 이후: 전체 트리 기준으로 한번에 safe paint
  loadChildren: function(event, data){
    const tree = data.tree;
    // 여러 노드가 한꺼번에 열릴 수 있으니 batch 처리
    tree.enableUpdate(false);
    window.__WBS_STORE__?.populateCountsForTree(tree);
    tree.enableUpdate(true);
    // 재렌더 하나만: 테이블 확정 후 전체 렌더
    tree.render(true);
  },

  init: function(event, data){
    const tree = data.tree;
    // 초기 한 번만 집계 채우기 (elements는 별도 로딩 완료 후 호출)
    if (window.__WBS_STORE__?.WbsStore?.isReady){
      tree.enableUpdate(false);
      window.__WBS_STORE__?.populateCountsForTree(tree);
      tree.enableUpdate(true);
      tree.render(true);
    }
  }
};

// “직접 DOM 페인트” 유틸(재렌더 대신 칸만 덮어씀)
export function paintCounts(node){
  const counts = node.data?.counts || {c:0,t:0,d:0,total:0};
  const $tr = $(node.tr);
  if (!$tr || !$tr.length) return;
  const $tds = $tr.find(">td");
  $tds.eq(1).text(counts.total);
  const $status = $tds.eq(2);
  $status.find(".b.c").text(counts.c);
  $status.find(".b.t").text(counts.t);
  $status.find(".b.d").text(counts.d);
}

// 필요 시 서브트리만 안전히 업데이트(렌더 금지)
export function ensureCountsForSubtree(node){
  const tree = node.tree;
  tree.enableUpdate(false);
  node.visit(n => {
    const agg = window.__WBS_STORE__?.countAt(n);
    n.data = n.data || {};
    n.data.dbIds = agg.dbIds;
    n.data.counts = { c:agg.c, t:agg.t, d:agg.d, total:agg.total };
    paintCounts(n);
  });
  tree.enableUpdate(true);
}



// main.js  ──────────────────────────────────────────────────────────────────

// 기존 repaintNode에서 node.render() 하던 부분 제거하고 paintCounts만 호출
import { ensureCountsForSubtree, paintCounts } from './fancy-tree-init.js';

function countsForPath(node){
  const agg = window.__WBS_STORE__?.countAt(node);
  return agg || { c:0, t:0, d:0, total:0, dbIds:[] };
}

function repaintNode(node){
  const agg = countsForPath(node);
  node.data = node.data || {};
  node.data.dbIds = agg.dbIds;
  node.data.counts = { c:agg.c, t:agg.t, d:agg.d, total:agg.total };
  // 안전 DOM 업데이트 (재렌더 금지)
  paintCounts(node);
}

// 전체 트리 리페인트할 때
function repaintTree(){
  const tree = $("#wbs").fancytree("getTree");
  tree.enableUpdate(false);
  tree.visit(n => repaintNode(n));
  tree.enableUpdate(true);
}

// 예: 패널 준비 후 한 번 호출
document.addEventListener('panel2-ready', ()=>{
  const tree = $("#wbs").fancytree("getTree");
  window.__WBS_STORE__?.populateCountsForTree(tree);
  repaintTree();
});




