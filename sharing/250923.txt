// /wwwroot/js/main.js — WBS 첫 로딩 즉시 색/배지 표시 (정리·최적화 최종본)

import { initTabs } from "./sidebar/init-tabs.js";
import { initTree } from "./sidebar/init-tree.js";
import { initViewer, loadModel } from "./viewer/init-viewer.js";
import { buildWbsProviderLazy } from "./sidebar/task-wbs/wbs/loader.js";
import { bindPanel2Resizer } from "./sidebar/task-wbs/layout/panel-resizer.js";

import {
  initMatrix,
  bulkEnsureForVisible,
  computePathState,
  getCounts,
} from "./sidebar/task-wbs/core/matrix-index.js";

import { toKey } from "./sidebar/task-wbs/core/path-key.js";

import {
  initTaskPanel,
  initTaskListButtons,
  setSavedTaskData,
  disableViewerEscReset,
  initWbsPanelWithFancytree,
} from "./sidebar/index.js";

/* ============================== */
/* 전역/레이아웃 */
const SIDEBAR_MIN = 360;
const SIDEBAR_DEFAULT = 900;
const PREVIEW_MIN = 520;

window.__WBS_DEBUG = window.__WBS_DEBUG || {};
window.__FA_FALLBACK_BY_KEY = Object.create(null); // pathKey -> {total,c,t,d,td}

try {
  // 디버그 진입점(존재 안 해도 무해)
  window.getCounts = getCounts;
} catch {}

function initSidebarWidth() {
  const root = document.documentElement;
  const stored = parseInt(localStorage.getItem("sidebarWidthPx") || "0", 10);
  const maxNow = Math.max(SIDEBAR_MIN, window.innerWidth - PREVIEW_MIN);
  const initial = Number.isFinite(stored) && stored >= SIDEBAR_MIN
    ? Math.min(maxNow, stored)
    : Math.min(maxNow, SIDEBAR_DEFAULT);
  root.style.setProperty("--sidebar-width", initial + "px");
  return initial;
}

function resetViewerInputAndCamera(viewer) {
  try {
    const tc = viewer.toolController;
    if (tc?.isToolActivated?.("BoxSelectionTool")) tc.deactivateTool("BoxSelectionTool");
    viewer.setNavigationLock(false);
    const fallbackNav = viewer.impl?.is2d ? "pan" : "orbit";
    viewer.setActiveNavigationTool?.(fallbackNav);
    viewer.setSelectionMode(Autodesk.Viewing.SelectionMode.MIXED);
    viewer.clearSelection?.();
    if (!viewer.impl?.is2d) {
      viewer.navigation.setWorldUpVector(new THREE.Vector3(0, 0, 1), true);
      const bb = viewer.model?.getBoundingBox?.();
      if (bb) {
        const center = bb.getCenter(new THREE.Vector3());
        viewer.navigation.setPivotPoint(center);
        viewer.navigation.setTarget(center);
      }
    }
    viewer.fitToView?.();
  } catch (e) {
    console.warn("[init] resetViewerInputAndCamera failed:", e);
  }
}

/* ============================== */
/* 뷰어 준비 대기 유틸 */
function onceViewer(viewer, type) {
  return new Promise((resolve) => {
    const h = () => { try { viewer.removeEventListener(type, h); } catch {} ; resolve(); };
    viewer.addEventListener(type, h);
  });
}
function hasObjectTree(viewer) {
  return !!viewer.model?.getData?.()?.instanceTree;
}
async function waitObjectTree(viewer) {
  if (hasObjectTree(viewer)) return;
  await onceViewer(viewer, Autodesk.Viewing.OBJECT_TREE_CREATED_EVENT);
}
async function waitGeometry(viewer, timeoutMs = 180000) {
  await new Promise((resolve) => {
    let done = false;
    const h = () => {
      if (done) return;
      done = true;
      try { viewer.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, h); } catch {}
      resolve();
    };
    viewer.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, h, { once: true });
    setTimeout(h, timeoutMs);
  });
}
async function waitPropertyDb(viewer, timeoutMs = 120000) {
  try {
    if (viewer?.model?.getPropertyDb?.()) return;
  } catch {}
  await new Promise((resolve) => {
    let done = false;
    const h = () => {
      if (done) return;
      done = true;
      try { viewer.removeEventListener(Autodesk.Viewing.PROPERTY_DB_CREATED_EVENT, h); } catch {}
      resolve();
    };
    viewer.addEventListener(Autodesk.Viewing.PROPERTY_DB_CREATED_EVENT, h, { once: true });
    setTimeout(h, timeoutMs);
  });
}
function waitIdle(timeout = 60) {
  return new Promise((resolve) => {
    if (typeof window.requestIdleCallback === "function") {
      window.requestIdleCallback(() => resolve(), { timeout });
    } else {
      setTimeout(resolve, timeout);
    }
  });
}
async function waitViewerReady(viewer) {
  await Promise.all([
    waitObjectTree(viewer),
    waitPropertyDb(viewer),
    waitGeometry(viewer),
  ]);
  await waitIdle(60);
}
async function focusCameraAndWait(viewer) {
  return new Promise((resolve) => {
    const onCam = () => {
      try { viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, onCam); } catch {}
      requestAnimationFrame(() => resolve());
    };
    viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, onCam, { once: true });
    resetViewerInputAndCamera(viewer);
  });
}

/* ============================== */
/* 태스크/URN 유틸 */
function safeUrn(urn) { return urn.replace(/[^a-zA-Z0-9]/g, "_"); }
function fillUrnRecursive(task, defaultUrn) {
  if (Array.isArray(task.linkedObjects)) {
    task.linkedObjects.forEach((o) => { if (!o.urn) o.urn = defaultUrn || window.CURRENT_MODEL_URN; });
  }
  if (Array.isArray(task.children)) {
    task.children.forEach((child) => fillUrnRecursive(child, defaultUrn));
  }
}
function persistTasksSnapshot(tasks) {
  const RAW  = window.CURRENT_MODEL_URN;
  const SAFE = window.CURRENT_MODEL_SAFE_URN;
  if (!RAW || !SAFE) return;
  try {
    const json = JSON.stringify(tasks || []);
    localStorage.setItem(`hec:tasks:${RAW}`, json);
    localStorage.setItem(`hec:tasks:${SAFE}`, json);
    window.__SAVED_TASKS = (tasks || []);
    console.log("[persistTasksSnapshot] saved. count =", window.__SAVED_TASKS.length);
  } catch (e) {
    console.warn("[persistTasksSnapshot] failed:", e);
  }
}

/* ============================== */
/* Provider 워밍업 (path→dbIds) */
async function seedDbIdMappings(provider, { maxDepth = 3, cap = 6000 } = {}) {
  const roots = await provider.roots().catch(() => []) || [];
  const q = roots.map(r => ({ path: [r.text], depth: 0 }));
  let visited = 0;
  while (q.length && visited < cap) {
    const { path, depth } = q.shift();
    try { provider.getDbIdsForPath?.(path, { includeDescendants: true, allowUnbuilt: true }); } catch {}
    if (depth < maxDepth) {
      let kids = [];
      try { kids = await provider.childrenByPath(path) || []; } catch {}
      visited += kids.length;
      for (const ch of kids) q.push({ path: ch.__path || [...path, ch.text], depth: depth + 1 });
    }
  }
}

/* ============================== */
/* 폴백 집계 (첫 프레임 표시 보장) */

// 상태 집합 생성: 시공(C)=빨강, 가설(T), 철거(D), 둘 다(TD)=파랑
function buildStatusSetsFromTasks(tasks) {
  const stateById = new Map();
  const norm = (raw) => {
    const s = String(raw || "").trim().toUpperCase();
    if (s.includes("시공") || s.startsWith("C") || s === "완료") return "C";
    if (s.includes("가설") || s.startsWith("T") || s === "임시" || s === "진행") return "T";
    if (s.includes("철거") || s.startsWith("D") || s === "해체") return "D";
    if (s === "TD" || s.includes("동시") || s.includes("복합")) return "TD";
    return "";
  };
  const prio = { C:3, TD:2, D:1, T:0, "":-1 };
  const apply = (id, sNew) => {
    if (!id || !sNew) return;
    const cur = stateById.get(id);
    if (!cur) { stateById.set(id, sNew); return; }
    if ((cur === "T" && sNew === "D") || (cur === "D" && sNew === "T")) { stateById.set(id, "TD"); return; }
    stateById.set(id, prio[sNew] > prio[cur] ? sNew : cur);
  };
  (function walk(arr, inherited="") {
    (arr||[]).forEach(t => {
      const sTask = norm(t.status || t.selectedOption || inherited);
      (t.linkedObjects||[]).forEach(o => apply(o.dbId, norm(o.status || o.phase || sTask)));
      if (t.children) walk(t.children, sTask);
    });
  })(tasks);

  const S = { C:new Set(), T:new Set(), D:new Set(), TD:new Set() };
  for (const [id, s] of stateById.entries()) if (S[s]) S[s].add(id);
  return S;
}

function calcCountsForPath(provider, path, S) {
  let ids = [];
  try { ids = provider.getDbIdsForPath(path, { includeDescendants:true, allowUnbuilt:true }) || []; } catch {}
  if (!ids.length) return { total:0, c:0, t:0, d:0, td:0 };
  const uniq = new Set(ids);
  let c=0,t=0,d=0,td=0;
  for (const id of uniq) {
    if (S.C.has(id)) c++;
    if (S.T.has(id)) t++;
    if (S.D.has(id)) d++;
    if (S.TD.has(id)) td++;
  }
  return { total:uniq.size, c,t,d,td };
}

function keyFromPath(path) {
  const D = window.__WBS_DEBUG;
  return (D?.toKey ? D.toKey(path) : toKey(path));
}

async function buildFallbackMap(provider, { maxDepth=3, cap=6000 } = {}) {
  window.__FA_FALLBACK_BY_KEY = Object.create(null);
  const tasks = window.__SAVED_TASKS || [];
  const S = buildStatusSetsFromTasks(tasks);

  const roots = (await provider.roots().catch(()=>[])) || [];
  const q = roots.map(r => ({ path:[r.text], depth:0 }));
  let seen = 0;

  while (q.length && seen < cap) {
    const { path, depth } = q.shift();
    const key = keyFromPath(path);
    window.__FA_FALLBACK_BY_KEY[key] = calcCountsForPath(provider, path, S);

    let kids = [];
    try { kids = await provider.childrenByPath(path) || []; } catch {}
    seen += kids.length;
    if (depth < maxDepth) {
      for (const ch of kids) q.push({ path: (ch.__path || [...path, ch.text]), depth: depth+1 });
    }
  }
  console.log("[FA] fallback map ready (keys =", Object.keys(window.__FA_FALLBACK_BY_KEY).length, ")");
}

function patchGetCountsToUseFallback() {
  const fb = () => window.__FA_FALLBACK_BY_KEY || Object.create(null);

  // 글로벌
  if (!window.__FA_BRIDGED_GLOBAL) {
    const origGlobal = window.getCounts;
    window.getCounts = function (k) {
      const r = origGlobal ? (origGlobal(k) || {}) : {};
      const sum = ((r.c|0)+(r.t|0)+(r.d|0)+(r.td|0));
      if (sum > 0) return r;
      const f = fb()[k];
      if (f) { const total = Math.max((r.total|0), (f.total|0)); return { total, c:f.c|0, t:f.t|0, d:f.d|0, td:f.td|0 }; }
      return r;
    };
    window.__FA_BRIDGED_GLOBAL = true;
  }

  // 디버그(NB: 렌더러들이 __WBS_DEBUG.getCounts를 주로 사용)
  const D = window.__WBS_DEBUG;
  if (D?.getCounts && !D.__patchedForFallback) {
    const orig = D.getCounts.bind(D);
    D.__origGetCounts = orig;
    D.getCounts = function (k) {
      const r = orig(k) || {};
      const sum = ((r.c|0)+(r.t|0)+(r.d|0)+(r.td|0));
      if (sum > 0) return r;
      const f = fb()[k];
      if (f) { const total = Math.max((r.total|0), (f.total|0)); return { total, c:f.c|0, t:f.t|0, d:f.d|0, td:f.td|0 }; }
      return r;
    };
    D.__patchedForFallback = true;
  }

  console.log("[FA] getCounts bridged");
}

/* ============================== */
/* WBS 셀 색/배지 렌더링 */
// 색 기준: C=빨강, TD(가설+철거)=파랑, T=주황, D=회색
const CELL_COLOR = {
  C:  "#ef4444",
  T:  "#f59e0b",
  D:  "#6b7280",
  TD: "#3b82f6",
};

function injectWbsCss() {
  if (document.getElementById("wbs-cell-style")) return;
  const css = `
    .fancytree-node .fancytree-title {
      border-left:4px solid transparent; padding-left:8px; border-radius:6px;
      transition: background-color .15s ease, border-color .15s ease;
    }
    .wbsCell--C  .fancytree-title { background:${CELL_COLOR.C}1a;  border-left-color:${CELL_COLOR.C}; }
    .wbsCell--T  .fancytree-title { background:${CELL_COLOR.T}1a;  border-left-color:${CELL_COLOR.T}; }
    .wbsCell--D  .fancytree-title { background:${CELL_COLOR.D}1a;  border-left-color:${CELL_COLOR.D}; }
    .wbsCell--TD .fancytree-title { background:${CELL_COLOR.TD}1a; border-left-color:${CELL_COLOR.TD}; }

    .wbs-badges{display:inline-flex;gap:6px;margin-left:8px;vertical-align:middle}
    .wbs-badge{display:inline-block;min-width:18px;padding:0 6px;height:18px;line-height:18px;
               font-size:11px;font-weight:600;border-radius:9px;color:#fff;text-align:center;
               box-shadow:inset 0 -1px rgba(0,0,0,.15)}
    .wbs-badge.hidden{display:none}
    .wbs-badge.C {background:${CELL_COLOR.C}}
    .wbs-badge.T {background:${CELL_COLOR.T};color:#222}
    .wbs-badge.D {background:${CELL_COLOR.D}}
    .wbs-badge.TD{background:${CELL_COLOR.TD}}
  `.trim();
  const s = document.createElement("style");
  s.id = "wbs-cell-style";
  s.textContent = css;
  document.head.appendChild(s);
}

function getPathForNode(node) {
  return node.data?.__path || (() => {
    const path = [];
    let n = node;
    while (n && !n.isRoot()) { path.unshift(n.title); n = n.parent; }
    return path;
  })();
}

function getCountsForPath(path) {
  const D = window.__WBS_DEBUG || {};
  const k = (D.toKey ? D.toKey(path) : toKey(path));
  const c = (D.getCounts ? D.getCounts(k) : (window.getCounts ? window.getCounts(k) : {})) || {};
  return { total:c.total|0, c:c.c|0, t:c.t|0, d:c.d|0, td:c.td|0 };
}

// 색 결정: TD(파랑) 우선 → C(빨강) → T(주황) → D(회색)
function classForCounts(cnt) {
  if (!cnt) return null;
  if ((cnt.td|0) > 0 || ((cnt.t|0) > 0 && (cnt.d|0) > 0)) return "wbsCell--TD";
  if ((cnt.c|0)  > 0) return "wbsCell--C";
  if ((cnt.t|0)  > 0) return "wbsCell--T";
  if ((cnt.d|0)  > 0) return "wbsCell--D";
  return null;
}

function ensureNodeBadges(node) {
  const $ = window.jQuery || window.$;
  if (!$ || !node?.span) return;

  const path   = getPathForNode(node);
  const counts = getCountsForPath(path);

  const $span  = $(node.span);
  const $title = $span.find(".fancytree-title");
  if ($title.length === 0) return;

  let $badges = $span.find(".wbs-badges");
  if ($badges.length === 0) {
    $badges = $("<span class='wbs-badges'/>").insertAfter($title);
    $badges.append("<span class='wbs-badge C'  data-k='c'>0</span>");
    $badges.append("<span class='wbs-badge T'  data-k='t'>0</span>");
    $badges.append("<span class='wbs-badge D'  data-k='d'>0</span>");
    $badges.append("<span class='wbs-badge TD' data-k='td'>0</span>");
  }

  const setVal = (k, v) => {
    const b = $badges.find(`.wbs-badge.${k}`);
    if (b.length) { b.text(v|0); b.toggleClass("hidden", (v|0) === 0); }
  };
  setVal("C",  counts.c);
  setVal("T",  counts.t);
  setVal("D",  counts.d);
  setVal("TD", counts.td);
}

function colorizeNode(node) {
  const $ = window.jQuery || window.$;
  if (!$ || !node?.li || node.isRoot?.()) return;
  const clsList = ["wbsCell--C","wbsCell--T","wbsCell--D","wbsCell--TD"];
  const cnt = getCountsForPath(getPathForNode(node));
  const cls = classForCounts(cnt);
  $(node.li).removeClass(clsList.join(" "));
  if (cls) $(node.li).addClass(cls);
  ensureNodeBadges(node);
}

function colorizeTree(tree) {
  if (!tree) return;
  tree.visit(colorizeNode);
}

function installWbsDecorators(tree) {
  if (!tree || tree.__wbsDecoratorsInstalled) return;
  injectWbsCss();

  const prev = tree.options.renderNode;
  tree.$div.fancytree("option", "renderNode", function(evt, data) {
    if (typeof prev === "function") prev.call(this, evt, data);
    try { colorizeNode(data.node); } catch {}
  });

  // 초기 2회 강제(첫 프레임 보장)
  try { colorizeTree(tree); } catch {}
  requestAnimationFrame(() => { try { colorizeTree(tree); } catch {} });

  // 디버그 빠른 강제 갱신
  window.DEBUG_WBS.repaintCells = () => {
    try { colorizeTree($.ui.fancytree.getTree("#wbs-tree")); } catch {}
  };

  tree.__wbsDecoratorsInstalled = true;
}

/* ============================== */
/* resize */
window.addEventListener("resize", _.throttle(() => {
  try {
    initSidebarWidth();
    window.viewer?.resize?.();
    window.viewer?.impl?.invalidate?.(true, true, true);
  } catch (e) {
    console.warn("[resize] redraw failed", e);
  }
}, 120));

/* ============================== */
/* 태스크 로딩 (API 폴백) */
const SAMPLE_TASK_DATA = [
  {
    no: "1",
    title: "Task A",
    selectedOption: "시공",
    start: "2024-06-25",
    end: "2024-07-01",
    linkedObjects: [{ urn: "SAMPLE_URN", dbId: 1001, text: "벽체1" }],
    children: [
      {
        no: "1.1",
        title: "Subtask A1",
        selectedOption: "시공",
        start: "2024-06-26",
        end: "2024-06-30",
        linkedObjects: [{ urn: "SAMPLE_URN", dbId: 1002, text: "벽체2" }],
      },
    ],
  },
  { no: "2", title: "Task B", selectedOption: "시공", start: "", end: "", linkedObjects: [] },
];

async function fetchTaskDataForCurrentModel() {
  try {
    const safeUrnVal = window.CURRENT_MODEL_SAFE_URN;
    const url = `/api/tasks?urn=${safeUrnVal}`;
    const resp = await fetch(url, { credentials: "include" });
    if (resp.ok) {
      const data = await resp.json();
      if (Array.isArray(data) && data.length > 0) return data;
    }
  } catch (err) {
    console.warn("task 데이터를 불러오지 못했습니다. 샘플로 대체:", err);
  }
  return SAMPLE_TASK_DATA.map(x => structuredClone(x));
}

/* ============================== */
/* main */
(async function () {
  try {
    // 1) 로그인
    const resp = await fetch("/api/auth/profile", { credentials: "include" });
    if (!resp.ok) { window.location.replace("/api/auth/login"); return; }
    const user = await resp.json();
    const login = document.getElementById("login");
    login.innerText = `Logout (${user.name})`;
    login.onclick = () => {
      const iframe = document.createElement("iframe");
      iframe.style.visibility = "hidden";
      iframe.src = "https://accounts.autodesk.com/Authentication/LogOut";
      document.body.appendChild(iframe);
      iframe.onload = () => {
        window.location.replace("/api/auth/logout");
        document.body.removeChild(iframe);
      };
    };

    // 2) 레이아웃
    const Sidebar = document.getElementById("sidebar");
    const Header  = document.getElementById("header");
    const Preview = document.getElementById("preview");
    const sidebarResizer = document.getElementById("sidebar-resizer");
    const Loading = document.getElementById("loading");
    Sidebar.style.display = "";
    sidebarResizer.style.display = "";
    Preview.style.display = "";
    Header.style.display = "";
    Loading.style.display = "none";
    login.style.visibility = "visible";
    Sidebar.style.removeProperty("width");
    Preview.style.removeProperty("left");
    sidebarResizer.style.removeProperty("left");
    initSidebarWidth();

    // 3) 탭/뷰어
    initTabs("#sidebar");
    const viewerHost = document.getElementById("viewer-host");
    const viewer = await initViewer(viewerHost);
    window.viewer = viewer;
    disableViewerEscReset(viewer);

    viewer.resize();
    viewer.impl?.invalidate?.(true, true, true);
    requestAnimationFrame(() => {
      try { viewer.resize(); viewer.impl?.invalidate?.(true, true, true); } catch {}
    });
    resetViewerInputAndCamera(viewer);

    requestAnimationFrame(() => {
      const sb = document.getElementById("sidebar");
      if (sb && sb.offsetWidth === 0) {
        document.documentElement.style.setProperty("--sidebar-width", SIDEBAR_DEFAULT + "px");
        viewer.resize();
        viewer.impl?.invalidate?.(true, true, true);
      }
    });

    // 4) 모델 선택
    initTree("#tree", async (versionId) => {
      const urn = window.btoa(versionId).replace(/=/g, ""); // RAW
      window.CURRENT_MODEL_URN = urn;
      window.CURRENT_MODEL_SAFE_URN = safeUrn(urn);

      // 기존 WBS 파괴
      try { $.ui.fancytree.getTree("#wbs-tree")?.destroy(); } catch {}
      $("#wbs-group-content").empty();

      // 모델 로드 & 안정화
      await loadModel(viewer, urn);
      await waitViewerReady(viewer);
      await focusCameraAndWait(viewer);
      viewer.resize();

      // WBS Provider
      let provider = null;
      try {
        const PRIMARY = ["HEC.WBS","HEC.Level","HEC.Zone"];
        const { provider: p } = await buildWbsProviderLazy(viewer, {
          primaryOrder: PRIMARY, source: "all", bucketThreshold: 400, bucketSize: 200,
        });
        provider = p;
        window.WBS_PROVIDER = provider;
        console.log("[WBS] roots:", (await provider.roots()).length);
      } catch (e) {
        console.warn("[WBS] provider failed:", e);
        provider = { roots:async()=>[], childrenByPath:async()=>[], getDbIdsForPath:()=>[] };
        window.WBS_PROVIDER = provider;
      }

      // 태스크 로드/정규화/저장
      const taskData = await fetchTaskDataForCurrentModel();
      taskData.forEach((t) => fillUrnRecursive(t, urn));
      persistTasksSnapshot(taskData);
      setSavedTaskData(taskData);

      // Provider 워밍업 → 매트릭스 초기화
      await seedDbIdMappings(provider, { maxDepth: 3, cap: 6000 });
      await initMatrix({ primaryOrder:["HEC.WBS","HEC.Level","HEC.Zone"], provider });

      // 폴백 맵 선계산 + getCounts 브릿지 (첫 프레임 보장)
      await buildFallbackMap(provider, { maxDepth:3, cap:6000 });
      patchGetCountsToUseFallback();

      // 루트~깊이3 키 보장/계산(실제 매트릭스가 준비되면 자동으로 대체됨)
      const preKeys = await collectKeysForRoots(provider, { maxDepth: 3, cap: 6000 });
      await bulkEnsureForVisible(preKeys);
      preKeys.forEach(computePathState);

      // WBS 패널 초기화 후 색/배지 설치
      await initWbsPanelWithFancytree(provider, { primaryOrder: ["HEC.WBS","HEC.Level","HEC.Zone"] });
      const tree = $.ui.fancytree.getTree("#wbs-tree");
      installWbsDecorators(tree);

      // 첫 프레임에서 즉시 보이도록 2회 강제
      colorizeTree(tree);
      requestAnimationFrame(() => colorizeTree(tree));

      // 나머지 패널
      bindPanel2Resizer(viewer);
      initTaskPanel(taskData);
      initTaskListButtons();

      // 약간의 여유 후 한 번 더(매트릭스가 후속으로 채워진 경우 갱신)
      setTimeout(() => { try { colorizeTree($.ui.fancytree.getTree("#wbs-tree")); } catch {} }, 400);
      setTimeout(() => { try { colorizeTree($.ui.fancytree.getTree("#wbs-tree")); } catch {} }, 1200);
    });

  } catch (err) {
    alert("Could not initialize the application. See console for more details.");
    console.error(err);
  }
})();

/* ============================== */
/* 끝 */