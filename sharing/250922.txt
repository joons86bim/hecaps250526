// main.js
function normalizeCounts(x){
  // 어떤 형태로 와도 안전하게 객체로 변환
  if (x == null) return { total: 0, C: 0, T: 0, D: 0 };
  if (typeof x === "number") return { total: x, C: x, T: 0, D: 0 }; // 총합만 아는 형태
  // 객체일 때 필드 보정
  return {
    total: Number(x.total ?? x.count ?? 0),
    C:     Number(x.C ?? x.c ?? 0),
    T:     Number(x.T ?? x.t ?? 0),
    D:     Number(x.D ?? x.d ?? 0),
  };
}

function countsForPath(path){
  // 1) 브리지 함수가 있으면 우선 사용
  if (typeof window.__FA_GET_COUNTS__ === "function") {
    return normalizeCounts(window.__FA_GET_COUNTS__(path));
  }
  // 2) Provider에 countAt가 있으면 사용
  const provider = window.__WBS_PROVIDER;
  if (provider?.countAt) {
    return normalizeCounts(provider.countAt(path));
  }
  // 3) WbsStore가 있으면 스토어의 countAt 사용
  const store = window.__WBS_STORE__;
  if (store?.countAt) {
    return normalizeCounts(store.countAt(path));
  }
  // 4) 사전 계산 맵이 있다면 (키 조인은 스토어와 동일한 구분자 사용)
  const SEP = "\u0001";
  const key = (path || []).join(SEP);
  const m = window.__FA_COUNT_MAP__;
  if (m && typeof m.get === "function") {
    return normalizeCounts(m.get(key));
  }
  // 5) 전부 없으면 0으로
  return normalizeCounts(null);
}



// wbs-store.js (기존 export들 아래에 추가)
export function countAt(pathArr){
  if (!Array.isArray(pathArr)) return 0;
  if (!WbsStore.isReady) rebuildIndexFromVisibleTree();
  const SEP = "\u0001";
  const key = pathArr.join(SEP);
  const ids = WbsStore.pathKeyToDbIds.get(key);
  return Array.isArray(ids) ? ids.length : 0;
}