} else {
  const key = node.data?.pathKey;

  // 2-0 숫자 확보: getCounts의 {total,c,t,d,td} → 화면표시용 {c,t,d}로 변환
  //  - td(가설&철거 동시)는 T/D 양쪽에 더해 표기
  const raw = key && getCounts(key);        // { total, c, t, d, td }
  let counts = toDisplayCounts(raw);         // { c, t, d } (td가 t/d에 반영됨)

  // 부모 직접값이 0이면 서브트리 집계(__aggCounts)로 폴백
  if ((!counts || sum3(counts) === 0) && node.data?.__aggCounts) {
    counts = node.data.__aggCounts;          // __aggCounts는 이미 {c,t,d}
  }

  // 2-1 상태(색칠): counts 기준 (t>0 && d>0 → 'TD')
  const st  = calcStateByCounts(counts);
  const cls = stateToClass(st);
  $(node.tr).removeClass("wbs-c wbs-t wbs-d wbs-td");
  if (cls) $(node.tr).addClass(cls);

  // 2-2 숫자 렌더
  if (counts && (typeof counts.c === "number" || typeof counts.t === "number" || typeof counts.d === "number")) {
    $statusCell
      .addClass("text-center")
      .html(`
        <div class="wbs-status" style="justify-content: center;">
          <div class="nums">
            <span class="b c" title="시공">${counts.c ?? 0}</span>
            <span class="b t" title="가설">${counts.t ?? 0}</span>
            <span class="b d" title="철거">${counts.d ?? 0}</span>
          </div>
        </div>
      `);
  } else {
    $statusCell.text("…");
    if (!node.data.__countsRequested && key) {
      node.data.__countsRequested = true;
      ensureCountsForNode(node)
        .then(() => { try { node.render(true); } catch {} })
        .finally(() => { node.data.__countsRequested = false; });
    }
  }

  // 2-3 숫자/상태 불일치 자동 복구 (1회)
  if (key) {
    const totalShown = (counts?.c || 0) + (counts?.t || 0) + (counts?.d || 0);
    const likelyWrong =
      ((node.data?.leafCount || 0) > 0) &&
      totalShown === 0 &&
      !node.data.__countsRepairOnce;

    if (likelyWrong) {
      node.data.__countsRepairOnce = true;
      ensureCountsForSubtree(provider, node)
        .then(() => { try { node.render(true); } catch {} })
        .finally(() => { node.data.__countsRepairOnce = false; });
    }
  }
}