// /wwwroot/js/main.js

import { initTabs } from "./sidebar/init-tabs.js";
import { initTree } from "./sidebar/init-tree.js";
import { initViewer, loadModel } from "./viewer/init-viewer.js";
import { buildWbsProviderLazy } from "./sidebar/task-wbs/wbs/loader.js";
import { bindPanel2Resizer } from "./sidebar/task-wbs/layout/panel-resizer.js";

import {
  initMatrix,
  bulkEnsureForVisible,
  computePathState,
  getCounts,
  markTasksChanged
} from "./sidebar/task-wbs/core/matrix-index.js";
import { toKey } from "./sidebar/task-wbs/core/path-key.js";

import {
  initTaskPanel,
  initTaskListButtons,
  setSavedTaskData,
  disableViewerEscReset,
  initWbsPanelWithFancytree
} from "./sidebar/index.js";

/* ----------------- small helpers ----------------- */
const SIDEBAR_MIN = 360;
const SIDEBAR_DEFAULT = 900;
const PREVIEW_MIN = 520;
let __MODEL_RUN_TOKEN = 0;

function waitIdle(timeout = 60) {
  return new Promise((resolve) => {
    if (typeof window.requestIdleCallback === "function") {
      window.requestIdleCallback(() => resolve(), { timeout });
    } else setTimeout(resolve, timeout);
  });
}
function onceViewer(viewer, type) {
  return new Promise((resolve) => {
    const h = () => { viewer.removeEventListener(type, h); resolve(); };
    viewer.addEventListener(type, h);
  });
}
function hasObjectTree(viewer) {
  return !!viewer.model?.getData?.()?.instanceTree;
}
async function waitObjectTree(viewer) {
  if (hasObjectTree(viewer)) return;
  await onceViewer(viewer, Autodesk.Viewing.OBJECT_TREE_CREATED_EVENT);
}
async function waitPropertyDb(viewer, timeoutMs = 120000) {
  try { if (viewer?.model?.getPropertyDb?.()) return; } catch {}
  await new Promise((resolve) => {
    let done = false;
    const h = () => {
      if (done) return;
      done = true;
      try { viewer.removeEventListener(Autodesk.Viewing.PROPERTY_DB_CREATED_EVENT, h); } catch {}
      resolve();
    };
    viewer.addEventListener(Autodesk.Viewing.PROPERTY_DB_CREATED_EVENT, h, { once: true });
    setTimeout(h, timeoutMs);
  });
}
async function waitGeometry(viewer, timeoutMs = 180000) {
  await new Promise((resolve) => {
    let done = false;
    const h = () => {
      if (done) return;
      done = true;
      try { viewer.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, h); } catch {}
      resolve();
    };
    viewer.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, h, { once: true });
    setTimeout(h, timeoutMs);
  });
}
async function waitViewerReady(viewer) {
  await Promise.all([ waitObjectTree(viewer), waitPropertyDb(viewer), waitGeometry(viewer) ]);
  await waitIdle(60);
}

function resetViewerInputAndCamera(viewer) {
  try {
    const tc = viewer.toolController;
    if (tc?.isToolActivated?.("BoxSelectionTool")) tc.deactivateTool("BoxSelectionTool");
    viewer.setNavigationLock(false);
    viewer.setActiveNavigationTool?.(viewer.impl?.is2d ? "pan" : "orbit");
    viewer.setSelectionMode(Autodesk.Viewing.SelectionMode.MIXED);
    viewer.clearSelection?.();
    if (!viewer.impl?.is2d) {
      viewer.navigation.setWorldUpVector(new THREE.Vector3(0,0,1), true);
      const bb = viewer.model?.getBoundingBox?.();
      if (bb) {
        const c = bb.getCenter(new THREE.Vector3());
        viewer.navigation.setPivotPoint(c);
        viewer.navigation.setTarget(c);
      }
    }
    viewer.fitToView?.();
  } catch(e) { console.warn("[init] resetViewerInputAndCamera failed:", e); }
}
async function focusCameraAndWait(viewer) {
  return new Promise((resolve) => {
    const onCam = () => {
      try { viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, onCam); } catch {}
      requestAnimationFrame(() => resolve());
    };
    viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, onCam, { once: true });
    resetViewerInputAndCamera(viewer); // fitToView 트리거
  });
}

function initSidebarWidth() {
  const root = document.documentElement;
  const stored = parseInt(localStorage.getItem("sidebarWidthPx") || "0", 10);
  const maxNow = Math.max(SIDEBAR_MIN, window.innerWidth - PREVIEW_MIN);
  const initial = Number.isFinite(stored) && stored >= SIDEBAR_MIN
    ? Math.min(maxNow, stored)
    : Math.min(maxNow, SIDEBAR_DEFAULT);
  root.style.setProperty("--sidebar-width", initial + "px");
  return initial;
}

// 루트~깊이N까지 pathKey 수집
async function collectKeysForRoots(provider, { maxDepth = 3, cap = 6000 } = {}) {
  const roots = (await provider.roots()) || [];
  const q = roots.map(r => ({ path: [r.text], depth: 0 }));
  const keys = new Set();
  let seen = 0;
  while (q.length && seen < cap) {
    const { path, depth } = q.shift();
    keys.add(toKey(path));
    let kids = [];
    try { kids = await provider.childrenByPath(path) || []; } catch {}
    seen += kids.length;
    if (depth < maxDepth) {
      for (const ch of kids) q.push({ path: ch.__path || [...path, ch.text], depth: depth + 1 });
    }
  }
  return Array.from(keys);
}

/* ----------------- task helpers ----------------- */
let taskData = [];
const SAMPLE_TASK_DATA = [/* 생략: 네 샘플 그대로 */];
function safeUrn(urn){ return urn.replace(/[^a-zA-Z0-9]/g, "_"); }
function fillUrnRecursive(task, defaultUrn) {
  if (Array.isArray(task.linkedObjects)) {
    task.linkedObjects.forEach((o)=>{ if (!o.urn) o.urn = defaultUrn || window.CURRENT_MODEL_URN; });
  }
  if (Array.isArray(task.children)) task.children.forEach((c)=>fillUrnRecursive(c, defaultUrn));
}
async function loadTaskDataIfExists() {
  try {
    const url = `/api/tasks?urn=${window.CURRENT_MODEL_SAFE_URN}`;
    const resp = await fetch(url, { credentials: "include" });
    taskData.length = 0;
    if (resp.ok) {
      const data = await resp.json();
      if (Array.isArray(data) && data.length) data.forEach((i)=>taskData.push(i));
      else SAMPLE_TASK_DATA.forEach((i)=>taskData.push(structuredClone(i)));
    } else {
      SAMPLE_TASK_DATA.forEach((i)=>taskData.push(structuredClone(i)));
    }
  } catch (err) {
    taskData.length = 0;
    SAMPLE_TASK_DATA.forEach((i)=>taskData.push(structuredClone(i)));
    console.warn("task 데이터 로드 실패, 샘플 사용:", err);
  }
}

/* ----------------- boot ----------------- */
window.addEventListener("resize", _.throttle(() => {
  try {
    initSidebarWidth();
    window.viewer?.resize?.();
    window.viewer?.impl?.invalidate?.(true, true, true);
  } catch (e) { console.warn("[resize] redraw failed", e); }
}, 120));

(async function(){
  try {
    // 레이아웃/뷰어
    initSidebarWidth();
    initTabs("#sidebar");
    const viewer = await initViewer(document.getElementById("viewer-host"));
    window.viewer = viewer;
    disableViewerEscReset(viewer);

    initTree("#tree", async (versionId) => {
      const urn = window.btoa(versionId).replace(/=/g, "");
      window.CURRENT_MODEL_URN = urn;
      window.CURRENT_MODEL_SAFE_URN = safeUrn(urn);

      // 기존 트리 정리
      try { $.ui.fancytree.getTree("#wbs-tree")?.destroy(); } catch {}
      $("#wbs-group-content").empty();

      // 태스크 로드 + URN 보정 + 저장
      await loadTaskDataIfExists();
      taskData.forEach((t)=>fillUrnRecursive(t, urn));
      setSavedTaskData(taskData);

      const myToken = ++__MODEL_RUN_TOKEN;

      // 모델 로드/대기/카메라
      await loadModel(viewer, urn);
      await waitViewerReady(viewer);
      await focusCameraAndWait(viewer);
      viewer.resize();

      if (myToken !== __MODEL_RUN_TOKEN) return;

      // WBS provider 생성
      let wbsProvider;
      try {
        const { provider } = await buildWbsProviderLazy(viewer, {
          primaryOrder: ["HEC.WBS","HEC.Level","HEC.Zone"],
          source: "all",
          bucketThreshold: 400,
          bucketSize: 200
        });
        wbsProvider = provider;
      } catch (e) {
        console.warn("[STEP 3] WBS provider failed:", e);
        wbsProvider = { roots: async()=>[], childrenByPath: async()=>[] };
      }

      // ── 핵심 순서 시작 ─────────────────────────────────
      // 1) 매트릭스 초기화
      await initMatrix({ primaryOrder: ["HEC.WBS","HEC.Level","HEC.Zone"], provider: wbsProvider });

      // 2) ★ 작업 상태 반영 (C/T/D 매핑 생성) — 이것 때문에 0,0,0,0이 나오던 것!
      await Promise.resolve(markTasksChanged());
      await waitIdle(0);

      // 3) 키 보장/상태 계산 (선계산)
      const preKeys = await collectKeysForRoots(wbsProvider, { maxDepth: 3, cap: 6000 });
      await bulkEnsureForVisible(preKeys);
      preKeys.forEach(computePathState);

      // 4) sanity 로그 — 여기서 이미 C/T/D가 찍혀야 정상
      try {
        const roots = (await wbsProvider.roots()) || [];
        console.log("[sanity] roots =", roots.length);
        console.log("[sanity] typeof getCounts =", typeof getCounts);
        for (const r of roots) {
          const k = toKey([r.text]);
          const c = getCounts(k);
          console.log("[counts]", r.text, c);
        }
      } catch (e) {
        console.warn("[sanity] counts log failed:", e);
      }
      // ──────────────────────────────────────────────────

      // FancyTree 초기화 (이제 숫자/색칠 다 준비된 상태)
      await initWbsPanelWithFancytree(wbsProvider, { primaryOrder: ["HEC.WBS","HEC.Level","HEC.Zone"] });
      bindPanel2Resizer(viewer);

      // Task 패널
      try {
        initTaskPanel(taskData);
        initTaskListButtons();
      } catch (e) {
        console.warn("[Task] init failed:", e);
      }
    });
  } catch (err) {
    alert("Could not initialize the application. See console for more details.");
    console.error(err);
  }
})();