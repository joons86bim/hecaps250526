// /wwwroot/js/sidebar/task-wbs/ui/current-task-modal.js
import { calendarSvg } from "./calendar-svg.js";
// import { checkTaskStatusByDate } from "../logic/task-check-basedondate.js"; // 사용 안 함(정책 오버라이드)
import { apply4DAt, reset4D } from "../../task-wbs/4d/4d-simulation.js";

export function showCurrentTaskModal() {
  if (document.querySelector(".current-task-modal")) return;

  const todayStr = isoToday();

  // ─ UI
  const modal = document.createElement("div");
  modal.className = "current-task-modal";
  modal.tabIndex = 0;
  modal.innerHTML = `
    <div class="current-task-modal-header">
      <span class="modal-title">공정현황</span>
      <button type="button" class="modal-close" title="닫기" aria-label="닫기">×</button>
    </div>
    <div class="current-task-modal-body">
      <div class="current-task-date-row">
        <input type="text" class="current-task-date-input" maxlength="10" placeholder="yyyy-mm-dd" value="${todayStr}" autocomplete="off" />
        <button type="button" class="datepicker-btn" tabindex="-1" title="달력 열기">${calendarSvg}</button>
        <button type="button" class="btn-today" title="오늘로 이동">오늘</button>
      </div>

      <div class="current-task-slider-row">
        <input type="range" class="current-task-slider" min="-15" max="15" value="0" />
      </div>

      <div class="sim-toolbar" aria-label="시뮬레이션 컨트롤">
        <!-- 순서 고정: ㅣ< , ㅁ , > , >ㅣ -->
        <button type="button" class="sim-btn sim-begin" title="5초 뒤로"   aria-label="5초 뒤로">${svgIcon('begin')}</button>
        <button type="button" class="sim-btn sim-stop"  title="정지/맨앞"  aria-label="정지/맨앞">${svgIcon('stop')}</button>
        <button type="button" class="sim-btn sim-play"  title="재생"      aria-label="재생">${svgIcon('play')}</button>
        <button type="button" class="sim-btn sim-end"   title="5초 앞으로" aria-label="5초 앞으로">${svgIcon('end')}</button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);

  applyInlineStyles(modal);
  centerModal(modal);

  // 핸들
  const $input    = modal.querySelector(".current-task-date-input");
  const $btnCal   = modal.querySelector(".datepicker-btn");
  const $btnToday = modal.querySelector(".btn-today");
  const $close    = modal.querySelector(".modal-close");
  const $header   = modal.querySelector(".current-task-modal-header");
  const $slider   = modal.querySelector(".current-task-slider");

  // 컨트롤
  const $btnBegin = modal.querySelector(".sim-begin"); // ㅣ< : 5초 '뒤로'
  const $btnPlay  = modal.querySelector(".sim-play");  // >
  const $btnStop  = modal.querySelector(".sim-stop");  // ㅁ
  const $btnEnd   = modal.querySelector(".sim-end");   // >ㅣ : 5초 '앞으로'

  // 상태 & 파라미터
  const SIM = {
    playing: false,
    raf: 0,
    lastTs: 0,
    stepSec: 5, // 버튼 스텝(초)
    speedDaysPerSec: window.SIM4D_SPEED_DAYS_PER_SEC ?? 1.0,   // 1초=며칠
    zOffset: window.SIM4D_Z_OFFSET ?? 3.0,
    useDateDuration: (window.SIM4D_USE_DATE_DURATION ?? true) === true,
    fixedDurationSec: window.SIM4D_FIXED_DURATION_SEC ?? 2.0,
    minISO: null, maxISO: null,   // 경계(ISO)
    minMs: null,  maxMs: null,    // 경계(ms)
    curMs: null                   // ★ 내부 시계(ms) — 누적 진행 전용
  };

  // IMask
  let mask = null;
  if (window.IMask) mask = window.IMask($input, { mask: "0000-00-00", lazy: false, autofix: true });
  enforceSmartSelection($input);

  // flatpickr
  const fp = window.flatpickr($input, {
    dateFormat: "Y-m-d",
    defaultDate: todayStr,
    allowInput: true,
    clickOpens: false,
    onChange: (_, dateStr) => {
      if (!isISO(dateStr)) return;
      setSimMs(Date.parse(dateStr), { apply: true, from: "flatpickr" });
    }
  });

  // 직접 입력
  $input.addEventListener("change", () => {
    const val = $input.value.trim();
    if (!isISO(val)) return;
    setSimMs(Date.parse(val), { apply: true, from: "input-change" });
  });

  // 달력 버튼
  $btnCal.addEventListener("click", (e) => { e.stopPropagation(); fp.open(); });

  // 트리 기반 범위 계산
  const tree = window.taskTree;
  updateSliderRangeFromTaskData(tree?.getRootNode()?.children || [], $slider);
  const bounds = computeGlobalBoundsFromTaskData(tree?.getRootNode()?.children || []);
  SIM.minISO = bounds.minISO;
  SIM.maxISO = bounds.maxISO;
  SIM.minMs  = isISO(SIM.minISO) ? Date.parse(SIM.minISO) : null;
  SIM.maxMs  = isISO(SIM.maxISO) ? Date.parse(SIM.maxISO) : null;

  // 오늘 버튼 (범위 내로 클램프)
  $btnToday.addEventListener("click", () => {
    const dISO = clampISO(isoToday(), SIM.minISO, SIM.maxISO);
    setSimMs(Date.parse(dISO), { apply: true, from: "today" });
  });

  // 슬라이더: 드래그 중 빠른 반응(40ms), 드롭 시 즉시
  const debouncedApply = debounce((iso) => applyByPolicy(iso, "slider-input", modal), 40);
  $slider.addEventListener("input", () => {
    const dISO = isoOffsetFromToday(parseInt($slider.value, 10));
    // 슬라이더는 UI 반영만 빠르게 하고, 정책은 디바운스 적용
    setSimMs(Date.parse(dISO), { apply: false, from: "slider-input" });
    debouncedApply(dISO);
  });
  $slider.addEventListener("change", () => {
    const dISO = isoOffsetFromToday(parseInt($slider.value, 10));
    setSimMs(Date.parse(dISO), { apply: true, from: "slider-change" });
  });

  // 헤더 드래그
  enableModalDrag(modal, $header);

  // 닫기(완전 초기화)
  $close.addEventListener("click", (e) => { e.stopPropagation(); resetViewerAndCloseEx(modal, SIM); });
  modal.addEventListener("keydown", (ev) => { if (ev.key === "Escape") resetViewerAndCloseEx(modal, SIM); });

  // 컨트롤 바인딩
  // ㅣ< : 5초 '뒤로'
  $btnBegin?.addEventListener("click", () => {
    const next = (SIM.curMs ?? Date.parse($input.value)) - SIM.stepSec * 1000 * SIM.speedDaysPerSec * 86400 / 86400;
    setSimMs(next, { apply: true, from: "nudge-back" });
  });
  // >ㅣ : 5초 '앞으로'
  $btnEnd?.addEventListener("click", () => {
    const next = (SIM.curMs ?? Date.parse($input.value)) + SIM.stepSec * 1000 * SIM.speedDaysPerSec * 86400 / 86400;
    setSimMs(next, { apply: true, from: "nudge-forward" });
  });

  // ㅁ : 재생 중이면 정지, 정지 중이면 '맨 앞으로'
  $btnStop?.addEventListener("click", () => {
    if (SIM.playing) {
      SIM.playing = false;
      if (SIM.raf) cancelAnimationFrame(SIM.raf);
      SIM.raf = 0;
    } else if (SIM.minMs != null) {
      setSimMs(SIM.minMs, { apply: true, from: "stop-reset" });
    }
  });

  // > : 재생 (현재가 최대면 맨 앞으로 보정 후 시작)
  $btnPlay?.addEventListener("click", () => {
    if (SIM.playing) return;
    if (SIM.curMs == null) SIM.curMs = Date.parse($input.value);
    if (SIM.maxMs != null && SIM.curMs >= SIM.maxMs) {
      if (SIM.minMs != null) setSimMs(SIM.minMs, { apply: true, from: "play-reset" });
    }
    SIM.playing = true;
    SIM.lastTs = performance.now();
    SIM.raf = requestAnimationFrame(loop);
  });

  // 최초 상태: 오늘(클램프)
  {
    const initISO = clampISO(todayStr, SIM.minISO, SIM.maxISO);
    setSimMs(Date.parse(initISO), { apply: true, from: "init" });
  }

  // ───────── 내부: 시간/적용 헬퍼 ─────────
  function loop(now){
    if (!SIM.playing) return;
    const dtSec = Math.max(0, (now - SIM.lastTs) / 1000);
    SIM.lastTs = now;

    // 1초당 n일 → ms 이동
    const deltaMs = dtSec * SIM.speedDaysPerSec * 86400000;
    let nextMs = (SIM.curMs ?? Date.parse($input.value)) + deltaMs;

    // 경계 클램프
    if (SIM.minMs != null) nextMs = Math.max(nextMs, SIM.minMs);
    if (SIM.maxMs != null) nextMs = Math.min(nextMs, SIM.maxMs);

    // 엔드 스톱: 최대에 도달하면 정지
    if (SIM.maxMs != null && nextMs >= SIM.maxMs && SIM.curMs >= SIM.maxMs) {
      SIM.playing = false;
      if (SIM.raf) cancelAnimationFrame(SIM.raf);
      SIM.raf = 0;
      return;
    }

    setSimMs(nextMs, { apply: true, from: "play" });
    SIM.raf = requestAnimationFrame(loop);
  }

  // 내부 시계(ms)를 기준으로 UI/정책/4D를 반영
  function setSimMs(ms, { apply = true, from = "" } = {}) {
    if (!Number.isFinite(ms)) return;

    // 클램프(ms)
    if (SIM.minMs != null && ms < SIM.minMs) ms = SIM.minMs;
    if (SIM.maxMs != null && ms > SIM.maxMs) ms = SIM.maxMs;

    SIM.curMs = ms;

    // UI 반영(문자열로): 날짜/슬라이더 동기화
    const iso = msToISO(ms);
    setDateInput(iso, { apply, from });
  }

  // 날짜 입력 값을 세팅하고 색상/4D 반영 (SIM.curMs는 setSimMs에서 관리)
  function setDateInput(dateStr, { apply = true, from = "" } = {}) {
    const safe = clampISO(dateStr, SIM.minISO, SIM.maxISO);
    $input.value = safe;
    if (mask) { try { mask.updateValue(); } catch(_) {} }
    syncSliderFromDate($slider, safe);

    if (apply) {
      applyByPolicy(safe, from, modal);
      try {
        apply4DAt(window.viewer, safe, {
          zOffset: SIM.zOffset,
          useDateDuration: SIM.useDateDuration,
          fixedDurationSec: SIM.fixedDurationSec,
          speedDaysPerSec: SIM.speedDaysPerSec
        });
      } catch (e) {
        console.warn("[4D] apply error:", e);
      }
    }
  }
}

/* ───────── 정책(원본 유지) ───────── */
function applyByPolicy(dateStr, source, ctxEl){
  const v = window.viewer; const tree = window.taskTree;
  if (!v || !tree || !isISO(dateStr)) return;

  const model = (v.getVisibleModels && v.getVisibleModels()[0]) || v.model;
  if (!model) return;

  const urnCur = String(window.CURRENT_MODEL_URN || "");
  const showSet  = new Set();
  const hideSet  = new Set();
  const themeC   = new Set(); // green
  const themeT   = new Set(); // blue
  const themeD   = new Set(); // red

  const inRange = (d, s, e) => (isISO(s) && isISO(e) && d >= s && d <= e);
  const beforeS = (d, s)     => (isISO(s) && d < s);
  const afterE  = (d, e)     => (isISO(e) && d > e);

  tree.getRootNode()?.visit((n) => {
    const d = n.data || {};
    const cat = normCat(d.selectedOption);
    if (!cat) return;

    const objs = Array.isArray(d.linkedObjects) ? d.linkedObjects : [];
    for (const o of objs) {
      const urn = String(o.urn || urnCur);
      if (!urnCur || urn !== urnCur) continue;
      const id = Number(o.dbId);
      if (!Number.isFinite(id)) continue;

      if (cat === "C") {
        if (beforeS(dateStr, d.start)) { hideSet.add(id); }
        else if (inRange(dateStr, d.start, d.end)) { showSet.add(id); themeC.add(id); }
        else if (afterE(dateStr, d.end)) { showSet.add(id); }
        else { showSet.add(id); }
      } else if (cat === "T") {
        if (beforeS(dateStr, d.start)) { hideSet.add(id); }
        else if (inRange(dateStr, d.start, d.end)) { showSet.add(id); themeT.add(id); }
        else if (afterE(dateStr, d.end)) { showSet.add(id); }
        else { showSet.add(id); }
      } else if (cat === "D") {
        if (beforeS(dateStr, d.start)) { showSet.add(id); }
        else if (inRange(dateStr, d.start, d.end)) { showSet.add(id); themeD.add(id); }
        else if (afterE(dateStr, d.end)) { hideSet.add(id); }
        else { showSet.add(id); }
      }
    }
  });

  for (const id of showSet) hideSet.delete(id);

  try {
    if (!ctxEl.__simVisInit) {
      v.impl?.visibilityManager?.setAllOn?.();
      ctxEl.__simVisInit = true;
    }

    try { v.clearThemingColors?.(model); } catch(_) {}
    try { v.clearThemingColors?.(); } catch(_) {}

    const showArr = [...showSet];
    const hideArr = [...hideSet];
    if (showArr.length) v.show(showArr, model);
    if (hideArr.length) v.hide(hideArr, model);

    const V4 = (r,g,b,a=1) => (window.THREE ? new window.THREE.Vector4(r,g,b,a) : { r,g,b,a });
    const cGreen = V4(0.16, 0.57, 0.20, 1);
    const cBlue  = V4(0.12, 0.45, 0.90, 1);
    const cRed   = V4(0.95, 0.27, 0.23, 1);

    const paintChunk = (ids, color) => {
      const CHUNK = 4000;
      for (let i = 0; i < ids.length; i += CHUNK) {
        const slice = ids.slice(i, i + CHUNK);
        for (let j = 0; j < slice.length; j++) {
          v.setThemingColor(slice[j], color, model);
        }
      }
    };
    if (themeC.size) paintChunk([...themeC], cGreen);
    if (themeT.size) paintChunk([...themeT], cBlue);
    if (themeD.size) paintChunk([...themeD], cRed);

    v.impl?.sceneUpdated?.(true);
    v.impl?.invalidate?.(true, true, true);
  } catch (err) {
    console.warn("[CurrentTask] policy apply error", err);
  }
}

/* ───────── 스타일/유틸 ───────── */
function applyInlineStyles(modal){
  Object.assign(modal.style, {
    zIndex: 10000,
    width: "300px",
    maxWidth: "90vw",
    background: "#fff",
    border: "1px solid #d9d9d9",
    borderRadius: "10px",
    boxShadow: "0 10px 24px rgba(0,0,0,.12)",
    fontFamily: "'Noto Sans KR', system-ui, -apple-system, 'Segoe UI', Arial, sans-serif",
    position: "fixed",
  });

  const header = modal.querySelector(".current-task-modal-header");
  Object.assign(header.style, {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    gap: "6px",
    padding: "6px 8px",
    borderBottom: "1px solid #eee",
    cursor: "grab",
    userSelect: "none",
    touchAction: "none"
  });

  const close = modal.querySelector(".modal-close");
  Object.assign(close.style, {
    border: "none",
    background: "transparent",
    fontSize: "18px",
    cursor: "pointer",
    lineHeight: "1",
  });

  const body = modal.querySelector(".current-task-modal-body");
  Object.assign(body.style, {
    padding: "8px",
    display: "flex",
    flexDirection: "column",
    gap: "6px"
  });

  const row = modal.querySelector(".current-task-date-row");
  Object.assign(row.style, {
    display: "flex",
    alignItems: "center",
    gap: "6px",
    justifyContent: "center",
    margin: "0"
  });

  const input = modal.querySelector(".current-task-date-input");
  Object.assign(input.style, {
    width: "118px",
    textAlign: "center",
    padding: "4px 6px",
    border: "1px solid #bbb",
    borderRadius: "6px",
    outline: "none",
  });

  const btnCal = modal.querySelector(".datepicker-btn");
  Object.assign(btnCal.style, {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    width: "28px",
    height: "28px",
    borderRadius: "6px",
    border: "1px solid #ddd",
    background: "#fafafa",
    cursor: "pointer",
    padding: "0"
  });

  const calSvg = btnCal.querySelector("svg");
  if (calSvg) { calSvg.setAttribute("width","16"); calSvg.setAttribute("height","16"); }

  const btnToday = modal.querySelector(".btn-today");
  Object.assign(btnToday.style, {
    height: "28px",
    padding: "0 10px",
    borderRadius: "6px",
    border: "1px solid #1976d2",
    background: "#1976d2",
    color: "#fff",
    cursor: "pointer"
  });

  const sliderRow = modal.querySelector(".current-task-slider-row");
  Object.assign(sliderRow.style, {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    padding: "0",
    margin: "0"
  });

  const slider = modal.querySelector(".current-task-slider");
  Object.assign(slider.style, {
    width: "100%",
    maxWidth: "260px",
    display: "block",
    margin: "2px 0"
  });

  const sim = modal.querySelector(".sim-toolbar");
  Object.assign(sim.style, {
    display: "flex",
    justifyContent: "center",
    gap: "6px",
    paddingTop: "4px",
    borderTop: "1px dashed #eee",
    marginTop: "0"
  });
  sim.querySelectorAll(".sim-btn").forEach(btn => {
    Object.assign(btn.style, {
      width: "36px",
      height: "30px",
      borderRadius: "8px",
      border: "1px solid #ddd",
      background: "#f8f9fb",
      cursor: "pointer",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      padding: "0"
    });
  });
}

function centerModal(modal){
  modal.style.visibility = "hidden";
  requestAnimationFrame(() => {
    const { innerWidth: w, innerHeight: h } = window;
    const r = modal.getBoundingClientRect();
    modal.style.left = Math.max(8, (w / 2 - r.width / 2)) + "px";
    modal.style.top  = Math.max(8, (h / 3 - r.height / 2)) + "px";
    modal.style.visibility = "visible";
  });
}

/* ───── 유틸 ───── */
function svgIcon(name){
  const stroke = "currentColor";
  if (name === "play")  return `<svg width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M8 5v14l11-7-11-7z" fill="${stroke}"/></svg>`;
  if (name === "stop")  return `<svg width="16" height="16" viewBox="0 0 24 24" fill="none"><rect x="6" y="6" width="12" height="12" rx="2" fill="${stroke}"/></svg>`;
  if (name === "begin") return `<svg width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M19 6l-7 6 7 6V6z" fill="${stroke}"/><rect x="5" y="6" width="2" height="12" fill="${stroke}"/></svg>`;
  if (name === "end")   return `<svg width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M5 6l7 6-7 6V6z" fill="${stroke}"/><rect x="17" y="6" width="2" height="12" fill="${stroke}"/></svg>`;
  return "";
}

function isISO(s){ return /^\d{4}-\d{2}-\d{2}$/.test(String(s||"")); }
function isoToday(){ return new Date().toISOString().slice(0,10); }
function isoOffsetFromToday(offsetDays){
  const base = new Date();
  base.setDate(base.getDate() + (Number(offsetDays) || 0));
  return base.toISOString().slice(0,10);
}
function msToISO(ms){ return new Date(ms).toISOString().slice(0,10); }
function clampISO(iso, minISO, maxISO){
  if (!isISO(iso)) return iso;
  let t = Date.parse(iso);
  if (isISO(minISO)) t = Math.max(t, Date.parse(minISO));
  if (isISO(maxISO)) t = Math.min(t, Date.parse(maxISO));
  return new Date(t).toISOString().slice(0,10);
}
function updateSliderRangeFromTaskData(nodes, sliderEl){
  if (!Array.isArray(nodes) || !sliderEl) return;
  const all = [];
  (function walk(arr){
    for (const n of arr) {
      const d = n.data || n;
      if (isISO(d.start)) all.push(d.start);
      if (isISO(d.end))   all.push(d.end);
      if (n.children) walk(n.children);
    }
  })(nodes);
  if (!all.length) { sliderEl.min = -15; sliderEl.max = 15; sliderEl.value = 0; return; }

  const minISO = all.reduce((a,b)=> a < b ? a : b);
  const maxISO = all.reduce((a,b)=> a > b ? a : b);
  const t = isoToday();

  const diffMin = Math.ceil((Date.parse(minISO) - Date.parse(t)) / 86400000);
  const diffMax = Math.ceil((Date.parse(maxISO) - Date.parse(t)) / 86400000);

  sliderEl.min = String(diffMin);
  sliderEl.max = String(diffMax);
  sliderEl.value = "0";
}
function computeGlobalBoundsFromTaskData(nodes){
  const all = [];
  (function walk(arr){
    for (const n of arr) {
      const d = n.data || n;
      if (isISO(d.start)) all.push(d.start);
      if (isISO(d.end))   all.push(d.end);
      if (n.children) walk(n.children);
    }
  })(nodes);
  if (!all.length) return { minISO: null, maxISO: null };
  const minISO = all.reduce((a,b)=> a < b ? a : b);
  const maxISO = all.reduce((a,b)=> a > b ? a : b);
  return { minISO, maxISO };
}
function syncSliderFromDate(sliderEl, dateStr){
  if (!sliderEl || !isISO(dateStr)) return;
  const t = isoToday();
  const diff = Math.round((Date.parse(dateStr) - Date.parse(t)) / 86400000);
  sliderEl.value = String(Math.min(Math.max(diff, Number(sliderEl.min)), Number(sliderEl.max)));
}
function normCat(v){
  const s = String(v || "").trim();
  if (s === "C" || s.startsWith("시공")) return "C";
  if (s === "T" || s.startsWith("가설")) return "T";
  if (s === "D" || s.startsWith("철거")) return "D";
  return "";
}
function enforceSmartSelection(input){
  const digitIdx = [0,1,2,3,5,6,8,9];
  const setSel = (pos) => { if (digitIdx.includes(pos)) input.setSelectionRange(pos, pos + 1); };
  const getDigitPos = (pos) => digitIdx.includes(pos) ? pos : (digitIdx.find(d => d > pos) ?? 9);
  const nextDigitIdx = (pos) => { const i = digitIdx.indexOf(pos); return (i !== -1 && i < digitIdx.length - 1) ? digitIdx[i+1] : pos; };
  const prevDigitIdx = (pos) => { const i = digitIdx.indexOf(pos); return (i > 0) ? digitIdx[i-1] : pos; };

  ["focus", "click"].forEach(evt => input.addEventListener(evt, () => setTimeout(() => setSel(getDigitPos(input.selectionStart)), 0)));
  input.addEventListener("keydown", (e) => {
    const pos = input.selectionStart;
    if (e.key === "ArrowLeft"  && pos !== 0)  { e.preventDefault(); setSel(prevDigitIdx(pos)); }
    if (e.key === "ArrowRight" && pos !== 9)  { e.preventDefault(); setSel(nextDigitIdx(pos)); }
  });
  input.addEventListener("input", () => {
    const pos = input.selectionStart;
    if (digitIdx.includes(pos - 1)) setSel(nextDigitIdx(pos - 1));
    else setSel(getDigitPos(pos));
  });
}

/* 드래그 */
function enableModalDrag(modal, handle){
  let dragging = false, pid = null;
  let startX = 0, startY = 0, startLeft = 0, startTop = 0;
  let raf = 0, nextLeft = 0, nextTop = 0;

  const isInteractive = (el) =>
    el.closest?.('.modal-close, .datepicker-btn, .btn-today, .sim-toolbar, .sim-btn, input, button, svg, path, rect, circle');

  const killDrag = (e) => e.preventDefault();
  handle.addEventListener('dragstart', killDrag);
  modal.addEventListener('dragstart', killDrag);

  const onPointerDown = (e) => {
    if (isInteractive(e.target)) return;
    if (e.button !== 0) return;
    e.preventDefault();
    e.stopPropagation();

    pid = e.pointerId;
    handle.setPointerCapture(pid);

    const cs = window.getComputedStyle(modal);
    const l = parseFloat(cs.left);
    const t = parseFloat(cs.top);
    if (Number.isFinite(l) && Number.isFinite(t)) {
      startLeft = l; startTop = t;
    } else {
      const r = modal.getBoundingClientRect();
      startLeft = r.left; startTop = r.top;
      modal.style.left = `${startLeft}px`;
      modal.style.top  = `${startTop}px`;
    }

    startX = e.clientX;
    startY = e.clientY;
    dragging = true;
    handle.style.cursor = "grabbing";
  };

  const onPointerMove = (e) => {
    if (!dragging) return;
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    nextLeft = Math.max(0, Math.round(startLeft + dx));
    nextTop  = Math.max(0, Math.round(startTop  + dy));

    if (!raf) {
      raf = requestAnimationFrame(() => {
        raf = 0;
        modal.style.left = `${nextLeft}px`;
        modal.style.top  = `${nextTop}px`;
      });
    }
  };

  const stopDrag = () => {
    if (!dragging) return;
    dragging = false;
    if (pid !== null) { try { handle.releasePointerCapture(pid); } catch(_){} }
    pid = null;
    handle.style.cursor = "grab";
  };

  handle.addEventListener("pointerdown", onPointerDown);
  handle.addEventListener("pointermove", onPointerMove);
  handle.addEventListener("pointerup", stopDrag);
  handle.addEventListener("pointercancel", stopDrag);
  window.addEventListener("pointerup", stopDrag, { passive: true });
}

/* 완전 초기화 */
function resetViewerAndCloseEx(m, SIM){
  try {
    if (SIM) {
      SIM.playing = false;
      if (SIM.raf) cancelAnimationFrame(SIM.raf);
      SIM.raf = 0;
    }
    const v = window.viewer;
    try { reset4D(v); } catch(_) {}

    try { v?.clearThemingColors?.(); } catch(_){}
    const vm = v?.impl?.visibilityManager;
    vm?.setAllOn?.();

    try { v?.setCutPlanes?.([]); } catch(_){}
    v?.impl?.invalidate?.(true, true, true);
  } catch(_){}
  m.remove();
}

/* debounce */
function debounce(fn, ms){
  let t=0;
  return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
}