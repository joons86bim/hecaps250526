// /core/wbs-store.js
// WBS 트리에서 한 번 구조/인덱스를 뽑아 캐시하고, 링크 시엔 이 저장소만 참조.
// - 트리 문서 순서(nodesInOrder)
// - path(문자열 배열) → dbIds(자손 포함) 맵
// - dbId → path 맵
// - 체크 노드 목록(트리 순서) 반환

export let WbsStore = {
  tree: null,
  nodesInOrder: [],
  pathKeyToDbIds: new Map(), // "A␁B␁C" -> [dbId...]
  dbIdToPath: new Map(),     // dbId -> ["A","B","C"]
  isReady: false,
};

const SEP = "\u0001"; // 경로 키 구분자(트리 텍스트에 없을 법한 문자)

/** 초기화 + 트리 이벤트에 맞춰 자동 리빌드 */
export function initWbsStore(tree) {
  WbsStore.tree = tree || window.wbsTree || null;
  rebuildWbsIndex();

  // fancytree 기준: 확장/축소/체크 변경 시 인덱스 갱신(부하 적게 debounce)
  try {
    const $root = $(WbsStore.tree?.$div || "#wbs-tree");
    $root.off(".wbsstore");
    $root.on("fancytreechange.wbsstore fancytreeexpand.wbsstore fancytreecollapse.wbsstore", debounce(rebuildWbsIndex, 120));
  } catch(_) {}
}

/** 경로 배열 생성: ["구조벽","지상2층","101동", ...] */
export function pathOfNode(n){
  const out = [];
  let cur = n;
  while (cur && cur.text && !(typeof cur.isRoot === "function" && cur.isRoot())) {
    out.unshift(String(cur.text));
    cur = cur.parent;
  }
  return out;
}

/** 체크 노드를 트리 문서 순서로 반환 */
export function getCheckedNodesInOrder(){
  if (!WbsStore.isReady) rebuildWbsIndex();
  return WbsStore.nodesInOrder.filter(n => isChecked(n));
}

/** 주어진 경로에 해당하는 dbIds 반환 (기본: 자손 포함) */
export function getDbIdsForPath(pathArr, { includeDescendants = true } = {}){
  if (!WbsStore.isReady) rebuildWbsIndex();
  const key = (pathArr || []).join(SEP);

  if (includeDescendants) {
    const arr = WbsStore.pathKeyToDbIds.get(key);
    if (arr && arr.length) return arr.slice();
  }

  // 정확히 이 경로에 매핑된 leaf dbId만
  const out = [];
  for (const [id, p] of WbsStore.dbIdToPath.entries()) {
    if (arrayEq(p, pathArr)) out.push(id);
  }
  return out;
}

/** 필요 시 강제 리빌드 */
export function refreshWbsStore(){ rebuildWbsIndex(); }

/* ============= 내부 구현 ============= */

function rebuildWbsIndex(){
  const tree = WbsStore.tree || window.wbsTree;
  WbsStore.nodesInOrder = [];
  WbsStore.pathKeyToDbIds.clear();
  WbsStore.dbIdToPath.clear();
  WbsStore.isReady = false;

  const root = tree?.getRootNode?.();
  if (!root) return;

  // 1) 문서 순서 수집 + leaf(dbId) 즉시 맵핑
  root.visit((n) => {
    WbsStore.nodesInOrder.push(n);
    const path = pathOfNode(n);
    const pkey = path.join(SEP);

    if (isLeafWithDb(n)) {
      const id = Number(n.data?.dbId ?? n.dbId);
      if (Number.isFinite(id)) {
        WbsStore.dbIdToPath.set(id, path);
        pushPathId(pkey, id);
      }
    }
  });

  // 2) 그룹 노드: 자손 leaf dbId 집계하여 pathKeyToDbIds에 기록
  root.visit((n) => {
    if (n.hasChildren && n.hasChildren()) {
      const path = pathOfNode(n);
      const pkey = path.join(SEP);
      const acc = [];
      n.visit((c) => {
        if (c !== n && isLeafWithDb(c)) {
          const id = Number(c.data?.dbId ?? c.dbId);
          if (Number.isFinite(id)) acc.push(id);
        }
      });
      if (acc.length) WbsStore.pathKeyToDbIds.set(pkey, uniqKeepOrder(acc));
    }
  });

  WbsStore.isReady = true;
}

function isChecked(n){
  if (typeof n.isSelected === "function") return !!n.isSelected();
  return !!(n.selected || n.data?.selected || n.data?.checked);
}

function isLeafWithDb(n){
  const hasKids = (n.hasChildren && n.hasChildren());
  const id = Number(n.data?.dbId ?? n.dbId);
  return !hasKids && Number.isFinite(id);
}

function pushPathId(pkey, id){
  const arr = WbsStore.pathKeyToDbIds.get(pkey) || [];
  arr.push(id);
  WbsStore.pathKeyToDbIds.set(pkey, arr);
}

function uniqKeepOrder(arr){
  const s = new Set(); const out = [];
  for (const x of arr) if (!s.has(x)) { s.add(x); out.push(x); }
  return out;
}

function arrayEq(a, b){
  if (!Array.isArray(a) || !Array.isArray(b) || a.length !== b.length) return false;
  for (let i=0;i<a.length;i++){ if (String(a[i]) !== String(b[i])) return false; }
  return true;
}

function debounce(fn, ms){
  let t = 0;
  return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
}




// [데이터연결]
$("#btn-link").off("click").on("click", async function () {
  const taskTree = $.ui.fancytree.getTree("#treegrid");
  const selectedTaskNode = taskTree.getActiveNode();
  if (!selectedTaskNode) return alert("Task를 선택하세요!");
  if (selectedTaskNode.hasChildren && selectedTaskNode.hasChildren()) {
    alert("하위 작업이 있는 Task에는 연결할 수 없습니다.\n 최하위 Task를 선택해 주세요.");
    return;
  }

  // 저장소 준비 재시도(트리 늦게 붙는 경우)
  try { initWbsStore(window.wbsTree); refreshWbsStore(); } catch(_) {}

  const urn = window.CURRENT_MODEL_URN;
  const catSel = normalizeTaskCategory(selectedTaskNode.data?.selectedOption); // "C"|"T"|"D"
  const catLabel = catSel === "C" ? "시공" : (catSel === "T" ? "가설" : "철거");

  // 체크 노드를 문서 순서대로
  const checked = getCheckedNodesInOrder();
  if (!checked.length) return alert("WBS에서 객체를 선택하세요!");

  // 경로 → dbIds(자손 포함) in-order
  const orderedDbIds = [];
  const pathByDbId = new Map();
  const seen = new Set();

  for (const node of checked) {
    const pathArr = pathOfNode(node);
    let ids = getDbIdsForPath(pathArr, { includeDescendants: true }) || [];
    // leaf인데 인덱스가 없다면 혹시 dbId가 박혀 있으면 직접 사용
    if (!ids.length) {
      const leafId = Number(node.data?.dbId ?? node.dbId);
      if (Number.isFinite(leafId)) ids = [leafId];
    }
    for (const id of ids) {
      if (!seen.has(id)) {
        seen.add(id);
        orderedDbIds.push(id);
        pathByDbId.set(id, pathArr.slice());
      }
    }
  }
  if (!orderedDbIds.length) {
    return alert("선택한 WBS에서 dbId를 찾지 못했습니다.\n(지연 로드 중이면 WBS를 한 번 펼친 뒤 다시 시도하세요)");
  }

  // ElementId 프리페치
  try { await ensureElementIdIndexForDbIds(orderedDbIds); } catch {}

  // 저장용 오브젝트(경로 라벨 보존)
  const toLink = orderedDbIds.map((d) => {
    const p = pathByDbId.get(d) || [];
    const el = getElementIdFor(urn, d);
    const bracket = `[${el || d}]`;
    const pathLabel = p.length ? (p.join(" - ") + " - " + bracket) : bracket;
    return { urn, dbId: d, elementId: el || null, text: pathLabel };
  });

  // ==== 점유/충돌 처리(기존 로직 유지) ====
  await runWbsHighlightBatch(async () => {
    const occupancy = new Map();
    taskTree.getRootNode().visit(n => {
      const cat = normalizeTaskCategory(n.data?.selectedOption);
      if (!cat) return;
      (n.data?.linkedObjects || []).forEach(o => {
        const key = `${o.urn || urn}:${o.dbId}`;
        const slot = occupancy.get(key) || { C: null, T: null, D: null };
        if (cat === "C" && !slot.C) slot.C = n;
        if (cat === "T" && !slot.T) slot.T = n;
        if (cat === "D" && !slot.D) slot.D = n;
        occupancy.set(key, slot);
      });
    });

    const allowed = [];
    const conflictsForC = [];
    const conflictsC = [];
    const conflictsSame = [];

    toLink.forEach(obj => {
      const key = `${obj.urn}:${obj.dbId}`;
      const slot = occupancy.get(key) || { C: null, T: null, D: null };

      if (catSel === "C") {
        if (!slot.C && !slot.T && !slot.D) allowed.push(obj);
        else conflictsForC.push({ obj, slot });
      } else if (catSel === "T") {
        if (slot.C) conflictsC.push({ obj, slot });
        else if (slot.T) conflictsSame.push({ obj, slot });
        else allowed.push(obj);
      } else if (catSel === "D") {
        if (slot.C) conflictsC.push({ obj, slot });
        else if (slot.D) conflictsSame.push({ obj, slot });
        else allowed.push(obj);
      }
    });

    function unlinkFromNode(node, obj) {
      if (!node) return;
      node.data.linkedObjects = (node.data.linkedObjects || []).filter(
        o => !(String(o.urn || urn) === String(obj.urn) && Number(o.dbId) === Number(obj.dbId))
      );
      node.render && node.render();
    }

    if (catSel === "C" && conflictsForC.length) {
      const res = prompt([
        `선택한 객체 중 ${conflictsForC.length}개는 이미 다른 Task에 연결되어 있습니다.`,
        `규칙상 '시공'은 단독 연결만 가능합니다.`,
        ``,
        `1. 기존 연결 해제 후 이 Task(시공)로 새로 연결`,
        `2. 이미 연결된 객체만 제외하고 진행`,
        `3. 취소`,
        ``,
        `번호를 입력하세요 (1/2/3)`
      ].join("\n"), "2");
      if (res === "3" || res == null) return;
      if (res === "1") {
        conflictsForC.forEach(({ obj, slot }) => {
          unlinkFromNode(slot.C, obj);
          unlinkFromNode(slot.T, obj);
          unlinkFromNode(slot.D, obj);
          allowed.push(obj);
        });
      }
    }

    if ((catSel === "T" || catSel === "D") && conflictsC.length) {
      const res = prompt([
        `다음 객체는 '시공'에 이미 연결되어 있어 ${catLabel}과(와) 병행할 수 없습니다.`,
        ``,
        `1. 시공 연결 해제 후 이 Task(${catLabel})로 새로 연결`,
        `2. 이미 연결된 객체만 제외하고 진행`,
        `3. 취소`,
        ``,
        `번호를 입력하세요 (1/2/3)`
      ].join("\n"), "2");
      if (res === "3" || res == null) return;
      if (res === "1") {
        conflictsC.forEach(({ obj, slot }) => { unlinkFromNode(slot.C, obj); allowed.push(obj); });
      }
    }

    if ((catSel === "T" || catSel === "D") && conflictsSame.length) {
      const label = catLabel;
      const res = prompt([
        `다음 객체는 이미 '${label}'에 연결되어 있습니다.`,
        ``,
        `1. 기존 '${label}' 연결을 이 Task로 교체 (해당 카테고리만 교체)`,
        `2. 이미 연결된 객체만 제외하고 진행`,
        `3. 취소`,
        ``,
        `번호를 입력하세요 (1/2/3)`
      ].join("\n"), "2");
      if (res === "3" || res == null) return;
      if (res === "1") {
        conflictsSame.forEach(({ obj, slot }) => {
          if (catSel === "T") unlinkFromNode(slot.T, obj);
          if (catSel === "D") unlinkFromNode(slot.D, obj);
          allowed.push(obj);
        });
      }
    }

    if (allowed.length > 0) {
      const existing = selectedTaskNode.data.linkedObjects || [];
      const merged = [];
      const seenKey = new Set();
      const pushUniq = (o) => { const k = o.urn + ":" + o.dbId; if (!seenKey.has(k)) { seenKey.add(k); merged.push(o); } };
      // WBS 순서(allowed) 먼저, 그 다음 기존 항목
      allowed.forEach(pushUniq);
      existing.forEach(pushUniq);
      selectedTaskNode.data.linkedObjects = merged;
    }

    withWbsGate(() => {
      flush(true);
      try { window.gantt?.renderFromTrees(window.taskTree, window.wbsTree); } catch(_) {}
    });

    try { await notifyCoverageDirtyAndRepaint(); } catch {}
  });

  notifyWbsStatusRefresh();
});



