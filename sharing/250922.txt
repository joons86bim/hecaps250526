// /wwwroot/js/sidebar/task-wbs/core/wbs-store.js
// 목적: UI 트리 확장 여부와 무관하게, "정확히 체크된(V) 노드"의 모든 후손 leaf dbId를
//       가져올 수 있는 스냅샷/인덱스 저장소.
//
// 사용 요약:
//   initWbsStore({ tree: window.wbsTree, provider: window.__WBS_PROVIDER });
//   const nodes = getCheckedExactNodesInOrder();
//   const ids = await getAllDescendantDbIdsByPath(pathArr); // 확장 필요시 provider로 lazy load
//
// 제공 API:
//   initWbsStore({tree, provider})
//   setProvider(provider)
//   resetWbsStore()
//   refreshWbsStore()         // UI 트리 기반 인덱스 재빌드(보이는 범위 우선)
//   getCheckedExactNodesInOrder()
//   getAllDescendantDbIdsByPath(pathArr)
//   getOrderedDbIdsFromCheckedExact()  // ← 한 번에 (ids[], pathByDbId Map)
//   pathOfNode(node)

export const WbsStore = {
  tree: null,
  provider: null,
  nodesInOrder: [],
  pathKeyToDbIds: new Map(), // "A␁B␁C" -> [dbId...](자손 포함)
  dbIdToPath: new Map(),     // dbId -> ["A","B","C"]
  isReady: false,
};

const SEP = "\u0001"; // 경로 키 구분자

export function initWbsStore({ tree, provider } = {}) {
  if (tree) WbsStore.tree = tree;
  if (provider) WbsStore.provider = provider;
  rebuildIndexFromVisibleTree();
  // fancytree 이벤트에 따라 가볍게 갱신
  try {
    const $root = $(WbsStore.tree?.$div || "#wbs-tree");
    $root.off(".wbsstore");
    $root.on("fancytreechange.wbsstore fancytreeexpand.wbsstore fancytreecollapse.wbsstore", debounce(rebuildIndexFromVisibleTree, 120));
  } catch(_) {}
}

export function setProvider(provider){
  WbsStore.provider = provider || null;
}

export function resetWbsStore(){
  WbsStore.nodesInOrder = [];
  WbsStore.pathKeyToDbIds.clear();
  WbsStore.dbIdToPath.clear();
  WbsStore.isReady = false;
}

export function refreshWbsStore(){
  rebuildIndexFromVisibleTree();
}

export function pathOfNode(n){
  const out = [];
  let cur = n;
  while (cur && cur.text && !(typeof cur.isRoot === "function" && cur.isRoot())) {
    out.unshift(String(cur.text));
    cur = cur.parent;
  }
  return out;
}

export function getCheckedExactNodesInOrder(){
  if (!WbsStore.isReady) rebuildIndexFromVisibleTree();
  return WbsStore.nodesInOrder.filter(isCheckedExact);
}

/** 체크(V)된 노드들의 자손 leaf dbId를 UI 확장 없이 수집 (WBS 순서 유지) */
export async function getOrderedDbIdsFromCheckedExact(){
  const checked = getCheckedExactNodesInOrder();
  const orderedDbIds = [];
  const pathByDbId = new Map();
  const seen = new Set();

  for (const node of checked) {
    const pathArr = pathOfNode(node);
    const ids = await getAllDescendantDbIdsByPath(pathArr);
    for (const id of ids) {
      if (!seen.has(id)) {
        seen.add(id);
        orderedDbIds.push(id);
        pathByDbId.set(id, pathArr.slice());
      }
    }
  }
  return { orderedDbIds, pathByDbId };
}

/** 주어진 경로의 모든 자손 leaf dbId 반환(스냅샷에 없으면 provider로 lazy 확장 후 캐시) */
export async function getAllDescendantDbIdsByPath(pathArr){
  if (!Array.isArray(pathArr) || !pathArr.length) return [];
  if (!WbsStore.isReady) rebuildIndexFromVisibleTree();

  const key = pathArr.join(SEP);
  let cached = WbsStore.pathKeyToDbIds.get(key);
  if (Array.isArray(cached) && cached.length) return cached.slice();

  // 없으면 provider로 lazy 확장
  const ids = await ensureSubtreeAndCollect(pathArr);
  if (ids.length) WbsStore.pathKeyToDbIds.set(key, ids.slice());
  return ids;
}

/* ============= 내부 구현 ============= */

function rebuildIndexFromVisibleTree(){
  resetWbsStore();
  const tree = WbsStore.tree || window.wbsTree;
  const root = tree?.getRootNode?.();
  if (!root) return;

  root.visit((n) => {
    WbsStore.nodesInOrder.push(n);
    if (isLeafWithDb(n)) {
      const path = pathOfNode(n);
      const pkey = path.join(SEP);
      const id = Number(n.data?.dbId ?? n.dbId);
      if (Number.isFinite(id)) {
        WbsStore.dbIdToPath.set(id, path);
        appendToKeyArray(WbsStore.pathKeyToDbIds, pkey, id);
      }
    }
  });

  // 그룹 경로에 대해 현재 보이는 자손만이라도 집계
  root.visit((n) => {
    if (n.hasChildren && n.hasChildren()) {
      const path = pathOfNode(n);
      const pkey = path.join(SEP);
      const acc = [];
      n.visit((c) => {
        if (c !== n && isLeafWithDb(c)) {
          const id = Number(c.data?.dbId ?? c.dbId);
          if (Number.isFinite(id)) acc.push(id);
        }
      });
      if (acc.length) WbsStore.pathKeyToDbIds.set(pkey, uniqKeepOrder(acc));
    }
  });

  WbsStore.isReady = true;
}

async function ensureSubtreeAndCollect(pathArr){
  // provider가 전체 트리를 서비스할 수 있어야 함
  const p = WbsStore.provider;
  if (!p || typeof p.childrenByPath !== "function") return [];
  // BFS로 path 이하 모든 leaf까지 확장
  const queue = [ pathArr.slice() ];
  const leafIds = [];
  const seenPathKey = new Set();

  while (queue.length) {
    const curPath = queue.shift();
    const key = curPath.join(SEP);
    if (seenPathKey.has(key)) continue;
    seenPathKey.add(key);

    let children = [];
    try {
      children = await p.childrenByPath(curPath); // [{text, dbId?}] child list
    } catch(_){ children = []; }

    const subIds = [];
    for (const ch of (children || [])) {
      const text = String(ch.text || ch.name || "").trim();
      if (!text) continue;
      const nextPath = curPath.concat(text);
      const id = Number(ch.dbId ?? ch.data?.dbId);
      if (Number.isFinite(id)) {
        // leaf
        WbsStore.dbIdToPath.set(id, nextPath);
        subIds.push(id);
      } else {
        // group
        queue.push(nextPath);
      }
    }

    if (subIds.length) {
      const pkey = curPath.join(SEP);
      const merged = uniqKeepOrder([...(WbsStore.pathKeyToDbIds.get(pkey) || []), ...subIds]);
      WbsStore.pathKeyToDbIds.set(pkey, merged);
      leafIds.push(...subIds);
    }
  }

  // 최상위 pathArr의 자손 통합 결과
  const key = pathArr.join(SEP);
  return uniqKeepOrder([...(WbsStore.pathKeyToDbIds.get(key) || []), ...leafIds]);
}

/* 유틸 */

function isCheckedExact(n){
  // 정확히 V 상태만 (부분선택/하이픈 제외)
  const sel = (typeof n.isSelected === "function") ? n.isSelected() : !!(n.selected || n.data?.selected === true || n.data?.checked === true);
  const part = (typeof n.isPartsel === "function") ? n.isPartsel() : !!n.partsel;
  return !!sel && !part;
}

function isLeafWithDb(n){
  const hasKids = (n.hasChildren && n.hasChildren());
  const id = Number(n.data?.dbId ?? n.dbId);
  return !hasKids && Number.isFinite(id);
}

function appendToKeyArray(map, key, val){
  const arr = map.get(key) || [];
  arr.push(val);
  map.set(key, arr);
}

function uniqKeepOrder(arr){
  const s = new Set(), out = [];
  for (const x of arr) if (!s.has(x)) { s.add(x); out.push(x); }
  return out;
}

function debounce(fn, ms){
  let t=0;
  return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); };
}




// [데이터연결]
$("#btn-link").off("click").on("click", async function () {
  const taskTree = $.ui.fancytree.getTree("#treegrid");
  const selectedTaskNode = taskTree.getActiveNode();
  if (!selectedTaskNode) return alert("Task를 선택하세요!");
  if (selectedTaskNode.hasChildren && selectedTaskNode.hasChildren()) {
    alert("하위 작업이 있는 Task에는 연결할 수 없습니다.\n 최하위 Task를 선택해 주세요.");
    return;
  }

  // 저장소 최신화(체크박스 상태 반영)
  try { refreshWbsStore(); } catch(_) {}

  const urn = window.CURRENT_MODEL_URN;
  const catSel = normalizeTaskCategory(selectedTaskNode.data?.selectedOption); // "C"|"T"|"D"
  const catLabel = catSel === "C" ? "시공" : (catSel === "T" ? "가설" : "철거");

  // 정확히 체크된(V) 노드들로부터 WBS 문서 순서대로 dbId 수집(확장 불필요)
  const { orderedDbIds, pathByDbId } = await getOrderedDbIdsFromCheckedExact();
  if (!orderedDbIds.length) return alert("WBS에서 '체크(V)'된 항목이 없습니다.");

  // ElementId 프리페치
  try { await ensureElementIdIndexForDbIds(orderedDbIds); } catch {}

  // 저장용 오브젝트(경로라벨 보존: "A - B - C - [ElementId|dbId]")
  const toLink = orderedDbIds.map((d) => {
    const p = pathByDbId.get(d) || [];
    const el = getElementIdFor(urn, d);
    const bracket = `[${el || d}]`;
    const pathLabel = p.length ? (p.join(" - ") + " - " + bracket) : bracket;
    return { urn, dbId: d, elementId: el || null, text: pathLabel };
  });

  // ==== 점유/충돌 처리(기존 로직 유지) ====
  await runWbsHighlightBatch(async () => {
    const occupancy = new Map();
    taskTree.getRootNode().visit(n => {
      const cat = normalizeTaskCategory(n.data?.selectedOption);
      if (!cat) return;
      (n.data?.linkedObjects || []).forEach(o => {
        const key = `${o.urn || urn}:${o.dbId}`;
        const slot = occupancy.get(key) || { C: null, T: null, D: null };
        if (cat === "C" && !slot.C) slot.C = n;
        if (cat === "T" && !slot.T) slot.T = n;
        if (cat === "D" && !slot.D) slot.D = n;
        occupancy.set(key, slot);
      });
    });

    const allowed = [];
    const conflictsForC = [];
    const conflictsC = [];
    const conflictsSame = [];

    toLink.forEach(obj => {
      const key = `${obj.urn}:${obj.dbId}`;
      const slot = occupancy.get(key) || { C: null, T: null, D: null };

      if (catSel === "C") {
        if (!slot.C && !slot.T && !slot.D) allowed.push(obj);
        else conflictsForC.push({ obj, slot });
      } else if (catSel === "T") {
        if (slot.C) conflictsC.push({ obj, slot });
        else if (slot.T) conflictsSame.push({ obj, slot });
        else allowed.push(obj);
      } else if (catSel === "D") {
        if (slot.C) conflictsC.push({ obj, slot });
        else if (slot.D) conflictsSame.push({ obj, slot });
        else allowed.push(obj);
      }
    });

    function unlinkFromNode(node, obj) {
      if (!node) return;
      node.data.linkedObjects = (node.data.linkedObjects || []).filter(
        o => !(String(o.urn || urn) === String(obj.urn) && Number(o.dbId) === Number(obj.dbId))
      );
      node.render && node.render();
    }

    if (catSel === "C" && conflictsForC.length) {
      const res = prompt([
        `선택한 객체 중 ${conflictsForC.length}개는 이미 다른 Task에 연결되어 있습니다.`,
        `규칙상 '시공'은 단독 연결만 가능합니다.`,
        ``,
        `1. 기존 연결 해제 후 이 Task(시공)로 새로 연결`,
        `2. 이미 연결된 객체만 제외하고 진행`,
        `3. 취소`,
        ``,
        `번호를 입력하세요 (1/2/3)`
      ].join("\n"), "2");
      if (res === "3" || res == null) return;
      if (res === "1") {
        conflictsForC.forEach(({ obj, slot }) => {
          unlinkFromNode(slot.C, obj);
          unlinkFromNode(slot.T, obj);
          unlinkFromNode(slot.D, obj);
          allowed.push(obj);
        });
      }
    }

    if ((catSel === "T" || catSel === "D") && conflictsC.length) {
      const res = prompt([
        `다음 객체는 '시공'에 이미 연결되어 있어 ${catLabel}과(와) 병행할 수 없습니다.`,
        ``,
        `1. 시공 연결 해제 후 이 Task(${catLabel})로 새로 연결`,
        `2. 이미 연결된 객체만 제외하고 진행`,
        `3. 취소`,
        ``,
        `번호를 입력하세요 (1/2/3)`
      ].join("\n"), "2");
      if (res === "3" || res == null) return;
      if (res === "1") {
        conflictsC.forEach(({ obj, slot }) => { unlinkFromNode(slot.C, obj); allowed.push(obj); });
      }
    }

    if ((catSel === "T" || catSel === "D") && conflictsSame.length) {
      const label = catLabel;
      const res = prompt([
        `다음 객체는 이미 '${label}'에 연결되어 있습니다.`,
        ``,
        `1. 기존 '${label}' 연결을 이 Task로 교체 (해당 카테고리만 교체)`,
        `2. 이미 연결된 객체만 제외하고 진행`,
        `3. 취소`,
        ``,
        `번호를 입력하세요 (1/2/3)`
      ].join("\n"), "2");
      if (res === "3" || res == null) return;
      if (res === "1") {
        conflictsSame.forEach(({ obj, slot }) => {
          if (catSel === "T") unlinkFromNode(slot.T, obj);
          if (catSel === "D") unlinkFromNode(slot.D, obj);
          allowed.push(obj);
        });
      }
    }

    if (allowed.length > 0) {
      const existing = selectedTaskNode.data.linkedObjects || [];
      const merged = [];
      const seenKey = new Set();
      const pushUniq = (o) => { const k = o.urn + ":" + o.dbId; if (!seenKey.has(k)) { seenKey.add(k); merged.push(o); } };
      // WBS 순서(allowed) 먼저, 그 다음 기존 항목
      allowed.forEach(pushUniq);
      existing.forEach(pushUniq);
      selectedTaskNode.data.linkedObjects = merged;
    }

    withWbsGate(() => {
      flush(true);
      try { window.gantt?.renderFromTrees(window.taskTree, window.wbsTree); } catch(_) {}
    });

    try { await notifyCoverageDirtyAndRepaint(); } catch {}
  });

  notifyWbsStatusRefresh();
});









