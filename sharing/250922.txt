/** ───────────────── Checked 노드 안전 수집(Fancytree 전용) ─────────────────
 * 1차: API t.getSelectedNodes(false)
 * 2차: 전체 노드 방문해 node.selected 검사
 * 3차: DOM 폴백(.fancytree-checkbox[aria-checked="true"] 등) → getNode(el)
 * partsel(부분선택)은 제외
 */
function getCheckedNodesFT() {
  const tree = $.ui.fancytree.getTree("#wbs-tree");
  if (!tree) return [];

  // 1) 공식 API
  try {
    const a = tree.getSelectedNodes(false).filter(n => !n.partsel);
    if (a.length) return a;
  } catch(_) {}

  // 2) 전체 방문해서 selected=true 찾기
  try {
    const found = [];
    tree.getRootNode()?.visit((n) => {
      if (n.selected && !n.partsel) found.push(n);
    });
    if (found.length) return found;
  } catch(_) {}

  // 3) DOM 폴백
  try {
    const $cont = $("#wbs-tree");
    const $cand = $cont.find(
      '.fancytree-node.fancytree-selected, .fancytree-checkbox[aria-checked="true"]'
    );
    const raw = $cand.toArray()
      .map(el => $.ui.fancytree.getNode(el))
      .filter(Boolean);

    const seen = new Set();
    const out = [];
    raw.forEach(n => {
      const key = n.key || n.getIndexHier?.() || n.title;
      const isPart = n.partsel || $(n.span).hasClass("fancytree-partsel");
      if (!isPart && key && !seen.has(key)) {
        seen.add(key);
        out.push(n);
      }
    });
    return out;
  } catch (e) {
    console.warn("[WBS] DOM fallback failed", e);
    return [];
  }
}

/** Fancytree 노드 → 경로 배열 */
function pathOfNodeFT(n){
  const out=[]; let cur=n;
  while (cur && !cur.isRoot()){
    out.unshift(cur.title || cur.key || cur.data?.text || "");
    cur = cur.parent;
  }
  return out;
}

/** provider(childrenByPath)로 미확장 자손까지 leaf dbId 수집 */
async function bfsCollectDescendantDbIds(provider, pathArr, visibleNode){
  // (1) 화면에 보이는 서브트리에서 leaf 수집
  const fromVisible = [];
  try {
    visibleNode?.visit?.((n) => {
      if (n !== visibleNode && !(n.hasChildren && n.hasChildren())) {
        const id = Number(n.dbId ?? n.data?.dbId);
        if (Number.isFinite(id)) fromVisible.push(id);
      }
    });
  } catch(_){}

  // (2) provider BFS (미확장 자손)
  const fromProvider = [];
  if (provider && typeof provider.childrenByPath === "function") {
    const queue = [ pathArr.slice() ];
    const seenKey = new Set();
    const SEP = "\u0001";

    while (queue.length) {
      const cur = queue.shift();
      const key = cur.join(SEP);
      if (seenKey.has(key)) continue;
      seenKey.add(key);

      let children = [];
      try { children = await provider.childrenByPath(cur); } catch(_) { children = []; }

      for (const ch of (children || [])) {
        const text = String(ch.text || ch.name || "").trim();
        if (!text) continue;
        const id = Number(ch.dbId ?? ch.data?.dbId);
        if (Number.isFinite(id)) fromProvider.push(id);
        else queue.push(cur.concat(text));
      }
    }
  }

  // 유니크 + 순서 유지(화면 → provider)
  const out = [];
  const s = new Set();
  for (const x of fromVisible.concat(fromProvider)) if (!s.has(x)) { s.add(x); out.push(x); }
  return out;
}



// ✅ 체크 노드 안전 수집(다중 전략)
const checkedNodes = getCheckedNodesFT();
if (!checkedNodes.length) {
  // 디버그 도움말
  console.warn("[WBS] No checked nodes via API/DOM fallback.");
  alert("WBS에서 '체크(V)'된 항목이 없습니다.\n(체크 후 다시 시도해 주세요)");
  return;
}

// 문서 순서 정렬: getIndexHier 기반 자연 정렬
checkedNodes.sort((a,b) => a.getIndexHier().localeCompare(b.getIndexHier(), undefined, { numeric:true }));

// 각 체크 노드 → 경로 → 자손 leaf dbId 수집
const orderedDbIds = [];
const pathByDbId = new Map();
const seen = new Set();

for (const node of checkedNodes){
  const path = pathOfNodeFT(node);
  const ids = await bfsCollectDescendantDbIds(provider, path, node);
  for (const id of ids){
    if (!seen.has(id)) {
      seen.add(id);
      orderedDbIds.push(id);
      pathByDbId.set(id, path.slice());
    }
  }
}




$('.fancytree-container#wbs-tree')
  .off('.dbgft2')
  .on('fancytreeselect.dbgft2 fancytreetogglecheckbox.dbgft2', (e, data)=>{
    console.log('[FT]', e.type, {title:data?.node?.title, selected:data?.node?.selected, partsel:data?.node?.partsel});
  });



(function(){
  const t=$.ui.fancytree.getTree('#wbs-tree');
  const a=t?t.getSelectedNodes(false).map(n=>({t:n.title, part:n.partsel})):[];
  console.log('API selected=',a);
  const dom=[...document.querySelectorAll('#wbs-tree .fancytree-node.fancytree-selected, #wbs-tree .fancytree-checkbox[aria-checked="true"]')]
    .map(el=>$.ui.fancytree.getNode(el))
    .filter(Boolean)
    .map(n=>({t:n.title, part:n.partsel}));
  console.log('DOM fallback=',dom);
})();

