// 태스크→상태별 dbId 집합 만들기
function buildStatusSetsFromTasks(tasks) {
  const S = { C:new Set(), T:new Set(), D:new Set(), TD:new Set() };
  (function walk(arr){
    (arr||[]).forEach(t=>{
      const raw = (t.status || t.selectedOption || "").toString().toUpperCase();
      const s = raw.startsWith("C") ? "C"
            : raw.startsWith("T") ? "T"
            : raw.startsWith("D") ? "D"
            : raw.startsWith("X") ? "TD"
            : raw; // 필요시 여기서 '시공/가설/철거' 매핑
      (t.linkedObjects||[]).forEach(o=>{
        if (s==="C") S.C.add(o.dbId);
        else if (s==="T") S.T.add(o.dbId);
        else if (s==="D") S.D.add(o.dbId);
        else if (s==="TD") S.TD.add(o.dbId);
      });
      if (t.children) walk(t.children);
    });
  })(tasks);
  return S;
}

// 특정 경로(path)의 집계 계산
function calcCountsForPath(provider, path, S) {
  let ids = [];
  try {
    ids = provider.getDbIdsForPath(path, { includeDescendants:true, allowUnbuilt:true }) || [];
  } catch {}
  if (!ids.length) return { total:0, c:0, t:0, d:0, td:0 };
  const set = new Set(ids);
  let c=0,t=0,d=0,td=0;
  for (const id of set) {
    if (S.C.has(id)) c++;
    if (S.T.has(id)) t++;
    if (S.D.has(id)) d++;
    if (S.TD.has(id)) td++;
  }
  return { total:set.size, c,t,d,td };
}

// ── (1) 폴백 카운트 맵을 "WBS 전체 경로"에 대해 미리 만들어둠 (트리 필요 없음)
async function buildFallbackMap(provider, { maxDepth=3, cap=6000 } = {}) {
  window.__FA_FALLBACK_BY_KEY = Object.create(null);
  const tasks = window.__SAVED_TASKS || [];
  const S = buildStatusSetsFromTasks(tasks);

  // 루트부터 BFS
  const roots = (await provider.roots().catch(()=>[])) || [];
  const q = roots.map(r => ({ path:[r.text], depth:0 }));
  let seen = 0;

  while (q.length && seen < cap) {
    const { path, depth } = q.shift();
    // 경로별 카운트 계산 → 키로 저장
    const key = (window.__WBS_DEBUG?.toKey ? window.__WBS_DEBUG.toKey(path) : toKey(path));
    window.__FA_FALLBACK_BY_KEY[key] = calcCountsForPath(provider, path, S);

    // 자식 큐잉
    let kids = [];
    try { kids = await provider.childrenByPath(path) || []; } catch {}
    seen += kids.length;

    if (depth < maxDepth) {
      for (const ch of kids) q.push({ path: (ch.__path || [...path, ch.text]), depth: depth+1 });
    }
  }
  console.log("[FA] fallback map ready (keys =", Object.keys(window.__FA_FALLBACK_BY_KEY).length, ")");
}



// ── (2) 매트릭스 값이 0일 땐 폴백 맵을 돌려주는 얇은 브릿지
function patchGetCountsBridge() {
  const D = window.__WBS_DEBUG;
  if (!D?.getCounts) return;
  if (D.__patchedForFallback) return;

  const orig = D.getCounts.bind(D);
  D.__origGetCounts = orig;

  D.getCounts = function(k) {
    const r = orig(k) || {};
    const hasReal = ((r.c|0)+(r.t|0)+(r.d|0)+(r.td|0)) > 0;
    if (hasReal) return r;                           // 매트릭스 준비됨 → 그대로
    const fb = window.__FA_FALLBACK_BY_KEY?.[k];     // 준비 전 → 폴백
    if (fb) {
      const total = Math.max((r.total|0), (fb.total|0));
      return { total, c:fb.c|0, t:fb.t|0, d:fb.d|0, td:fb.td|0 };
    }
    return r;
  };

  D.__patchedForFallback = true;
  console.log("[FA] getCounts bridged");
}




// ① 폴백 키가 만들어졌는지
Object.keys(window.__FA_FALLBACK_BY_KEY||{}).length

// ② 임의 루트 키의 폴백 값이 존재하는지
const D = window.__WBS_DEBUG;
const k = D?.toKey ? D.toKey(["구조벽"]) : toKey(["구조벽"]);
window.__FA_FALLBACK_BY_KEY?.[k]