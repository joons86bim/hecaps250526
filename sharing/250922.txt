// === helpers (파일 상단 어딘가에 추가) ===
function pathOfNodeFT(n){
  const out=[]; let cur=n;
  while (cur && !cur.isRoot()){
    out.unshift(cur.title || cur.key || cur.data?.text || "");
    cur = cur.parent;
  }
  return out;
}

async function bfsCollectDescendantDbIds(provider, pathArr, visibleNode){
  const fromVisible = [];
  try {
    visibleNode.visit(n=>{
      if (n !== visibleNode && !(n.hasChildren && n.hasChildren())) {
        const id = Number(n.data?.dbId ?? n.dbId);
        if (Number.isFinite(id)) fromVisible.push(id);
      }
    });
  } catch(_){}

  const out = [...fromVisible];
  const seen = new Set(out);

  if (provider?.childrenByPath){
    const q = [ pathArr.slice() ];
    const seenKey = new Set();
    const keyOf = a => a.join("\u0001");
    while(q.length){
      const cur = q.shift();
      const k = keyOf(cur);
      if (seenKey.has(k)) continue;
      seenKey.add(k);

      let children = [];
      try { children = await provider.childrenByPath(cur); } catch(_) { children = []; }

      for (const ch of (children || [])){
        const nm = String(ch.text || ch.name || "").trim();
        const id = Number(ch.dbId ?? ch.data?.dbId);
        if (Number.isFinite(id)){
          if (!seen.has(id)){ seen.add(id); out.push(id); }
        } else if (nm) {
          q.push(cur.concat(nm));
        }
      }
    }
  }
  return out;
}




// [데이터연결]
$("#btn-link").off("click").on("click", async function () {
  const taskTree = $.ui.fancytree.getTree("#treegrid");
  const selectedTaskNode = taskTree.getActiveNode();
  if (!selectedTaskNode) return alert("Task를 선택하세요!");
  if (selectedTaskNode.hasChildren && selectedTaskNode.hasChildren()) {
    alert("하위 작업이 있는 Task에는 연결할 수 없습니다.\n 최하위 Task를 선택해 주세요.");
    return;
  }

  const urn = window.CURRENT_MODEL_URN;
  const provider = window.__WBS_PROVIDER; // 있으면 BFS로 미확장 자손까지
  const catSel = normalizeTaskCategory(selectedTaskNode.data?.selectedOption); // "C"|"T"|"D"
  const catLabel = catSel === "C" ? "시공" : (catSel === "T" ? "가설" : "철거");

  // ✅ Fancytree에서 정확히 체크된 노드만 수집 (partsel 제외)
  const wbsTree = $.ui.fancytree.getTree("#wbs-tree");
  if (!wbsTree) { alert("WBS 트리를 찾을 수 없습니다(#wbs-tree)."); return; }

  let checkedNodes = wbsTree.getSelectedNodes(false) // topOnly=false
                     .filter(n => !n.partsel);        // 부분선택 제외

  if (!checkedNodes.length) return alert("WBS에서 '체크(V)'된 항목이 없습니다.");

  // 문서 순서 정렬
  checkedNodes.sort((a,b) => a.getIndexHier().localeCompare(b.getIndexHier(), undefined, { numeric:true }));

  // 각 체크 노드 → 경로 계산 → 자손 leaf dbId 모으기(미확장도 provider BFS로)
  const orderedDbIds = [];
  const pathByDbId = new Map();
  const seen = new Set();

  for (const node of checkedNodes){
    const path = pathOfNodeFT(node);
    const ids = await bfsCollectDescendantDbIds(provider, path, node);
    for (const id of ids){
      if (!seen.has(id)) {
        seen.add(id);
        orderedDbIds.push(id);
        pathByDbId.set(id, path.slice());
      }
    }
  }

  if (!orderedDbIds.length) return alert("체크된 항목에서 연결 가능한 객체(dbId)를 찾지 못했습니다.");

  // ElementId 프리페치
  try { await ensureElementIdIndexForDbIds(orderedDbIds); } catch {}

  // 저장용 오브젝트(경로라벨 보존: "A - B - C - [ElementId|dbId]")
  const toLink = orderedDbIds.map((d) => {
    const p = pathByDbId.get(d) || [];
    const el = getElementIdFor(urn, d);
    const bracket = `[${el || d}]`;
    const pathLabel = p.length ? (p.join(" - ") + " - " + bracket) : bracket;
    return { urn, dbId: d, elementId: el || null, text: pathLabel };
  });

  // ==== 점유/충돌 처리 (기존 로직 그대로) ====
  await (async () => {
    const occupancy = new Map();
    taskTree.getRootNode().visit(n => {
      const cat = normalizeTaskCategory(n.data?.selectedOption);
      if (!cat) return;
      (n.data?.linkedObjects || []).forEach(o => {
        const key = `${o.urn || urn}:${o.dbId}`;
        const slot = occupancy.get(key) || { C: null, T: null, D: null };
        if (cat === "C" && !slot.C) slot.C = n;
        if (cat === "T" && !slot.T) slot.T = n;
        if (cat === "D" && !slot.D) slot.D = n;
        occupancy.set(key, slot);
      });
    });

    const allowed = [];
    const conflictsForC = [];
    const conflictsC = [];
    const conflictsSame = [];

    toLink.forEach(obj => {
      const key = `${obj.urn}:${obj.dbId}`;
      const slot = occupancy.get(key) || { C: null, T: null, D: null };

      if (catSel === "C") {
        if (!slot.C && !slot.T && !slot.D) allowed.push(obj);
        else conflictsForC.push({ obj, slot });
      } else if (catSel === "T") {
        if (slot.C) conflictsC.push({ obj, slot });
        else if (slot.T) conflictsSame.push({ obj, slot });
        else allowed.push(obj);
      } else if (catSel === "D") {
        if (slot.C) conflictsC.push({ obj, slot });
        else if (slot.D) conflictsSame.push({ obj, slot });
        else allowed.push(obj);
      }
    });

    function unlinkFromNode(node, obj) {
      if (!node) return;
      node.data.linkedObjects = (node.data.linkedObjects || []).filter(
        o => !(String(o.urn || urn) === String(obj.urn) && Number(o.dbId) === Number(obj.dbId))
      );
      node.render && node.render();
    }

    if (catSel === "C" && conflictsForC.length) {
      const res = prompt([
        `선택한 객체 중 ${conflictsForC.length}개는 이미 다른 Task에 연결되어 있습니다.`,
        `규칙상 '시공'은 단독 연결만 가능합니다.`,
        ``,
        `1. 기존 연결 해제 후 이 Task(시공)로 새로 연결`,
        `2. 이미 연결된 객체만 제외하고 진행`,
        `3. 취소`,
        ``,
        `번호를 입력하세요 (1/2/3)`
      ].join("\n"), "2");
      if (res === "3" || res == null) return;
      if (res === "1") {
        conflictsForC.forEach(({ obj, slot }) => {
          unlinkFromNode(slot.C, obj);
          unlinkFromNode(slot.T, obj);
          unlinkFromNode(slot.D, obj);
          allowed.push(obj);
        });
      }
    }

    if ((catSel === "T" || catSel === "D") && conflictsC.length) {
      const res = prompt([
        `다음 객체는 '시공'에 이미 연결되어 있어 ${catLabel}과(와) 병행할 수 없습니다.`,
        ``,
        `1. 시공 연결 해제 후 이 Task(${catLabel})로 새로 연결`,
        `2. 이미 연결된 객체만 제외하고 진행`,
        `3. 취소`,
        ``,
        `번호를 입력하세요 (1/2/3)`
      ].join("\n"), "2");
      if (res === "3" || res == null) return;
      if (res === "1") {
        conflictsC.forEach(({ obj, slot }) => { unlinkFromNode(slot.C, obj); allowed.push(obj); });
      }
    }

    if ((catSel === "T" || catSel === "D") && conflictsSame.length) {
      const label = catLabel;
      const res = prompt([
        `다음 객체는 이미 '${label}'에 연결되어 있습니다.`,
        ``,
        `1. 기존 '${label}' 연결을 이 Task로 교체 (해당 카테고리만 교체)`,
        `2. 이미 연결된 객체만 제외하고 진행`,
        `3. 취소`,
        ``,
        `번호를 입력하세요 (1/2/3)`
      ].join("\n"), "2");
      if (res === "3" || res == null) return;
      if (res === "1") {
        conflictsSame.forEach(({ obj, slot }) => {
          if (catSel === "T") unlinkFromNode(slot.T, obj);
          if (catSel === "D") unlinkFromNode(slot.D, obj);
          allowed.push(obj);
        });
      }
    }

    if (allowed.length > 0) {
      const existing = selectedTaskNode.data.linkedObjects || [];
      const merged = [];
      const seenKey = new Set();
      const pushUniq = (o) => { const k = o.urn + ":" + o.dbId; if (!seenKey.has(k)) { seenKey.add(k); merged.push(o); } };
      allowed.forEach(pushUniq);  // WBS 순서 우선
      existing.forEach(pushUniq); // 기존 뒤에
      selectedTaskNode.data.linkedObjects = merged;
    }

    const withWbsGate = (fn)=>{
      const prev = window.__ALLOW_WBS_UPDATE;
      window.__ALLOW_WBS_UPDATE = true;
      try { return fn(); } finally { window.__ALLOW_WBS_UPDATE = prev; }
    };

    withWbsGate(() => {
      if (window.requestTaskRecalcAndFlush) window.requestTaskRecalcAndFlush(); 
      else if (window.requestTaskTreeFlush) window.requestTaskTreeFlush();
      try { window.gantt?.renderFromTrees(window.taskTree, window.wbsTree); } catch(_) {}
    });

    try { await notifyCoverageDirtyAndRepaint(); } catch {}
  })();

  try { window.__WBS_MARK_TASKS_CHANGED?.(); } catch {}
});



(function(){
  const t = $.ui.fancytree.getTree("#wbs-tree");
  const nodes = t ? t.getSelectedNodes(false).filter(n=>!n.partsel) : [];
  console.log('[WBS Selected]', nodes.map(n => ({title:n.title, idx:n.getIndexHier()})));
})();