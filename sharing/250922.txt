// /wwwroot/js/sidebar/task-wbs/wbs-tree.js
import { ensureEyeButton, installWbsVisibilityDelegate } from "./ui/wbs-visibility.js";
import { applyHighlightForSubtreeUI } from "./ui/wbs-highlight.js";
import { activateFixedPaint, refreshFixedPaint, requestDebouncedRepaint, paintSubtreeNow } from "./ui/wbs-fixed-paint.js";

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ê³µí†µ ìœ í‹¸/ìƒíƒœ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

const rIC = typeof requestIdleCallback === "function"
  ? requestIdleCallback
  : (fn)=>setTimeout(()=>fn({ timeRemaining:()=>5 }),0);

// ì²´í¬ í”„ë¦¬í”½ìŠ¤ ê·œì¹™(ì „ì—­ ê³µìœ : path prefix on/off)
const CHECK_RULES = (window.__WBS_CHECK_RULES = window.__WBS_CHECK_RULES || { on:new Set(), off:new Set() });
const PSEP = "Â¦";
const pkey = (path) => (path||[]).join(PSEP);
const startsWithKey = (full, key) => (full===key || full.startsWith(key + PSEP));

function registerAutoCheck(pathArr, turnOn){
  const k = pkey(pathArr);
  if (turnOn){
    Array.from(CHECK_RULES.off).forEach(x => { if (startsWithKey(x,k) || startsWithKey(k,x)) CHECK_RULES.off.delete(x); });
    Array.from(CHECK_RULES.on).forEach(x => { if (startsWithKey(x,k)) CHECK_RULES.on.delete(x); });
    CHECK_RULES.on.add(k);
  }else{
    Array.from(CHECK_RULES.on).forEach(x => { if (startsWithKey(x,k) || startsWithKey(k,x)) CHECK_RULES.on.delete(x); });
    CHECK_RULES.off.add(k);
  }
}
function shouldBeChecked(pathArr){
  const k = pkey(pathArr);
  for (const off of CHECK_RULES.off) if (startsWithKey(k,off)) return false;
  for (const on  of CHECK_RULES.on ) if (startsWithKey(k,on )) return true;
  return null; // ê·œì¹™ ì—†ìŒ
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ê²½ë¡œ/ë…¸ë“œ ë„ìš°ë¯¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

export function pathOfNodeFT(n){
  const out = [];
  let cur = n;
  while (cur && !cur.isRoot()){
    out.unshift(cur.title || cur.key || cur.data?.text || "");
    cur = cur.parent;
  }
  return out;
}

function ensureCountBadge(ftNode, provider){
  const span = ftNode?.span; if (!span) return;
  const titleEl = span.querySelector('.fancytree-title') || span;
  let badge = span.querySelector('.count-badge');
  if (!badge){
    badge = document.createElement('span');
    badge.className = 'count-badge';
    badge.style.marginLeft = '6px';
    badge.style.opacity = '0.8';
    titleEl.after(badge);
  }

  const isLeaf = Number.isFinite(Number(ftNode.data?.dbId));
  if (isLeaf){
    badge.textContent = '';
    badge.style.display = 'none';
    return;
  }

  let cnt = (typeof ftNode.data?.leafCount === 'number') ? ftNode.data.leafCount : undefined;
  if (cnt == null && provider && typeof provider.countAt === 'function'){
    try { cnt = provider.countAt(pathOfNodeFT(ftNode)); } catch {}
  }

  badge.textContent = (typeof cnt === 'number') ? String(cnt) : 'â€¦';
  badge.style.display = '';
}

function ensureDecor(ftNode, provider){
  try { ensureCountBadge(ftNode, provider); } catch {}
  try { ensureEyeButton(ftNode); } catch {}
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ë°ì´í„° ë§¤í¼(Provider â†’ Fancytree) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

function mapItemsToFt(items, parentPath = []){
  if (!Array.isArray(items)) return [];
  const out = [];
  for (const item of items){
    if (item?._isBucket && Array.isArray(item.__bucket)){
      out.push(...mapItemsToFt(item.__bucket, parentPath)); // ë²„í‚· í‰íƒ„í™”
      continue;
    }
    const label = String(item?.text ?? "").trim();
    const dbId  = Number(item?.dbId);
    const isLeaf = Number.isFinite(dbId);

    const path = parentPath.concat([label]);
    const want = shouldBeChecked(path);

    out.push({
      title: label || "(ë¹ˆ í•­ëª©)",
      key: pkey(path),              // ê²½ë¡œ ê¸°ë°˜ ê³ ìœ í‚¤
      folder: !isLeaf,
      lazy: !isLeaf,                // ë¹„-ë¦¬í”„ë©´ í™•ìž¥ì‹œ ë¡œë“œ
      selected: (want === true) ? true : (want === false ? false : !!item?.selected),
      data: {
        dbId: isLeaf ? dbId : null,
        path
      }
    });
  }
  return out;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ FancyTree ì°¾ê¸°/ìˆ˜ì§‘ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

export function findWbsTree(){
  if (!window.$ || !$.ui || !$.ui.fancytree) return null;
  const all = Array.from(document.querySelectorAll('.fancytree-container'))
    .map(el => $.ui.fancytree.getTree(el))
    .filter(Boolean);

  const taskTree = $.ui.fancytree.getTree('#treegrid');
  const cand = all.filter(t => t !== taskTree);

  const withCk = cand.filter(t => !!t.options?.checkbox);
  return withCk[0] || cand[0] || null;
}

export function getCheckedNodesFT() {
  const tree = findWbsTree();
  if (!tree) { console.warn('[WBS] findWbsTree() = null'); return []; }

  // 1) ê³µì‹ API: ë¶€ë¶„ì„ íƒ í¬í•¨(í•„í„° ì œê±°)
  try {
    const nodes = tree.getSelectedNodes(false); // partselë„ í—ˆìš©
    if (nodes.length) return uniqNodes(nodes);
  } catch(_) {}

  // 2) ì „ì²´ ë°©ë¬¸: selected===true ì´ë©´ ìˆ˜ì§‘ (partsel ì—¬ë¶€ ë¬´ì‹œ)
  try {
    const found = [];
    tree.getRootNode()?.visit((n) => {
      if (n.selected) found.push(n);
    });
    if (found.length) return uniqNodes(found);
  } catch(_) {}

  // 3) DOM í´ë°± (ë¶€ë¶„ì„ íƒ í—ˆìš©)
  try {
    const $cont = tree.$div || $(tree.$div);
    const $cand = $cont.find(
      '.fancytree-checkbox[aria-checked="true"], ' +
      '.fancytree-node.fancytree-selected, ' +
      '.fancytree-title.fancytree-selected'
    );
    const raw = $cand.toArray()
      .map(el => $.ui.fancytree.getNode(el))
      .filter(Boolean);
    if (raw.length) return uniqNodes(raw);
  } catch (e) {
    console.warn("[WBS] DOM fallback failed", e);
  }
  return [];

  function uniqNodes(arr){
    const out = [];
    const seen = new Set();
    arr.forEach(n => {
      const key = n.key || n.getIndexHier?.() || n.title || n.data?.path?.join?.("Â¦");
      if (key && !seen.has(key)) { seen.add(key); out.push(n); }
    });
    return out;
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Provider BFS (ê³µìš©) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

export async function bfsCollectDescendantDbIds(provider, pathArr, visibleNode){
  // 1) í™”ë©´ í‘œì‹œ ì„œë¸ŒíŠ¸ë¦¬ì—ì„œ leaf ìˆ˜ì§‘
  const fromVisible = [];
  try {
    visibleNode?.visit?.((n) => {
      if (n !== visibleNode && !(n.hasChildren && n.hasChildren())) {
        const id = Number(n.data?.dbId ?? n.dbId);
        if (Number.isFinite(id)) fromVisible.push(id);
      }
    });
  } catch(_){}

  // 2) provider BFS
  const fromProvider = [];
  if (provider && typeof provider.childrenByPath === "function") {
    const queue = [ pathArr.slice() ];
    const seenKey = new Set();
    const SEP = "\u0001";

    while (queue.length) {
      const cur = queue.shift();
      const key = cur.join(SEP);
      if (seenKey.has(key)) continue;
      seenKey.add(key);

      let children = [];
      try { children = await provider.childrenByPath(cur); } catch{ children = []; }

      for (const ch of (children || [])) {
        const text = String(ch.text || ch.name || "").trim();
        if (!text) continue;
        const id = Number(ch.dbId ?? ch.data?.dbId);
        if (Number.isFinite(id)) fromProvider.push(id);
        else queue.push(cur.concat(text));
      }
    }
  }

  // (í™”ë©´ â†’ provider) ìˆœì„œ ìœ ì§€ ìœ ë‹ˆí¬
  const out = [];
  const s = new Set();
  for (const x of fromVisible.concat(fromProvider)) if (!s.has(x)) { s.add(x); out.push(x); }
  return out;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ë©”ì¸: WBS íŒ¨ë„ ì´ˆê¸°í™”(Fancytreeë§Œ) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

export async function initWbsPanel(input){
  // CSS: í™•ìž¥ ê¹œë¹¡ìž„ ì–µì œ(ì˜µì…˜)
  if (!document.getElementById('wbs-expanding-css')){
    const st = document.createElement('style');
    st.id = 'wbs-expanding-css';
    st.textContent = `
      #wbs-tree .count-badge{ font-size: 12px; padding:0 4px; border-radius: 8px; background:rgba(0,0,0,.06); }
    `;
    document.head.appendChild(st);
  }

  // ì»¨í…Œì´ë„ˆ í™•ë³´(#wbs-treeê°€ í‘œì¤€)
  let cont = document.querySelector('#wbs-tree');
  if (!cont){
    const wrap = document.getElementById('wbs-group-content') || document.body;
    cont = document.createElement('div');
    cont.id = 'wbs-tree';
    wrap.appendChild(cont);
  }

  // Provider ê°ì‹¸ê¸°(ì´ˆê¸° ì„ íƒ ìƒíƒœ ì£¼ìž…)
  const rawProvider = (input && input.__provider) ? input : null;
  const usingProvider = !!rawProvider;
  let provider = rawProvider;

  if (usingProvider){
    const coerceCheckOnData = (items, parentPath=[]) => {
      if (!Array.isArray(items)) return items;
      return items.map(item => {
        if (item?._isBucket && Array.isArray(item.__bucket)){
          item.__bucket = coerceCheckOnData(item.__bucket, parentPath);
          return item;
        }
        const label = item?.text ?? "";
        const path = parentPath.concat([label]);
        const want = shouldBeChecked(path);
        if (want !== null) item.selected = !!want;
        return item;
      });
    };
    provider = {
      __provider: true,
      async roots(){
        const items = await rawProvider.roots();
        return coerceCheckOnData(items, []);
      },
      async childrenByPath(path){
        const items = await rawProvider.childrenByPath(path);
        return coerceCheckOnData(items, path);
      },
      countAt: (...a)=>rawProvider.countAt?.(...a),
      getDbIdsForPath: (...a)=>rawProvider.getDbIdsForPath?.(...a),
      ensurePathMapForDbIds: (...a)=>rawProvider.ensurePathMapForDbIds?.(...a)
    };
    window.__WBS_PROVIDER = provider;
  }

  // ì´ë¯¸ ë§Œë“¤ì–´ì§„ WBS Fancytreeê°€ ìžˆìœ¼ë©´ ìž¬ì‚¬ìš©
  let tree = $.ui.fancytree.getTree('#wbs-tree');
  if (!tree){
    $('#wbs-tree').fancytree({
      checkbox: true,
      selectMode: 3,
      clickFolderMode: 3, // í´ë¦­ ì‹œ í™•ìž¥/ì¶•ì†Œ
      titlesTabbable: true,
      debugLevel: 0
    });
    tree = $.ui.fancytree.getTree('#wbs-tree');
  }

  // ë£¨íŠ¸ ë°ì´í„° ì£¼ìž…
  if (usingProvider){
    try {
      const roots = await provider.roots();
      await tree.reload(mapItemsToFt(roots, []));
    } catch(e) {
      console.warn('[WBS] provider.roots() ì‹¤íŒ¨:', e);
      await tree.reload([]);
    }
  }else if (Array.isArray(input)){
    await tree.reload(mapItemsToFt(input, []));
  }

  // í•¸ë“¤ëŸ¬ ë°”ì¸ë”©(í•œ ë²ˆë§Œ)
  const $div = tree.$div;
  $div.off('.wbs');

  if (usingProvider){
    // Lazy load
    $div.on('fancytreelazyLoad.wbs', async (e, data)=>{
      const node = data.node;
      const path = node.data?.path || pathOfNodeFT(node);
      data.result = provider.childrenByPath(path).then(items => mapItemsToFt(items, path));
    });
  }

  // Children loaded â†’ ê·œì¹™/í•˜ì´ë¼ì´íŠ¸/ê³ ì •ì¹ 
  $div.on('fancytreeloadChildren.wbs', (e, data)=>{
    try {
      (data.node.children || []).forEach(ch => {
        const want = shouldBeChecked(ch.data?.path || pathOfNodeFT(ch));
        if (want === true) ch.setSelected(true);
        else if (want === false) ch.setSelected(false);
      });
      paintSubtreeNow?.(data.node);
    } catch {}
  });

  // Render â†’ ë°ì½”ë ˆì´ì…˜/í•˜ì´ë¼ì´íŠ¸
  $div.on('fancytreerenderNode.wbs', (e, data)=>{
    const n = data.node;
    requestAnimationFrame(()=>{
      try { ensureDecor(n, provider); } catch {}
      try {
        const map = window.__WBS_CATMAP;
        if (!window.__WBS_FIXED_MODE && map) applyHighlightForSubtreeUI(n, map);
      } catch {}
    });
  });

  // Expanded â†’ ê³ ì •ìƒ‰ì¹ /í•˜ì´ë¼ì´íŠ¸ ê°±ì‹ 
  $div.on('fancytreeexpand.wbs', async (e, data)=>{
    try { paintSubtreeNow?.(data.node); } catch {}
    try { await refreshFixedPaint?.({ repaint:true }); } catch {}
    try {
      const map = window.__WBS_CATMAP;
      if (!window.__WBS_FIXED_MODE && map) applyHighlightForSubtreeUI(data.node, map);
    } catch {}
  });

  // Select(ì²´í¬) â†’ ê·œì¹™ ê°±ì‹  + ìžì‹ ì „íŒŒ
  $div.on('fancytreeselect.wbs', (e, data)=>{
    const n = data.node;
    const sel = !!n.selected;
    const path = n.data?.path || pathOfNodeFT(n);
    registerAutoCheck(path, sel);
    // í‘œì‹œëœ ìžì‹ì—ëŠ” ì¦‰ì‹œ ì „íŒŒ(ë¯¸í‘œì‹œëŠ” ê·œì¹™ì— ì˜í•´ lazy-load ì‹œ ì ìš©)
    try { if (n.hasChildren()) n.visit(ch => { if (ch !== n && !ch.partsel) ch.setSelected(sel); }); } catch {}
  });

  // ì²« íŽ˜ì¸íŠ¸ + ê³ ì • ì¹ 
  requestAnimationFrame(()=>{ try { activateFixedPaint(); } catch {} });

  // ê°€ì‹œì„± í† ê¸€ ìœ„ìž„
  installWbsVisibilityDelegate();

  // ì „ì—­ ë…¸ì¶œ(ë‹¤ë¥¸ ëª¨ë“ˆì—ì„œ ì‚¬ìš©)
  window.wbsTree = tree;

  // DOM ì¶”ê°€ ë³€ê²½(ë³´ìˆ˜)
  try {
    const obs = new MutationObserver(()=> requestDebouncedRepaint?.(32));
    obs.observe(tree.$div.get(0), { childList:true, subtree:true });
  } catch {}
}


// /wwwroot/js/sidebar/task-wbs/task-buttons.js
import { normalizeTaskCategory, enforceCategoryInheritance } from "./core/categories.js";
import { aggregateTaskFields } from "./logic/task-aggregate.js";
import { scheduleWbsRepaint } from "./ui/wbs-highlight.js";
import { showCurrentTaskModal } from "./ui/current-task-modal.js";
import { notifyCoverageDirtyAndRepaint } from "./ui/wbs-fixed-paint.js";
import { ensureElementIdIndexForDbIds, getElementIdFor, formatObjectLabel } from "./core/element-id.js";

// â˜… WBS(íŒ¬ì‹œíŠ¸ë¦¬) ê³µìš© í—¬í¼: ì¤‘ë³µ ì œê±°(ì´ ëª¨ë“ˆì—ì„œëŠ” ì •ì˜í•˜ì§€ ì•ŠìŒ)
import { findWbsTree } from "./wbs-tree.js";

/* =============================================================================
   Optional WbsStore (ìžˆìœ¼ë©´ ì‚¬ìš©, ì—†ì–´ë„ ë™ìž‘)
============================================================================= */
let __WBS_STORE__ = (typeof window !== "undefined" && window.__WBS_STORE__) || null;
function ensureWbsStore() {
  if (__WBS_STORE__) return Promise.resolve(__WBS_STORE__);
  return import("./core/wbs-store.js").then(mod => { __WBS_STORE__ = mod; return mod; }).catch(()=>null);
}

/* =============================================================================
   ìƒíƒœ ë°˜ì˜/íŽ˜ì¸íŠ¸ ìœ í‹¸
============================================================================= */
function notifyWbsStatusRefresh(){
  try { window.__WBS_MARK_TASKS_CHANGED?.(); } catch {}
}
async function runWbsHighlightBatch(cb){
  const prev = window.__WBS_PAINT_LOCK === true;
  window.__WBS_PAINT_LOCK = true;
  try { await cb(); }
  finally {
    window.__WBS_PAINT_LOCK = prev;
    requestAnimationFrame(()=>{ try{ window.updateWBSHighlight?.(); } catch{} });
  }
}

/* =============================================================================
   ì™¸ë¶€ ì €ìž¥ ìŠ¤ëƒ…ìƒ·
============================================================================= */
export function setSavedTaskData(data) {
  window.savedTaskData = JSON.parse(JSON.stringify(data ?? []));
}

/* =============================================================================
   ì´ˆê¸°í™” ë³¸ì²´
============================================================================= */
export function initTaskListButtons() {
  window.__ALLOW_WBS_UPDATE = window.__ALLOW_WBS_UPDATE ?? false;

  // WbsStore ì´ˆê¸°í™” (ê°€ëŠ¥í•  ë•Œë§Œ)
  ensureWbsStore().then((mod) => {
    if (!mod) return;
    try {
      // âœ… ê³µìš© í—¬í¼ ì‚¬ìš©: ì‹¤ì œ ì²´í¬ë°•ìŠ¤ WBS íŠ¸ë¦¬ ì¸ìŠ¤í„´ìŠ¤
      const wbsFT = findWbsTree();
      mod.initWbsStore?.({ tree: wbsFT, provider: window.__WBS_PROVIDER, eager: "auto" });

      // âœ… ì „ì—­ ë…¸ì¶œ(ì½˜ì†”/ë‹¤ë¥¸ ëª¨ë“ˆì—ì„œ ì‚¬ìš© ê°€ëŠ¥)
      window.__WBS_STORE__ = mod;

      // âœ… provider êµì²´ ì‹œ ì¸ë±ìŠ¤ ìž¬êµ¬ì¶•
      window.__SET_WBS_PROVIDER__ = (p) => {
        try { mod.setProvider?.(p); mod.refreshWbsStore?.(); } catch(_) {}
      };
    } catch(_) {}
  });

  function withWbsGate(fn){
    const prev = window.__ALLOW_WBS_UPDATE;
    window.__ALLOW_WBS_UPDATE = true;
    try { return fn(); }
    finally { window.__ALLOW_WBS_UPDATE = prev; }
  }

  function flush(recalc = false) {
    if (recalc && window.requestTaskRecalcAndFlush) {
      window.requestTaskRecalcAndFlush();
    } else if (window.requestTaskTreeFlush) {
      window.requestTaskTreeFlush();
    } else {
      const tree = $.ui.fancytree.getTree("#treegrid");
      tree.render(true, true);
    }
    if (!window.__WBS_PAINT_LOCK) scheduleWbsRepaint();
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì¶”ê°€ â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  $("#btn-add").off("click").on("click", function () {
    const tree = $.ui.fancytree.getTree("#treegrid");
    const sel = tree.getActiveNode();
    const parentNode = sel || null;
    const baseCat = (parentNode?.data?.selectedOption) || "ì‹œê³µ";
    const no = generateNo(parentNode);
    const nodeData = {
      no,
      selectOptions: ["ì‹œê³µ", "ê°€ì„¤", "ì² ê±°"],
      selectedOption: baseCat,
      title: "ìƒˆ ìž‘ì—…",
      start: "",
      end: "",
      linkedObjects: []
    };
    if (parentNode) {
      if (Array.isArray(parentNode.data?.linkedObjects) && parentNode.data.linkedObjects.length) {
        parentNode.data.linkedObjects = [];
        parentNode.render && parentNode.render();
      }
      parentNode.addChildren(nodeData);
      parentNode.setExpanded(true);
      parentNode.data.start = "";
      parentNode.data.end = "";
      parentNode.render && parentNode.render();
    } else {
      tree.getRootNode().addChildren(nodeData);
    }
    enforceCategoryInheritance(tree);
    flush(true);
  });

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì‚­ì œ â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  $("#btn-delete").off("click").on("click", function(){
    const tree = $.ui.fancytree.getTree("#treegrid");
    const sel = tree.getActiveNode();
    if (sel && !sel.isRoot()) {
      sel.remove();
      flush(true);
    }
  });

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ ê°ì²´ì„ íƒ â†’ 3D viewer select â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  $("#btn-select").off("click").on("click", function() {
    const taskTree = $.ui.fancytree.getTree("#treegrid");
    const selected = taskTree.getActiveNode();
    if (!selected) return alert("Taskë¥¼ ì„ íƒí•˜ì„¸ìš”!");

    const objects = aggregateTaskFields(selected).objects;
    if (!objects || objects.length === 0) return alert("ì´ Task(ë° í•˜ìœ„ Task)ì— ì—°ê²°ëœ ê°ì²´ê°€ ì—†ìŠµë‹ˆë‹¤.");

    const byUrn = {};
    objects.forEach(obj => {
      if (!byUrn[obj.urn]) byUrn[obj.urn] = [];
      byUrn[obj.urn].push(obj.dbId);
    });
    Object.entries(byUrn).forEach(([urn, dbIds]) => {
      if (urn === window.CURRENT_MODEL_URN && window.viewer) {
        window.viewer.select(dbIds);
      }
    });
  });

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì—…ë°ì´íŠ¸(ì €ìž¥) â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  $("#btn-update").off("click").on("click", async function () {
    const safeUrnVal = window.CURRENT_MODEL_SAFE_URN;
    const url = `/api/tasks?urn=${safeUrnVal}`;
    const currentTaskData = getCurrentTaskDataFromTree();
    const current = JSON.stringify(currentTaskData ?? []);
    const saved   = JSON.stringify(window.savedTaskData ?? []);

    if (!window.savedTaskData || (Array.isArray(window.savedTaskData) && window.savedTaskData.length === 0 && currentTaskData.length > 0)) {
      // ìµœì´ˆ ì €ìž¥ í—ˆìš©
    } else if (current === saved) {
      alert("ìˆ˜ì •ëœ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
      return;
    }

    try {
      const resp = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        credentials: "include",
        body: JSON.stringify(currentTaskData),
      });
      if (resp.ok) {
        alert("Task ë°ì´í„°ê°€ ì €ìž¥ë˜ì—ˆìŠµë‹ˆë‹¤!");
        window.savedTaskData = JSON.parse(JSON.stringify(currentTaskData));
      } else {
        alert("Task ë°ì´í„° ì €ìž¥ ì‹¤íŒ¨!");
      }
    } catch (err) {
      alert("ì €ìž¥ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: " + err.message);
    }
  });

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ ë°ì´í„°ì—°ê²°: ì²´í¬ëœ WBS â†’ ê²½ë¡œ â†’ leaf dbId ìˆ˜ì§‘ â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  $("#btn-link").off("click").on("click", async function () {
    const taskTree = $.ui.fancytree.getTree("#treegrid");
    const selectedTaskNode = taskTree.getActiveNode();
    if (!selectedTaskNode) return alert("Taskë¥¼ ì„ íƒí•˜ì„¸ìš”!");
    if (selectedTaskNode.hasChildren && selectedTaskNode.hasChildren()) {
      alert("í•˜ìœ„ ìž‘ì—…ì´ ìžˆëŠ” Taskì—ëŠ” ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n ìµœí•˜ìœ„ Taskë¥¼ ì„ íƒí•´ ì£¼ì„¸ìš”.");
      return;
    }

    const urn = window.CURRENT_MODEL_URN;
    const provider = window.__WBS_PROVIDER;
    const catSel = normalizeTaskCategory(selectedTaskNode.data?.selectedOption); // "C"|"T"|"D"
    const catLabel = catSel === "C" ? "ì‹œê³µ" : (catSel === "T" ? "ê°€ì„¤" : "ì² ê±°");

    // âœ… Store ìš°ì„ : ë¶€ë¶„ì„ íƒ(partsel)ë„ í—ˆìš©í•´ì„œ ê²½ë¡œâ†’dbIdë¥¼ ì¸ë±ìŠ¤ì—ì„œ ë°”ë¡œ íšŒìˆ˜
    let orderedDbIds = [];
    let pathByDbId = new Map();

    const store = window.__WBS_STORE__;
    if (store?.getOrderedDbIdsFromSelection) {
      const { orderedDbIds: ids, pathByDbId: map } =
        await store.getOrderedDbIdsFromSelection({ includePartsel: true });
      orderedDbIds = ids;
      pathByDbId   = map;
    } else {
      // ðŸ” í´ë°±(ì´ì „ ë°©ì‹): ì²´í¬ëœ ë…¸ë“œ ì§ì ‘ ì½ì–´ì„œ provider/ê°€ì‹œ íŠ¸ë¦¬ì—ì„œ ìˆ˜ì§‘
      const _wbs = findWbsTree();
      if (!_wbs) { alert("WBS íŠ¸ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤(ì²´í¬ë°•ìŠ¤ê°€ ìžˆëŠ” íŠ¸ë¦¬)."); return; }

      const checkedNodes = getCheckedNodesFT(); // (partsel ì œì™¸)
      if (!checkedNodes.length) {
        console.warn("[WBS] No checked nodes via API/DOM fallback.");
        alert("WBSì—ì„œ 'ì²´í¬(V)'ëœ í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤.\n(ì²´í¬ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”)");
        return;
      }

      checkedNodes.sort((a,b) => a.getIndexHier().localeCompare(b.getIndexHier(), undefined, { numeric:true }));

      const seen = new Set();
      for (const node of checkedNodes){
        const path = node.data?.path || pathOfNodeFT(node);
        const ids = await bfsCollectDescendantDbIds(provider, path, node);
        for (const id of ids){
          if (!seen.has(id)) {
            seen.add(id);
            orderedDbIds.push(id);
            pathByDbId.set(id, path.slice());
          }
        }
      }
    }

    if (!orderedDbIds.length) return alert("ì²´í¬ëœ í•­ëª©ì—ì„œ ì—°ê²° ê°€ëŠ¥í•œ ê°ì²´(dbId)ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");

    // ElementId í”„ë¦¬íŽ˜ì¹˜
    try { await ensureElementIdIndexForDbIds(orderedDbIds); } catch {}

    // ì €ìž¥ìš© ì˜¤ë¸Œì íŠ¸(ë¼ë²¨: "A - B - C - [ElementId|dbId]")
    const toLink = orderedDbIds.map((d) => {
      const p = pathByDbId.get(d) || [];
      const el = getElementIdFor(urn, d);
      const bracket = `[${el || d}]`;
      const pathLabel = p.length ? (p.join(" - ") + " - " + bracket) : bracket;
      return { urn, dbId: d, elementId: el || null, text: pathLabel };
    });

    // ==== ì ìœ /ì¶©ëŒ ì²˜ë¦¬(ê¸°ì¡´ ë¡œì§ ìœ ì§€) ====
    await (async () => {
      const occupancy = new Map();
      taskTree.getRootNode().visit(n => {
        const cat = normalizeTaskCategory(n.data?.selectedOption);
        if (!cat) return;
        (n.data?.linkedObjects || []).forEach(o => {
          const key = `${o.urn || urn}:${o.dbId}`;
          const slot = occupancy.get(key) || { C: null, T: null, D: null };
          if (cat === "C" && !slot.C) slot.C = n;
          if (cat === "T" && !slot.T) slot.T = n;
          if (cat === "D" && !slot.D) slot.D = n;
          occupancy.set(key, slot);
        });
      });

      const allowed = [];
      const conflictsForC = [];
      const conflictsC = [];
      const conflictsSame = [];

      toLink.forEach(obj => {
        const key = `${obj.urn}:${obj.dbId}`;
        const slot = occupancy.get(key) || { C: null, T: null, D: null };

        if (catSel === "C") {
          if (!slot.C && !slot.T && !slot.D) allowed.push(obj);
          else conflictsForC.push({ obj, slot });
        } else if (catSel === "T") {
          if (slot.C) conflictsC.push({ obj, slot });
          else if (slot.T) conflictsSame.push({ obj, slot });
          else allowed.push(obj);
        } else if (catSel === "D") {
          if (slot.C) conflictsC.push({ obj, slot });
          else if (slot.D) conflictsSame.push({ obj, slot });
          else allowed.push(obj);
        }
      });

      function unlinkFromNode(node, obj) {
        if (!node) return;
        node.data.linkedObjects = (node.data.linkedObjects || []).filter(
          o => !(String(o.urn || urn) === String(obj.urn) && Number(o.dbId) === Number(obj.dbId))
        );
        node.render && node.render();
      }

      if (catSel === "C" && conflictsForC.length) {
        const res = prompt([
          `ì„ íƒí•œ ê°ì²´ ì¤‘ ${conflictsForC.length}ê°œëŠ” ì´ë¯¸ ë‹¤ë¥¸ Taskì— ì—°ê²°ë˜ì–´ ìžˆìŠµë‹ˆë‹¤.`,
          `ê·œì¹™ìƒ 'ì‹œê³µ'ì€ ë‹¨ë… ì—°ê²°ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤.`,
          ``,
          `1. ê¸°ì¡´ ì—°ê²° í•´ì œ í›„ ì´ Task(ì‹œê³µ)ë¡œ ìƒˆë¡œ ì—°ê²°`,
          `2. ì´ë¯¸ ì—°ê²°ëœ ê°ì²´ë§Œ ì œì™¸í•˜ê³  ì§„í–‰`,
          `3. ì·¨ì†Œ`,
          ``,
          `ë²ˆí˜¸ë¥¼ ìž…ë ¥í•˜ì„¸ìš” (1/2/3)`
        ].join("\n"), "2");
        if (res === "3" || res == null) return;
        if (res === "1") {
          conflictsForC.forEach(({ obj, slot }) => {
            unlinkFromNode(slot.C, obj);
            unlinkFromNode(slot.T, obj);
            unlinkFromNode(slot.D, obj);
            allowed.push(obj);
          });
        }
      }

      if ((catSel === "T" || catSel === "D") && conflictsC.length) {
        const res = prompt([
          `ë‹¤ìŒ ê°ì²´ëŠ” 'ì‹œê³µ'ì— ì´ë¯¸ ì—°ê²°ë˜ì–´ ìžˆì–´ ${catLabel}ê³¼(ì™€) ë³‘í–‰í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`,
          ``,
          `1. ì‹œê³µ ì—°ê²° í•´ì œ í›„ ì´ Task(${catLabel})ë¡œ ìƒˆë¡œ ì—°ê²°`,
          `2. ì´ë¯¸ ì—°ê²°ëœ ê°ì²´ë§Œ ì œì™¸í•˜ê³  ì§„í–‰`,
          `3. ì·¨ì†Œ`,
          ``,
          `ë²ˆí˜¸ë¥¼ ìž…ë ¥í•˜ì„¸ìš” (1/2/3)`
        ].join("\n"), "2");
        if (res === "3" || res == null) return;
        if (res === "1") {
          conflictsC.forEach(({ obj, slot }) => { unlinkFromNode(slot.C, obj); allowed.push(obj); });
        }
      }

      if ((catSel === "T" || catSel === "D") && conflictsSame.length) {
        const label = catLabel;
        const res = prompt([
          `ë‹¤ìŒ ê°ì²´ëŠ” ì´ë¯¸ '${label}'ì— ì—°ê²°ë˜ì–´ ìžˆìŠµë‹ˆë‹¤.`,
          ``,
          `1. ê¸°ì¡´ '${label}' ì—°ê²°ì„ ì´ Taskë¡œ êµì²´ (í•´ë‹¹ ì¹´í…Œê³ ë¦¬ë§Œ êµì²´)`,
          `2. ì´ë¯¸ ì—°ê²°ëœ ê°ì²´ë§Œ ì œì™¸í•˜ê³  ì§„í–‰`,
          `3. ì·¨ì†Œ`,
          ``,
          `ë²ˆí˜¸ë¥¼ ìž…ë ¥í•˜ì„¸ìš” (1/2/3)`
        ].join("\n"), "2");
        if (res === "3" || res == null) return;
        if (res === "1") {
          conflictsSame.forEach(({ obj, slot }) => {
            if (catSel === "T") unlinkFromNode(slot.T, obj);
            if (catSel === "D") unlinkFromNode(slot.D, obj);
            allowed.push(obj);
          });
        }
      }

      if (allowed.length > 0) {
        const existing = selectedTaskNode.data.linkedObjects || [];
        const merged = [];
        const seenKey = new Set();
        const pushUniq = (o) => { const k = o.urn + ":" + o.dbId; if (!seenKey.has(k)) { seenKey.add(k); merged.push(o); } };
        allowed.forEach(pushUniq);  // WBS ìˆœì„œ ìš°ì„ 
        existing.forEach(pushUniq); // ê¸°ì¡´ ë’¤ì—
        selectedTaskNode.data.linkedObjects = merged;
      }

      const prev = window.__ALLOW_WBS_UPDATE;
      window.__ALLOW_WBS_UPDATE = true;
      try {
        if (window.requestTaskRecalcAndFlush) window.requestTaskRecalcAndFlush(); 
        else if (window.requestTaskTreeFlush) window.requestTaskTreeFlush();
        try { window.gantt?.renderFromTrees(window.taskTree, window.wbsTree); } catch(_) {}
      } finally {
        window.__ALLOW_WBS_UPDATE = prev;
      }

      try { await notifyCoverageDirtyAndRepaint(); } catch {}
    })();

    try { window.__WBS_MARK_TASKS_CHANGED?.(); } catch {}
  });

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì—°ê²° í•´ì œ â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  $("#btn-unlink").off("click").on("click", async function () {
    const taskTree = $.ui.fancytree.getTree("#treegrid");
    const selectedNode = taskTree.getActiveNode();
    if (!selectedNode) return alert("ì—°ê²°ì„ í•´ì œí•  Taskë¥¼ ì„ íƒí•˜ì„¸ìš”!");

    await runWbsHighlightBatch(async () => {
      (function unlinkAll(node){
        node.data.linkedObjects = [];
        if (node.hasChildren()) node.children.forEach(unlinkAll);
      })(selectedNode);

      withWbsGate(() => {
        flush(true);
        try { window.gantt?.renderFromTrees(window.taskTree, window.wbsTree); } catch(_) {}
      });

      try { await notifyCoverageDirtyAndRepaint(); } catch {}
    });
    notifyWbsStatusRefresh();
  });

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ ê³µì •í˜„í™© â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  $("#btn-date").off("click").on("click", function(){
    showCurrentTaskModal();
  });

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ TEST ë²„íŠ¼ â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  $("#btn-test").off("click").on("click", async function() {
    initTaskWbsButtons(window.viewer);
  });
}

/* =============================================================================
   Task íŠ¸ë¦¬ ì €ìž¥ ë³€í™˜/ë²ˆí˜¸ ìƒì„±
============================================================================= */
function getCurrentTaskDataFromTree() {
  const tree = $.ui.fancytree.getTree("#treegrid");
  const urn = window.CURRENT_MODEL_URN;
  function nodeToData(node) {
    const obj = {
      no: node.data.no,
      selectOptions: node.data.selectOptions ?? ["ì‹œê³µ", "ê°€ì„¤", "ì² ê±°"],
      selectedOption: node.data.selectedOption ?? "ì‹œê³µ",
      title: node.data.title ?? node.title,
      start: node.data.start,
      end: node.data.end,
      linkedObjects: (node.data.linkedObjects || []).map(o => ({
        urn: o.urn ?? urn,
        dbId: o.dbId,
        elementId: o.elementId ?? null,
        text: o.text ?? formatObjectLabel(o),
      })),
    };
    if (node.hasChildren()) obj.children = node.children.map(nodeToData);
    return obj;
  }
  return (tree.getRootNode().children || []).map(nodeToData);
}

function generateNo(parentNode) {
  if (!parentNode || parentNode.isRoot()) {
    const roots = $.ui.fancytree.getTree("#treegrid").getRootNode().children || [];
    return String(roots.length + 1);
  } else {
    const siblings = parentNode.children || [];
    const baseNo = parentNode.data.no || parentNode.title;
    return baseNo + "." + (siblings.length + 1);
  }
}

/* =============================================================================
   TEST ì• ë‹ˆë©”ì´ì…˜(ê¸°ì¡´ ìœ ì§€)
============================================================================= */
export function initTaskWbsButtons(viewer) {
  let btn = document.getElementById('btn-test');
  if (!btn || !viewer) return;

  const clone = btn.cloneNode(true);
  btn.parentNode.replaceChild(clone, btn);
  btn = clone;

  btn.addEventListener('click', async () => {
    try { await runTestAnimation(viewer); }
    catch (e) { console.error('[test-btn] error:', e); }
  });
}

async function runTestAnimation(viewer) {
  const sel = getSelectionSmart(viewer);
  if (!sel || !sel.model || !sel.dbIds.length) {
    console.warn('[test-btn] ë¨¼ì € ê°ì²´ë¥¼ ì„ íƒí•˜ì„¸ìš”.');
    return;
  }
  const { model, dbIds } = sel;
  viewer.clearSelection();

  const fragIds = collectFragIds(model, dbIds);
  if (!fragIds.length) return;

  const store = prepareFragStates(viewer, model, fragIds);

  const MOVE_Z = 5.0;
  const D1 = 2000;
  const HOLD = 1000;
  const D2 = 2000;

  const THREE = window.THREE || Autodesk.Viewing.THREE;
  const FALLBACK_COLOR = new THREE.Color(1.0, 0.45, 0.0);

  await animate(D1, (t) => {
    const k = easeInOutSine(t);
    const alphaOut = 1 - k;
    const dz = lerp(0, MOVE_Z, k);
    for (const f of store) {
      f.proxy.position.z = f.startPos.z + dz;
      f.proxy.updateAnimTransform();
      if (f.cloneMat) {
        f.cloneMat.opacity = alphaOut;
        f.cloneMat.transparent = true;
        f.cloneMat.needsUpdate = true;
        if (f.cloneMat.color && f.originalColor) {
          f.cloneMat.color.copy(f.originalColor).lerp(FALLBACK_COLOR, k);
        }
      }
    }
    viewer.impl.invalidate(true, true, true);
  });

  await delay(HOLD);

  await animate(D2, (t) => {
    const k = easeInOutSine(t);
    const alphaIn = k;
    const dz = lerp(MOVE_Z, 0, k);
    for (const f of store) {
      f.proxy.position.z = f.startPos.z + dz;
      f.proxy.updateAnimTransform();
      if (f.cloneMat) {
        f.cloneMat.opacity = alphaIn;
        f.cloneMat.transparent = true;
        f.cloneMat.needsUpdate = true;
        if (f.cloneMat.color && f.originalColor) {
          f.cloneMat.color.copy(FALLBACK_COLOR).lerp(f.originalColor, k);
        }
      }
    }
    viewer.impl.invalidate(true, true, true);
  });

  restoreFragStates(viewer, store);
}

function getSelectionSmart(viewer) {
  const agg = viewer.getAggregateSelection?.();
  if (agg && agg.length > 0) {
    const a = agg[0];
    const ids = (a.selection || []).slice();
    return ids.length ? { model: a.model, dbIds: ids, aggregate: true } : null;
  }
  const ids = viewer.getSelection?.() || [];
  return (ids && ids.length) ? { model: viewer.model, dbIds: ids, aggregate: false } : null;
}

function collectFragIds(model, dbIds) {
  const it = model.getData().instanceTree;
  const fragIds = [];
  dbIds.forEach((dbId) => {
    it.enumNodeFragments(dbId, (fragId) => fragIds.push(fragId), true);
  });
  return fragIds;
}

function getFragList(viewer, model) {
  if (model?.getFragmentList) return model.getFragmentList();
  if (viewer?.model?.getFragmentList) return viewer.model.getFragmentList();
  return null;
}

function prepareFragStates(viewer, model, fragIds) {
  const THREE = window.THREE || Autodesk.Viewing.THREE;
  const matman = viewer.impl.matman ? viewer.impl.matman() : null;
  const fragList = getFragList(viewer, model);
  const store = [];

  const fragToDb = {};
  if (fragList) {
    fragIds.forEach((fragId) => {
      try { fragToDb[fragId] = fragList.getDbId(fragId); } catch (_) {}
    });
  }

  for (const fragId of fragIds) {
    const proxy = viewer.impl.getFragmentProxy(model, fragId);
    proxy.getAnimTransform();
    const startPos = new THREE.Vector3(proxy.position.x, proxy.position.y, proxy.position.z);

    const rp = viewer.impl.getRenderProxy(model, fragId);
    const originalMat = rp?.material || null;

    let originalColor = null;
    if (originalMat && originalMat.color) originalColor = originalMat.color.clone();

    let cloneMat = null;
    if (originalMat) {
      cloneMat = (matman && matman.cloneMaterial) ? matman.cloneMaterial(originalMat) : originalMat.clone();
      cloneMat.transparent = true;
      cloneMat.opacity = 1.0;
      cloneMat.depthWrite = false;
      cloneMat.side = originalMat.side;
      cloneMat.needsUpdate = true;

      if (viewer.impl.setMaterial) {
        viewer.impl.setMaterial(model, fragId, cloneMat);
      } else if (fragList?.setMaterial) {
        fragList.setMaterial(fragId, cloneMat);
      } else if (viewer.impl.setFragmentMaterial) {
        viewer.impl.setFragmentMaterial(fragId, cloneMat);
      }
    }

    store.push({
      model, fragId,
      dbId: fragToDb[fragId],
      proxy, startPos,
      renderProxy: rp,
      originalMat, cloneMat,
      originalColor
    });
  }
  viewer.impl.invalidate(true, true, true);
  return store;
}

function restoreFragStates(viewer, store) {
  if (!store.length) return;
  const model = store[0].model;
  const fragList = getFragList(viewer, model);

  for (const f of store) {
    f.proxy.position.copy(f.startPos);
    f.proxy.updateAnimTransform();

    if (f.originalMat) {
      if (viewer.impl.setMaterial) {
        viewer.impl.setMaterial(f.model, f.fragId, f.originalMat);
      } else if (fragList?.setMaterial) {
        fragList.setMaterial(f.fragId, f.originalMat);
      } else if (viewer.impl.setFragmentMaterial) {
        viewer.impl.setFragmentMaterial(f.fragId, f.originalMat);
      }
    }
    if (f.cloneMat?.dispose) f.cloneMat.dispose();
  }

  viewer.impl.invalidate(true, true, true);
}

function lerp(a, b, t) { return a + (b - a) * t; }
function delay(ms) { return new Promise((res) => setTimeout(res, ms)); }
function animate(duration, step) {
  return new Promise((resolve) => {
    const start = performance.now();
    function frame(now) {
      const t = Math.min(1, (now - start) / duration);
      step(t);
      if (t < 1) requestAnimationFrame(frame);
      else resolve();
    }
    requestAnimationFrame(frame);
  });
}
function easeInOutSine(t){ return 0.5 - 0.5 * Math.cos(Math.PI * t); }



// /wwwroot/js/main.js â€” ì²« ë¡œë”© WBS ì…€ ìƒ‰ì¹  ë³´ìž¥ (ë°°ì§€ ì œê±°/ìµœì í™”)

import { initTabs } from "./sidebar/init-tabs.js";
import { initTree } from "./sidebar/init-tree.js";
import { initViewer, loadModel } from "./viewer/init-viewer.js";
import { buildWbsProviderLazy } from "./sidebar/task-wbs/wbs/loader.js";
import { bindPanel2Resizer } from "./sidebar/task-wbs/layout/panel-resizer.js";

import {
  initMatrix,
  bulkEnsureForVisible,
  computePathState,
  getCounts as _getCountsImported,   // ë¡œì»¬ importëŠ” ë””ë²„ê·¸ ë¸Œë¦¿ì§€ ëŒ€ìƒ ì•„ë‹˜(ì°¸ê³ ìš©)
  markTasksChanged,
} from "./sidebar/task-wbs/core/matrix-index.js";

import { toKey } from "./sidebar/task-wbs/core/path-key.js";

import {
  initTaskPanel,
  initTaskListButtons,
  setSavedTaskData,
  disableViewerEscReset,
  initWbsPanelWithFancytree,
} from "./sidebar/index.js";

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   ì „ì—­/ê¸°ë³¸ ì„¤ì •
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
try {
  window.__WBS_DEBUG = window.__WBS_DEBUG || {};
  window.getCounts = _getCountsImported;
  window.markTasksChanged = markTasksChanged;
} catch {}

const SIDEBAR_MIN = 360;
const SIDEBAR_DEFAULT = 900;
const PREVIEW_MIN = 520;

window.__FA_FALLBACK_BY_KEY = Object.create(null); // í´ë°± count ì €ìž¥ì†Œ

function initSidebarWidth() {
  const root = document.documentElement;
  const stored = parseInt(localStorage.getItem("sidebarWidthPx") || "0", 10);
  const maxNow = Math.max(SIDEBAR_MIN, window.innerWidth - PREVIEW_MIN);
  const initial = Number.isFinite(stored) && stored >= SIDEBAR_MIN
    ? Math.min(maxNow, stored)
    : Math.min(maxNow, SIDEBAR_DEFAULT);
  root.style.setProperty("--sidebar-width", initial + "px");
  return initial;
}

function resetViewerInputAndCamera(viewer) {
  try {
    const tc = viewer.toolController;
    if (tc?.isToolActivated?.("BoxSelectionTool")) tc.deactivateTool("BoxSelectionTool");
    viewer.setNavigationLock(false);
    const fallbackNav = viewer.impl?.is2d ? "pan" : "orbit";
    viewer.setActiveNavigationTool?.(fallbackNav);
    viewer.setSelectionMode(Autodesk.Viewing.SelectionMode.MIXED);
    viewer.clearSelection?.();
    if (!viewer.impl?.is2d) {
      viewer.navigation.setWorldUpVector(new THREE.Vector3(0, 0, 1), true);
      const bb = viewer.model?.getBoundingBox?.();
      if (bb) {
        const center = bb.getCenter(new THREE.Vector3());
        viewer.navigation.setPivotPoint(center);
        viewer.navigation.setTarget(center);
      }
    }
    viewer.fitToView?.();
  } catch {}
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   ë·°ì–´ ëŒ€ê¸° ìœ í‹¸
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function onceViewer(viewer, type) {
  return new Promise((resolve) => {
    const h = () => { try { viewer.removeEventListener(type, h); } catch {} ; resolve(); };
    viewer.addEventListener(type, h);
  });
}
function hasObjectTree(viewer) {
  return !!viewer.model?.getData?.()?.instanceTree;
}
async function waitObjectTree(viewer) {
  if (hasObjectTree(viewer)) return;
  await onceViewer(viewer, Autodesk.Viewing.OBJECT_TREE_CREATED_EVENT);
}
async function waitGeometry(viewer, timeoutMs = 180000) {
  await new Promise((resolve) => {
    let done = false;
    const h = () => { if (done) return; done = true; try { viewer.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, h); } catch {} ; resolve(); };
    viewer.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, h, { once: true });
    setTimeout(h, timeoutMs);
  });
}
async function waitPropertyDb(viewer, timeoutMs = 120000) {
  try { if (viewer?.model?.getPropertyDb?.()) return; } catch {}
  await new Promise((resolve) => {
    let done = false;
    const h = () => { if (done) return; done = true; try { viewer.removeEventListener(Autodesk.Viewing.PROPERTY_DB_CREATED_EVENT, h); } catch {} ; resolve(); };
    viewer.addEventListener(Autodesk.Viewing.PROPERTY_DB_CREATED_EVENT, h, { once: true });
    setTimeout(h, timeoutMs);
  });
}
function waitIdle(timeout = 60) {
  return new Promise((resolve) => {
    if (typeof window.requestIdleCallback === "function") {
      window.requestIdleCallback(() => resolve(), { timeout });
    } else setTimeout(resolve, timeout);
  });
}
async function waitViewerReady(viewer) {
  await Promise.all([ waitObjectTree(viewer), waitPropertyDb(viewer), waitGeometry(viewer) ]);
  await waitIdle(60);
}
async function focusCameraAndWait(viewer) {
  return new Promise((resolve) => {
    const onCam = () => { try { viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, onCam); } catch {}; requestAnimationFrame(() => resolve()); };
    viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, onCam, { once: true });
    resetViewerInputAndCamera(viewer);
  });
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   íƒœìŠ¤í¬/URN ìœ í‹¸
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function safeUrn(urn) { return urn.replace(/[^a-zA-Z0-9]/g, "_"); }
function fillUrnRecursive(task, defaultUrn) {
  if (Array.isArray(task.linkedObjects)) {
    task.linkedObjects.forEach((o) => { if (!o.urn) o.urn = defaultUrn || window.CURRENT_MODEL_URN; });
  }
  if (Array.isArray(task.children)) {
    task.children.forEach((child) => fillUrnRecursive(child, defaultUrn));
  }
}
function persistTasksSnapshot(tasks) {
  const RAW  = window.CURRENT_MODEL_URN;
  const SAFE = window.CURRENT_MODEL_SAFE_URN;
  if (!RAW || !SAFE) return;
  try {
    const json = JSON.stringify(tasks || []);
    localStorage.setItem(`hec:tasks:${RAW}`, json);
    localStorage.setItem(`hec:tasks:${SAFE}`, json);
    window.__SAVED_TASKS = (tasks || []);
    console.log("[persistTasksSnapshot] saved. count =", window.__SAVED_TASKS.length);
  } catch (e) {
    console.warn("[persistTasksSnapshot] failed:", e);
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Provider ì›Œë°ì—… / í´ë°± ì§‘ê³„
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
async function seedDbIdMappings(provider, { maxDepth = 3, cap = 6000 } = {}) {
  const roots = await provider.roots().catch(() => []) || [];
  const q = roots.map(r => ({ path: [r.text], depth: 0 }));
  let visited = 0;
  while (q.length && visited < cap) {
    const { path, depth } = q.shift();
    try { provider.getDbIdsForPath?.(path, { includeDescendants: true, allowUnbuilt: true }); } catch {}
    if (depth < maxDepth) {
      let kids = [];
      try { kids = await provider.childrenByPath(path) || []; } catch {}
      visited += kids.length;
      for (const ch of kids) {
        const np = ch.__path || [...path, ch.text];
        q.push({ path: np, depth: depth + 1 });
      }
    }
  }
}

async function collectKeysForRoots(provider, { maxDepth = 3, cap = 6000 } = {}) {
  const roots = (await provider.roots().catch(() => [])) || [];
  const q = roots.map(r => ({ path: [r.text], depth: 0 }));
  const keys = new Set();
  let seen = 0;

  while (q.length && seen < cap) {
    const { path, depth } = q.shift();
    keys.add(toKey(path));

    let kids = [];
    try { kids = await provider.childrenByPath(path) || []; } catch {}
    seen += kids.length;

    if (depth < maxDepth) {
      for (const ch of kids) {
        const np = ch.__path || [...path, ch.text];
        q.push({ path: np, depth: depth + 1 });
      }
    }
  }
  return Array.from(keys);
}

// íƒœìŠ¤í¬ â†’ ìƒíƒœë³„ dbId ì„¸íŠ¸
function buildStatusSetsFromTasks(tasks) {
  const stateById = new Map();
  const norm = (raw) => {
    if (!raw) return "";
    const s = String(raw).trim();
    const S = s.toUpperCase();
    if (s.includes("ì‹œê³µ") || S.startsWith("C")) return "C";
    if (s.includes("ê°€ì„¤") || S.startsWith("T")) return "T";
    if (s.includes("ì² ê±°") || s.includes("í•´ì²´") || S.startsWith("D")) return "D";
    if (S === "TD" || s.includes("ë™ì‹œ") || s.includes("ë³µí•©") || S.startsWith("X")) return "TD";
    return "";
  };
  const prio = { C:3, TD:2, D:1, T:0, "":-1 };
  function apply(id, sNew) {
    if (!id || !sNew) return;
    const cur = stateById.get(id);
    if (!cur) { stateById.set(id, sNew); return; }
    if ((cur === "T" && sNew === "D") || (cur === "D" && sNew === "T")) { stateById.set(id, "TD"); return; }
    stateById.set(id, prio[sNew] > prio[cur] ? sNew : cur);
  }
  (function walk(arr, inherited="") {
    (arr||[]).forEach(t => {
      const sTask = norm(t.status || t.selectedOption || inherited);
      (t.linkedObjects||[]).forEach(o => apply(o.dbId, norm(o.status || o.phase || sTask)));
      if (t.children) walk(t.children, sTask);
    });
  })(tasks);
  const S = { C:new Set(), T:new Set(), D:new Set(), TD:new Set() };
  for (const [id, s] of stateById.entries()) if (S[s]) S[s].add(id);
  return S;
}

function calcCountsForPath(provider, path, S) {
  let ids = [];
  try {
    ids = provider.getDbIdsForPath(path, { includeDescendants:true, allowUnbuilt:true }) || [];
  } catch {}
  if (!ids.length) return { total:0, c:0, t:0, d:0, td:0 };
  const set = new Set(ids);
  let c=0,t=0,d=0,td=0;
  for (const id of set) {
    if (S.C.has(id)) c++;
    if (S.T.has(id)) t++;
    if (S.D.has(id)) d++;
    if (S.TD.has(id)) td++;
  }
  return { total:set.size, c,t,d,td };
}

function keyFromPath(path) {
  const D = window.__WBS_DEBUG;
  return (D?.toKey ? D.toKey(path) : toKey(path));
}

async function buildFallbackMap(provider, { maxDepth=3, cap=6000 } = {}) {
  window.__FA_FALLBACK_BY_KEY = Object.create(null);
  const tasks = window.__SAVED_TASKS || [];
  const S = buildStatusSetsFromTasks(tasks);

  const roots = (await provider.roots().catch(()=>[])) || [];
  const q = roots.map(r => ({ path:[r.text], depth:0 }));
  let seen = 0;

  while (q.length && seen < cap) {
    const { path, depth } = q.shift();
    const key = keyFromPath(path);
    window.__FA_FALLBACK_BY_KEY[key] = calcCountsForPath(provider, path, S);

    let kids = [];
    try { kids = await provider.childrenByPath(path) || []; } catch {}
    seen += kids.length;
    if (depth < maxDepth) {
      for (const ch of kids) q.push({ path: (ch.__path || [...path, ch.text]), depth: depth+1 });
    }
  }
  console.log("[FA] fallback map ready (keys =", Object.keys(window.__FA_FALLBACK_BY_KEY).length, ")");
}

function patchGetCountsToUseFallback() {
  const D = window.__WBS_DEBUG;
  const fbMap = () => window.__FA_FALLBACK_BY_KEY || Object.create(null);

  if (!window.__FA_BRIDGED_GLOBAL) {
    const origGlobal = window.getCounts;
    window.getCounts = function (k) {
      const r = origGlobal ? (origGlobal(k) || {}) : {};
      const sum = ((r.c|0)+(r.t|0)+(r.d|0)+(r.td|0));
      if (sum > 0) return r;
      const fb = fbMap()[k];
      if (fb) { const total = Math.max((r.total|0), (fb.total|0)); return { total, c:fb.c|0, t:fb.t|0, d:fb.d|0, td:fb.td|0 }; }
      return r;
    };
    window.__FA_BRIDGED_GLOBAL = true;
  }

  if (D?.getCounts && !D.__patchedForFallback) {
    const orig = D.getCounts.bind(D);
    D.__origGetCounts = orig;
    D.getCounts = function (k) {
      const r = orig(k) || {};
      const sum = ((r.c|0)+(r.t|0)+(r.d|0)+(r.td|0));
      if (sum > 0) return r;
      const fb = fbMap()[k];
      if (fb) { const total = Math.max((r.total|0), (fb.total|0)); return { total, c:fb.c|0, t:fb.t|0, d:fb.d|0, td:fb.td|0 }; }
      return r;
    };
    D.__patchedForFallback = true;
  }

  console.log("[FA] getCounts bridged");
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   WBS FancyTree ì…€ ìƒ‰ì¹  (ë°°ì§€ ì œê±°)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const CELL_COLOR = {
  C:  "#ef4444", // ì‹œê³µ(ë¹¨ê°•)
  T:  "#f59e0b", // ê°€ì„¤(ì£¼í™©)
  D:  "#6b7280", // ì² ê±°(íšŒìƒ‰)
  TD: "#2563eb"  // ê°€ì„¤+ì² ê±°(íŒŒëž‘)
};

function injectWbsCellCss() {
  if (document.getElementById("wbs-cell-style")) return;
  const css = `
    .fancytree-node .fancytree-title {
      border-left: 4px solid transparent;
      padding-left: 8px;
      border-radius: 6px;
      transition: background-color .15s ease, border-color .15s ease;
    }
    .wbsCell--C  .fancytree-title  { background: ${CELL_COLOR.C}1a;  border-left-color: ${CELL_COLOR.C}; }
    .wbsCell--T  .fancytree-title  { background: ${CELL_COLOR.T}1a;  border-left-color: ${CELL_COLOR.T}; }
    .wbsCell--D  .fancytree-title  { background: ${CELL_COLOR.D}1a;  border-left-color: ${CELL_COLOR.D}; }
    .wbsCell--TD .fancytree-title  { background: ${CELL_COLOR.TD}1a; border-left-color: ${CELL_COLOR.TD}; }
  `.trim();
  const s = document.createElement("style");
  s.id = "wbs-cell-style";
  s.textContent = css;
  document.head.appendChild(s);
}

function normalizeCounts(x){
  // ì–´ë–¤ í˜•íƒœë¡œ ì™€ë„ ì•ˆì „í•˜ê²Œ ê°ì²´ë¡œ ë³€í™˜
  if (x == null) return { total: 0, C: 0, T: 0, D: 0 };
  if (typeof x === "number") return { total: x, C: x, T: 0, D: 0 }; // ì´í•©ë§Œ ì•„ëŠ” í˜•íƒœ
  // ê°ì²´ì¼ ë•Œ í•„ë“œ ë³´ì •
  return {
    total: Number(x.total ?? x.count ?? 0),
    C:     Number(x.C ?? x.c ?? 0),
    T:     Number(x.T ?? x.t ?? 0),
    D:     Number(x.D ?? x.d ?? 0),
  };
}

function countsForPath(path){
  // 1) ë¸Œë¦¬ì§€ í•¨ìˆ˜ê°€ ìžˆìœ¼ë©´ ìš°ì„  ì‚¬ìš©
  if (typeof window.__FA_GET_COUNTS__ === "function") {
    return normalizeCounts(window.__FA_GET_COUNTS__(path));
  }
  // 2) Providerì— countAtê°€ ìžˆìœ¼ë©´ ì‚¬ìš©
  const provider = window.__WBS_PROVIDER;
  if (provider?.countAt) {
    return normalizeCounts(provider.countAt(path));
  }
  // 3) WbsStoreê°€ ìžˆìœ¼ë©´ ìŠ¤í† ì–´ì˜ countAt ì‚¬ìš©
  const store = window.__WBS_STORE__;
  if (store?.countAt) {
    return normalizeCounts(store.countAt(path));
  }
  // 4) ì‚¬ì „ ê³„ì‚° ë§µì´ ìžˆë‹¤ë©´ (í‚¤ ì¡°ì¸ì€ ìŠ¤í† ì–´ì™€ ë™ì¼í•œ êµ¬ë¶„ìž ì‚¬ìš©)
  const SEP = "\u0001";
  const key = (path || []).join(SEP);
  const m = window.__FA_COUNT_MAP__;
  if (m && typeof m.get === "function") {
    return normalizeCounts(m.get(key));
  }
  // 5) ì „ë¶€ ì—†ìœ¼ë©´ 0ìœ¼ë¡œ
  return normalizeCounts(null);
}

function classForCounts(c) {
  if (!c) return null;
  if ((c.td|0) > 0) return "wbsCell--TD";
  if ((c.c|0)  > 0) return "wbsCell--C";
  if ((c.t|0)  > 0) return "wbsCell--T";
  if ((c.d|0)  > 0) return "wbsCell--D";
  return null;
}

function repaintNode(node) {
  const $ = window.jQuery || window.$;
  if (!$ || !node || !node.span || node.isRoot?.()) return;

  // __pathê°€ ì—†ìœ¼ë©´ ì•„ì§ ë§¤í•‘ ì „ â†’ ì´ë²ˆ í”„ë ˆìž„ ìŠ¤í‚µ (ìž¬ì‹œë„ ë£¨í”„ê°€ ë‹¤ì‹œ ì¹ í•¨)
  const path = node.data?.__path;
  if (!path) return;

  const counts = countsForPath(path);
  const $li = $(node.li);
  $li.removeClass("wbsCell--C wbsCell--T wbsCell--D wbsCell--TD");
  const cls = classForCounts(counts);
  if (cls) $li.addClass(cls);
}

function repaintTree(tree) {
  if (!tree) return;
  tree.visit(repaintNode);
}

// ì²« ë¡œë”© ì…€ ì¹ í•˜ê¸° ìž¬ì‹œë„ ë£¨í”„(ìµœëŒ€ 1ì´ˆ)
function startFirstPaintRetry(tree) {
  let tries = 0;
  const maxTries = 10;
  const step = () => {
    tries++;
    repaintTree(tree);
    if (tries >= maxTries) return;
    setTimeout(step, 100);
  };
  setTimeout(step, 0);
}

function installWbsDecorators(tree) {
  const $ = window.jQuery || window.$;
  if (!tree) tree = $.ui?.fancytree?.getTree("#wbs-tree");
  if (!tree) return;

  injectWbsCellCss();

  // ê¸°ì¡´ í›… ì²´ì´ë‹
  const prevRenderNode = tree.options.renderNode;
  tree.$div.fancytree("option", "renderNode", function(event, data) {
    try { if (typeof prevRenderNode === "function") prevRenderNode.call(this, event, data); } catch {}
    try { repaintNode(data.node); } catch {}
  });
  tree.$div.fancytree("option", "createNode", function(_ev, data) {
    try { repaintNode(data.node); } catch {}
  });
  tree.$div.fancytree("option", "expand", function(_ev, data) {
    if (data.node?.expanded) setTimeout(() => { try { repaintTree(tree); } catch {} }, 0);
  });

  // ì´ˆê¸° ë‘ í”„ë ˆìž„ + ìž¬ì‹œë„ ë£¨í”„
  try { repaintTree(tree); } catch {}
  requestAnimationFrame(() => { try { repaintTree(tree); } catch {} });
  startFirstPaintRetry(tree);

  // ë””ë²„ê·¸ í›…
  tree.__wbsHelpers = tree.__wbsHelpers || {};
  tree.__wbsHelpers.repaintTree = () => { try { repaintTree(tree); } catch {} };
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   íƒœìŠ¤í¬ ë¡œë“œ(API ëŒ€ì²´ ìƒ˜í”Œ)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const SAMPLE_TASK_DATA = [
  {
    no: "1", title: "Task A", selectedOption: "ì‹œê³µ",
    start: "2024-06-25", end: "2024-07-01",
    linkedObjects: [{ urn: "SAMPLE_URN", dbId: 1001, text: "ë²½ì²´1" }],
    children: [
      { no: "1.1", title: "Subtask A1", selectedOption: "ì‹œê³µ",
        start: "2024-06-26", end: "2024-06-30",
        linkedObjects: [{ urn: "SAMPLE_URN", dbId: 1002, text: "ë²½ì²´2" }] }
    ],
  },
  { no: "2", title: "Task B", selectedOption: "ê°€ì„¤", start: "", end: "", linkedObjects: [] },
];

async function fetchTaskDataForCurrentModel() {
  try {
    const safeUrnVal = window.CURRENT_MODEL_SAFE_URN;
    const url = `/api/tasks?urn=${safeUrnVal}`;
    const resp = await fetch(url, { credentials: "include" });
    if (resp.ok) {
      const data = await resp.json();
      if (Array.isArray(data) && data.length > 0) return data;
    }
  } catch (err) {
    console.warn("task ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ìƒ˜í”Œë¡œ ëŒ€ì²´:", err);
  }
  return SAMPLE_TASK_DATA.map(x => structuredClone(x));
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   ë¦¬ì‚¬ì´ì¦ˆ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
window.addEventListener("resize", _.throttle(() => {
  try {
    initSidebarWidth();
    window.viewer?.resize?.();
    window.viewer?.impl?.invalidate?.(true, true, true);
  } catch (e) { console.warn("[resize] redraw failed", e); }
}, 120));

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   main
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
(async function () {
  try {
    // 1) ë¡œê·¸ì¸
    const resp = await fetch("/api/auth/profile", { credentials: "include" });
    if (!resp.ok) { window.location.replace("/api/auth/login"); return; }
    const user = await resp.json();
    const login = document.getElementById("login");
    login.innerText = `Logout (${user.name})`;
    login.onclick = () => {
      const iframe = document.createElement("iframe");
      iframe.style.visibility = "hidden";
      iframe.src = "https://accounts.autodesk.com/Authentication/LogOut";
      document.body.appendChild(iframe);
      iframe.onload = () => { window.location.replace("/api/auth/logout"); document.body.removeChild(iframe); };
    };

    // 2) ë ˆì´ì•„ì›ƒ
    const Sidebar = document.getElementById("sidebar");
    const Header  = document.getElementById("header");
    const Preview = document.getElementById("preview");
    const sidebarResizer = document.getElementById("sidebar-resizer");
    const Loading = document.getElementById("loading");
    Sidebar.style.display = "";
    sidebarResizer.style.display = "";
    Preview.style.display = "";
    Header.style.display = "";
    Loading.style.display = "none";
    login.style.visibility = "visible";
    Sidebar.style.removeProperty("width");
    Preview.style.removeProperty("left");
    sidebarResizer.style.removeProperty("left");
    initSidebarWidth();

    // 3) íƒ­/ë·°ì–´
    initTabs("#sidebar");
    const viewerHost = document.getElementById("viewer-host");
    const viewer = await initViewer(viewerHost);
    window.viewer = viewer;
    disableViewerEscReset(viewer);

    viewer.resize();
    viewer.impl?.invalidate?.(true, true, true);
    requestAnimationFrame(() => { try { viewer.resize(); viewer.impl?.invalidate?.(true, true, true); } catch {} });
    resetViewerInputAndCamera(viewer);

    requestAnimationFrame(() => {
      const sb = document.getElementById("sidebar");
      if (sb && sb.offsetWidth === 0) {
        document.documentElement.style.setProperty("--sidebar-width", SIDEBAR_DEFAULT + "px");
        viewer.resize();
        viewer.impl?.invalidate?.(true, true, true);
      }
    });

    // 4) ëª¨ë¸ ì„ íƒ
    initTree("#tree", async (versionId) => {
      const urn = window.btoa(versionId).replace(/=/g, "");
      window.CURRENT_MODEL_URN = urn;
      window.CURRENT_MODEL_SAFE_URN = safeUrn(urn);

      // ê¸°ì¡´ WBS íŒŒê´´
      try { $.ui.fancytree.getTree("#wbs-tree")?.destroy(); } catch {}
      $("#wbs-group-content").empty();

      // (A) ëª¨ë¸ ë¡œë“œ & ì•ˆì •í™”
      await loadModel(viewer, urn);
      await waitViewerReady(viewer);
      await focusCameraAndWait(viewer);
      viewer.resize();

      // (B) WBS Provider ìƒì„±
      let provider = null;
      try {
        const PRIMARY = ["HEC.WBS","HEC.Level","HEC.Zone"];
        const { provider: p } = await buildWbsProviderLazy(viewer, {
          primaryOrder: PRIMARY, source: "all", bucketThreshold: 400, bucketSize: 200,
        });
        provider = p;
        window.WBS_PROVIDER = provider;
        const roots = await provider.roots();
        console.log("[WBS] roots:", Array.isArray(roots) ? roots.length : roots);
      } catch (e) {
        console.warn("[WBS] provider failed:", e);
        provider = { __provider:true, roots:async()=>[], childrenByPath:async()=>[] };
        window.WBS_PROVIDER = provider;
      }

      // (C) íƒœìŠ¤í¬ ë¡œë“œ/ì •ê·œí™”/ì˜ì†
      const tasks = await fetchTaskDataForCurrentModel();
      tasks.forEach((t) => fillUrnRecursive(t, urn));
      persistTasksSnapshot(tasks);

      // (D) provider ë§µ ì›Œë°ì—… â†’ ë§¤íŠ¸ë¦­ìŠ¤ ì´ˆê¸°í™” â†’ íƒœìŠ¤í¬ ë°ì´í„° UIë¡œ ê³µìœ 
      await seedDbIdMappings(provider, { maxDepth: 3, cap: 6000 });
      await initMatrix({ primaryOrder:["HEC.WBS","HEC.Level","HEC.Zone"], provider });
      setSavedTaskData(tasks);

      // (E) í´ë°±ë§µ ì¤€ë¹„ & getCounts ë¸Œë¦¿ì§€
      await buildFallbackMap(provider, { maxDepth:3, cap:6000 });
      patchGetCountsToUseFallback();

      // (F) ì„ ê³„ì‚°(ë£¨íŠ¸~ê¹Šì´3)
      const preKeys = await collectKeysForRoots(provider, { maxDepth: 3, cap: 6000 });
      await bulkEnsureForVisible(preKeys);
      preKeys.forEach(computePathState);

      // (G) íŠ¸ë¦¬ init â†’ í•¸ë“¤ í™•ë³´ â†’ ë°ì½”ë ˆì´í„° ì„¤ì¹˜ â†’ ì²« ì¹ í•˜ê¸° ìž¬ì‹œë„
      await initWbsPanelWithFancytree(provider, { primaryOrder: ["HEC.WBS","HEC.Level","HEC.Zone"] });
      console.log("[STEP 5] WBS fancytree init OK");

      const tree = $.ui.fancytree.getTree("#wbs-tree");
      installWbsDecorators(tree); // â˜… ì…€ ìƒ‰ì¹  ì „ìš©(ë°°ì§€ ì—†ìŒ)

      // (H) ë‚˜ë¨¸ì§€
      try { bindPanel2Resizer(viewer); console.log("[STEP 6] panel2 resizer bound"); } catch {}
      try { initTaskPanel(tasks); initTaskListButtons(); console.log("[STEP 1] Task panel OK"); } catch {}
      try { window.dispatchEvent(new Event("panel2-ready")); console.log("[STEP 2] panel2-ready dispatched"); } catch {}
    });

  } catch (err) {
    alert("Could not initialize the application. See console for more details.");
    console.error(err);
  }
})();



// /wwwroot/js/sidebar/index.js
// í¼ì‚¬ë“œ: ì™¸ë¶€ì—ì„œëŠ” ì´ íŒŒì¼ë§Œ import í•˜ì„¸ìš”.

// Task / WBS íŒ¨ë„
export { initTaskPanel } from "./task-wbs/task-tree.js";
export { initTaskListButtons, setSavedTaskData } from "./task-wbs/task-buttons.js";

// âœ… ìƒˆ WBS(Fancytree + ë§¤íŠ¸ë¦­ìŠ¤)
export { initWbsPanelWithFancytree } from "./task-wbs/wbs-panel-init.js";

// (êµ¬ í•˜ì´ë¼ì´íŠ¸ ëª¨ë“ˆ í˜¸ì¶œ ì œê±°: Fancytree ì „í™˜ ì¤‘ì—ëŠ” ë¶ˆí•„ìš”)

// â”€â”€ í•˜ì´ë¼ì´íŠ¸ ê²Œì´íŠ¸(íŠ¸ëž˜í”½ ì¡°ì ˆ) â”€â”€

// ë‚ ì§œ/ë¦¬ë“œíƒ€ìž„ ìœ í‹¸(í•„ìš” ì‹œ ì™¸ë¶€ ì‚¬ìš©)
export * as DateHelpers from "./task-wbs/core/date-helpers.js";

// ESC: ë·°ì–´ ìƒíƒœ ì´ˆê¸°í™” ì°¨ë‹¨ + ESCë¡œ Task/WBS ì„ íƒë§Œ í•´ì œ
export { disableViewerEscReset } from "./task-wbs/helpers/viewer-esc.js";

// (ì„ íƒ) WBS ë¡œë”(ì§€ì—° í”„ë¡œë°”ì´ë”)ë„ í¼ì‚¬ë“œë¡œ ë…¸ì¶œ
// â€» ë‹¹ì‹ ì˜ ì‹¤ì œ íŒŒì¼ ìœ„ì¹˜ì— ë§žì¶° ê²½ë¡œ ìœ ì§€í•˜ì„¸ìš”.
export { buildWbsProviderLazy } from "./task-wbs/wbs/loader.js";

// Box Selection (ìžˆìœ¼ë©´ ìœ ì§€)
export { BoxSelectionTool, enableBoxSelectionMode } from "/js/viewer/selection-tool.js";

