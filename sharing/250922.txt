// /wwwroot/js/task-wbs/4d/4d-simulation.js
// 공개 API:
//   apply4DAtMs(viewer, timeMs, config)
//   apply4DAt(viewer, dateISO, config)  // 호환용 래퍼
//   reset4D(viewer)
//
// config 기본값:
// {
//   zOffset: 3.0,              // m (모델 단위 맞춰 조정)
//   useDateDuration: true,     // true: 작업 시작~끝 날짜 비율 사용, false: 고정시간 방식
//   fixedDurationSec: 2.0,     // useDateDuration=false 시 1개 작업 가상 진행시간(초)
//   speedDaysPerSec: 1.0,      // 재생 속도(참조용)
//   syncThemingAlpha: true     // in-range 테마 알파도 함께 페이드
// }

let _globalState = new Map(); // key: model.id

export function reset4D(viewer) {
  const model = (viewer.getVisibleModels?.()[0]) || viewer.model;
  if (!model) return;
  const st = _globalState.get(model.id);
  if (!st) return;

  const { store } = st;
  const fragList = _getFragList(viewer, model);

  for (const f of store.items) {
    try {
      f.proxy.position.copy(f.startPos);
      f.proxy.updateAnimTransform();

      if (f.originalMat) {
        if (viewer.impl.setMaterial) viewer.impl.setMaterial(model, f.fragId, f.originalMat);
        else if (fragList?.setMaterial) fragList.setMaterial(f.fragId, f.originalMat);
        else if (viewer.impl.setFragmentMaterial) viewer.impl.setFragmentMaterial(f.fragId, f.originalMat);
      }
      if (f.cloneMat?.dispose) f.cloneMat.dispose();
      f.cloneMat = null;
    } catch(_) {}
  }
  viewer.impl.invalidate?.(true, true, true);
  _globalState.delete(model.id);
}

export function apply4DAt(viewer, dateISO, config = {}) {
  if (!dateISO) return;
  const ms = Date.parse(String(dateISO));
  if (!Number.isFinite(ms)) return;
  apply4DAtMs(viewer, ms, config);
}

export function apply4DAtMs(viewer, nowMs, config = {}) {
  const cfg = {
    zOffset: 3.0,
    useDateDuration: true,
    fixedDurationSec: 2.0,
    speedDaysPerSec: 1.0,
    syncThemingAlpha: true,
    ...config,
  };
  if (!viewer || !Number.isFinite(nowMs)) return;
  const model = (viewer.getVisibleModels?.()[0]) || viewer.model;
  if (!model) return;

  let state = _globalState.get(model.id);
  if (!state) {
    const schedule = _buildScheduleFromTaskTree(model);
    const store = _prepareStore(viewer, model, schedule);
    state = { schedule, store };
    _globalState.set(model.id, state);
  }
  const { schedule, store } = state;
  if (!schedule.items.length) return;

  // 정책과 동일한 색 (알파는 프레임마다 가변)
  const V4 = (r,g,b,a=1) => (window.THREE ? new window.THREE.Vector4(r,g,b,a) : { r,g,b,a });
  const cByCat = {
    C: V4(0.16, 0.57, 0.20, 1),
    T: V4(0.12, 0.45, 0.90, 1),
    D: V4(0.95, 0.27, 0.23, 1),
  };

  for (const it of schedule.items) {
    // 기간(고정시간 모드면 end 대체)
    const endMsEff = cfg.useDateDuration
      ? it.endMs
      : (it.startMs + cfg.fixedDurationSec * 1000 * cfg.speedDaysPerSec);

    const denom = Math.max(1, endMsEff - it.startMs);
    const p = _norm01((nowMs - it.startMs) / denom);

    let alpha = 1.0, dz = 0.0;
    const zOff = cfg.zOffset;

    if (it.cat === 'C' || it.cat === 'T') {
      // 시공/가설: 시작 전 숨김(zOff), 기간 중 0→1 페이드 + zOff→0 이동, 이후 보임
      if (nowMs < it.startMs) { alpha = 0.0; dz = zOff; }
      else if (nowMs <= endMsEff) { alpha = p; dz = _lerp(zOff, 0, p); }
      else { alpha = 1.0; dz = 0.0; }
    } else { // D 철거: 시작 전 보임, 기간 중 1→0 페이드 + 0→zOff 이동, 이후 숨김(zOff)
      if (nowMs < it.startMs) { alpha = 1.0; dz = 0.0; }
      else if (nowMs <= endMsEff) { alpha = 1.0 - p; dz = _lerp(0, zOff, p); }
      else { alpha = 0.0; dz = zOff; }
    }

    // dbId → frag 반영
    const fragsByDb = store.byDb;
    for (const dbId of it.dbIds) {
      const frags = fragsByDb.get(dbId);
      if (!frags) continue;

      for (const f of frags) {
        try {
          f.proxy.position.z = f.startPos.z + dz;
          f.proxy.updateAnimTransform();

          if (f.cloneMat) {
            f.cloneMat.opacity = alpha;
            f.cloneMat.transparent = true;
            f.cloneMat.depthWrite = false;
            f.cloneMat.needsUpdate = true;
          }
        } catch(_) {}
      }

      if (cfg.syncThemingAlpha) {
        const col = cByCat[it.cat];
        if (col) {
          const vv = V4(col.x ?? col.r, col.y ?? col.g, col.z ?? col.b, alpha);
          try { viewer.setThemingColor(dbId, vv, model); } catch(_) {}
        }
      }
    }
  }

  viewer.impl.invalidate?.(true, true, true);
}

/* ------------------ 내부 구현 ------------------ */

function _buildScheduleFromTaskTree(model) {
  const urnCur = String(window.CURRENT_MODEL_URN || "");
  const tree = window.taskTree;

  const items = [];
  const normCat = (v) => {
    const s = String(v || "").trim();
    if (s === "C" || s.startsWith("시공")) return "C";
    if (s === "T" || s.startsWith("가설")) return "T";
    if (s === "D" || s.startsWith("철거")) return "D";
    return "";
  };
  const isISO = (s) => /^\d{4}-\d{2}-\d{2}$/.test(String(s||""));

  if (tree?.getRootNode) {
    tree.getRootNode()?.visit((n) => {
      const d = n.data || {};
      const cat = normCat(d.selectedOption);
      if (!cat) return;
      if (!isISO(d.start) || !isISO(d.end)) return;

      const objs = Array.isArray(d.linkedObjects) ? d.linkedObjects : [];
      const dbIds = [];
      for (const o of objs) {
        const urn = String(o.urn || urnCur);
        if (urnCur && urn !== urnCur) continue;
        const id = Number(o.dbId);
        if (Number.isFinite(id)) dbIds.push(id);
      }
      if (!dbIds.length) return;

      items.push({
        cat,
        startMs: Date.parse(d.start + "T00:00:00Z"),
        endMs:   Date.parse(d.end   + "T23:59:59Z"),
        dbIds
      });
    });
  }
  return { items };
}

function _prepareStore(viewer, model, schedule) {
  const THREE = window.THREE || Autodesk.Viewing.THREE;
  const matman = viewer.impl.matman ? viewer.impl.matman() : null;
  const fragList = _getFragList(viewer, model);
  const it = model.getData().instanceTree;

  const byDb = new Map();
  const items = [];
  const fragIdToDb = new Map();

  // dbId → fragId
  const uniqDb = new Set();
  for (const s of schedule.items) for (const id of s.dbIds) uniqDb.add(id);

  uniqDb.forEach((dbId) => {
    const list = [];
    it.enumNodeFragments(dbId, (fragId) => {
      list.push(fragId);
      fragIdToDb.set(fragId, dbId);
    }, true);
    if (list.length) byDb.set(dbId, []);
  });

  // frag별 프록시/머티리얼 클론
  const allFragIds = [...fragIdToDb.keys()];
  for (const fragId of allFragIds) {
    const proxy = viewer.impl.getFragmentProxy(model, fragId);
    proxy.getAnimTransform();
    const startPos = new THREE.Vector3(proxy.position.x, proxy.position.y, proxy.position.z);

    const rp = viewer.impl.getRenderProxy(model, fragId);
    const originalMat = rp?.material || null;

    let cloneMat = null;
    if (originalMat) {
      cloneMat = (matman?.cloneMaterial) ? matman.cloneMaterial(originalMat) : originalMat.clone();
      cloneMat.transparent = true;
      cloneMat.opacity = originalMat.opacity ?? 1.0;
      cloneMat.depthWrite = false;
      cloneMat.side = originalMat.side;
      cloneMat.needsUpdate = true;

      if (viewer.impl.setMaterial) viewer.impl.setMaterial(model, fragId, cloneMat);
      else if (fragList?.setMaterial) fragList.setMaterial(fragId, cloneMat);
      else if (viewer.impl.setFragmentMaterial) viewer.impl.setFragmentMaterial(fragId, cloneMat);
    }

    const f = { fragId, proxy, startPos, originalMat, cloneMat };
    items.push(f);

    const dbId = fragIdToDb.get(fragId);
    if (Number.isInteger(dbId) && byDb.has(dbId)) {
      byDb.get(dbId).push(f);
    }
  }

  viewer.impl.invalidate?.(true, true, true);
  return { items, byDb };
}

function _getFragList(viewer, model) {
  if (model?.getFragmentList) return model.getFragmentList();
  if (viewer?.model?.getFragmentList) return viewer.model.getFragmentList();
  return null;
}

function _norm01(x) { return x <= 0 ? 0 : (x >= 1 ? 1 : x); }
function _lerp(a,b,t){ return a + (b - a) * (t < 0 ? 0 : (t > 1 ? 1 : t)); }



// /wwwroot/js/sidebar/task-wbs/ui/current-task-modal.js
import { calendarSvg } from "./calendar-svg.js";
import { apply4DAtMs, reset4D } from "../../task-wbs/4d/4d-simulation.js";

export function showCurrentTaskModal() {
  if (document.querySelector(".current-task-modal")) return;

  const todayStr = isoToday();

  const modal = document.createElement("div");
  modal.className = "current-task-modal";
  modal.tabIndex = 0;
  modal.innerHTML = `
    <div class="current-task-modal-header">
      <span class="modal-title">공정현황</span>
      <button type="button" class="modal-close" title="닫기" aria-label="닫기">×</button>
    </div>
    <div class="current-task-modal-body">
      <div class="current-task-date-row">
        <input type="text" class="current-task-date-input" maxlength="10" placeholder="yyyy-mm-dd" value="${todayStr}" autocomplete="off" />
        <button type="button" class="datepicker-btn" tabindex="-1" title="달력 열기">${calendarSvg}</button>
        <button type="button" class="btn-today" title="오늘로 이동">오늘</button>
      </div>

      <div class="current-task-slider-row">
        <input type="range" class="current-task-slider" min="-15" max="15" value="0" />
      </div>

      <div class="sim-toolbar" aria-label="시뮬레이션 컨트롤">
        <!-- 순서: ㅣ< , ㅁ , > , >ㅣ -->
        <button type="button" class="sim-btn sim-begin" title="5초 뒤로"   aria-label="5초 뒤로">${svgIcon('begin')}</button>
        <button type="button" class="sim-btn sim-stop"  title="정지/맨앞"  aria-label="정지/맨앞">${svgIcon('stop')}</button>
        <button type="button" class="sim-btn sim-play"  title="재생"      aria-label="재생">${svgIcon('play')}</button>
        <button type="button" class="sim-btn sim-end"   title="5초 앞으로" aria-label="5초 앞으로">${svgIcon('end')}</button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);

  applyInlineStyles(modal);
  centerModal(modal);

  const $input    = modal.querySelector(".current-task-date-input");
  const $btnCal   = modal.querySelector(".datepicker-btn");
  const $btnToday = modal.querySelector(".btn-today");
  const $close    = modal.querySelector(".modal-close");
  const $header   = modal.querySelector(".current-task-modal-header");
  const $slider   = modal.querySelector(".current-task-slider");

  const $btnBegin = modal.querySelector(".sim-begin"); // ㅣ< : 5초 '뒤로'
  const $btnPlay  = modal.querySelector(".sim-play");  // >
  const $btnStop  = modal.querySelector(".sim-stop");  // ㅁ
  const $btnEnd   = modal.querySelector(".sim-end");   // >ㅣ : 5초 '앞으로'

  const SIM = {
    playing: false,
    raf: 0,
    lastTs: 0,
    stepSec: 5,                                  // 버튼 스텝(초)
    speedDaysPerSec: window.SIM4D_SPEED_DAYS_PER_SEC ?? 1.0,
    zOffset: window.SIM4D_Z_OFFSET ?? 3.0,
    useDateDuration: (window.SIM4D_USE_DATE_DURATION ?? true) === true,
    fixedDurationSec: window.SIM4D_FIXED_DURATION_SEC ?? 2.0,
    minISO: null, maxISO: null,
    minMs: null,  maxMs: null,
    curMs: null,
    lastPolicyISO: null
  };

  // IMask
  let mask = null;
  if (window.IMask) mask = window.IMask($input, { mask: "0000-00-00", lazy: false, autofix: true });
  enforceSmartSelection($input);

  // flatpickr
  const fp = window.flatpickr($input, {
    dateFormat: "Y-m-d",
    defaultDate: todayStr,
    allowInput: true,
    clickOpens: false,
    onChange: (_, dateStr) => { if (isISO(dateStr)) setSimMs(Date.parse(dateStr), { apply: true, from: "flatpickr" }); }
  });

  $input.addEventListener("change", () => {
    const val = $input.value.trim();
    if (isISO(val)) setSimMs(Date.parse(val), { apply: true, from: "input-change" });
  });

  $btnCal.addEventListener("click", (e) => { e.stopPropagation(); fp.open(); });

  // 전체 기간 계산 → ±5일 확장
  const bounds = computeGlobalBoundsFromTaskData(window.taskTree?.getRootNode()?.children || []);
  let minISO = bounds.minISO, maxISO = bounds.maxISO;
  if (isISO(minISO)) minISO = addDaysISO(minISO, -5);
  if (isISO(maxISO)) maxISO = addDaysISO(maxISO, +5);

  SIM.minISO = minISO; SIM.maxISO = maxISO;
  SIM.minMs  = isISO(minISO) ? Date.parse(minISO) : null;
  SIM.maxMs  = isISO(maxISO) ? Date.parse(maxISO) : null;

  // 슬라이더 범위도 확장 값으로
  updateSliderRangeFromBounds(SIM.minISO, SIM.maxISO, $slider);

  $btnToday.addEventListener("click", () => {
    const dISO = clampISO(isoToday(), SIM.minISO, SIM.maxISO);
    setSimMs(Date.parse(dISO), { apply: true, from: "today" });
  });

  // 슬라이더(빠른 반응 + 디바운스 정책)
  const debouncedApply = debounce((iso) => applyByPolicy(iso, "slider-input", modal), 40);
  $slider.addEventListener("input", () => {
    const dISO = isoOffsetFromToday(parseInt($slider.value, 10));
    setSimMs(Date.parse(dISO), { apply: false, from: "slider-input" });
    debouncedApply(dISO);
  });
  $slider.addEventListener("change", () => {
    const dISO = isoOffsetFromToday(parseInt($slider.value, 10));
    setSimMs(Date.parse(dISO), { apply: true, from: "slider-change" });
  });

  enableModalDrag(modal, $header);

  // 닫기(완전 초기화)
  $close.addEventListener("click", (e) => { e.stopPropagation(); resetViewerAndCloseEx(modal, SIM); });
  modal.addEventListener("keydown", (ev) => { if (ev.key === "Escape") resetViewerAndCloseEx(modal, SIM); });

  // 컨트롤: 5초 스텝 = 5 * speedDaysPerSec * 86400000(ms)
  const stepMs = () => SIM.stepSec * SIM.speedDaysPerSec * 86400000;

  $btnBegin?.addEventListener("click", () => {
    const next = (SIM.curMs ?? Date.parse($input.value)) - stepMs();
    setSimMs(next, { apply: true, from: "nudge-back" });
  });

  $btnEnd?.addEventListener("click", () => {
    const next = (SIM.curMs ?? Date.parse($input.value)) + stepMs();
    setSimMs(next, { apply: true, from: "nudge-forward" });
  });

  $btnStop?.addEventListener("click", () => {
    if (SIM.playing) {
      SIM.playing = false;
      if (SIM.raf) cancelAnimationFrame(SIM.raf);
      SIM.raf = 0;
    } else if (SIM.minMs != null) {
      setSimMs(SIM.minMs, { apply: true, from: "stop-reset" });
    }
  });

  $btnPlay?.addEventListener("click", () => {
    if (SIM.playing) return;
    if (SIM.curMs == null) SIM.curMs = Date.parse($input.value);
    if (SIM.maxMs != null && SIM.curMs >= SIM.maxMs && SIM.minMs != null) {
      setSimMs(SIM.minMs, { apply: true, from: "play-reset" });
    }
    SIM.playing = true;
    SIM.lastTs = performance.now();
    SIM.raf = requestAnimationFrame(loop);
  });

  // 최초 상태: 오늘(클램프)
  {
    const initISO = clampISO(todayStr, SIM.minISO, SIM.maxISO);
    setSimMs(Date.parse(initISO), { apply: true, from: "init" });
  }

  // ───────── 재생 루프 ─────────
  function loop(now){
    if (!SIM.playing) return;
    const dtSec = Math.max(0, (now - SIM.lastTs) / 1000);
    SIM.lastTs = now;

    let nextMs = (SIM.curMs ?? Date.parse($input.value)) + dtSec * SIM.speedDaysPerSec * 86400000;
    if (SIM.minMs != null) nextMs = Math.max(nextMs, SIM.minMs);
    if (SIM.maxMs != null) nextMs = Math.min(nextMs, SIM.maxMs);

    // 끝 도달 시 정지
    if (SIM.maxMs != null && nextMs >= SIM.maxMs && SIM.curMs >= SIM.maxMs) {
      SIM.playing = false;
      if (SIM.raf) cancelAnimationFrame(SIM.raf);
      SIM.raf = 0;
      return;
    }
    setSimMs(nextMs, { apply: true, from: "play" });
    SIM.raf = requestAnimationFrame(loop);
  }

  // 내부 시계(ms) → UI/정책/4D 반영
  function setSimMs(ms, { apply = true, from = "" } = {}) {
    if (!Number.isFinite(ms)) return;
    if (SIM.minMs != null && ms < SIM.minMs) ms = SIM.minMs;
    if (SIM.maxMs != null && ms > SIM.maxMs) ms = SIM.maxMs;
    SIM.curMs = ms;

    const iso = msToISO(ms);
    setDateInput(iso, { apply, from });
  }

  // 날짜 입력 반영
  function setDateInput(dateStr, { apply = true, from = "" } = {}) {
    const safe = clampISO(dateStr, SIM.minISO, SIM.maxISO);
    $input.value = safe;
    if (mask) { try { mask.updateValue(); } catch(_) {} }
    syncSliderFromDate($slider, safe);

    if (apply) {
      // 정책은 '날짜'가 바뀔 때만 갱신(성능)
      if (safe !== SIM.lastPolicyISO) {
        applyByPolicy(safe, from, modal);
        SIM.lastPolicyISO = safe;
      }
      // 4D는 프레임마다 ms 기반으로 부드럽게
      try {
        apply4DAtMs(window.viewer, SIM.curMs, {
          zOffset: SIM.zOffset,
          useDateDuration: SIM.useDateDuration,
          fixedDurationSec: SIM.fixedDurationSec,
          speedDaysPerSec: SIM.speedDaysPerSec,
          syncThemingAlpha: true
        });
      } catch (e) {
        console.warn("[4D] apply error:", e);
      }
    }
  }
}

/* ───────── 정책 등 보조 코드(기존 유지) ───────── */
function applyByPolicy(dateStr, source, ctxEl){
  const v = window.viewer; const tree = window.taskTree;
  if (!v || !tree || !isISO(dateStr)) return;

  const model = (v.getVisibleModels && v.getVisibleModels()[0]) || v.model;
  if (!model) return;

  const urnCur = String(window.CURRENT_MODEL_URN || "");
  const showSet  = new Set();
  const hideSet  = new Set();
  const themeC   = new Set(); // green
  const themeT   = new Set(); // blue
  const themeD   = new Set(); // red

  const inRange = (d, s, e) => (isISO(s) && isISO(e) && d >= s && d <= e);
  const beforeS = (d, s)     => (isISO(s) && d < s);
  const afterE  = (d, e)     => (isISO(e) && d > e);

  tree.getRootNode()?.visit((n) => {
    const d = n.data || {};
    const cat = normCat(d.selectedOption);
    if (!cat) return;

    const objs = Array.isArray(d.linkedObjects) ? d.linkedObjects : [];
    for (const o of objs) {
      const urn = String(o.urn || urnCur);
      if (!urnCur || urn !== urnCur) continue;
      const id = Number(o.dbId);
      if (!Number.isFinite(id)) continue;

      if (cat === "C") {
        if (beforeS(dateStr, d.start)) { hideSet.add(id); }
        else if (inRange(dateStr, d.start, d.end)) { showSet.add(id); themeC.add(id); }
        else if (afterE(dateStr, d.end)) { showSet.add(id); }
        else { showSet.add(id); }
      } else if (cat === "T") {
        if (beforeS(dateStr, d.start)) { hideSet.add(id); }
        else if (inRange(dateStr, d.start, d.end)) { showSet.add(id); themeT.add(id); }
        else if (afterE(dateStr, d.end)) { showSet.add(id); }
        else { showSet.add(id); }
      } else if (cat === "D") {
        if (beforeS(dateStr, d.start)) { showSet.add(id); }
        else if (inRange(dateStr, d.start, d.end)) { showSet.add(id); themeD.add(id); }
        else if (afterE(dateStr, d.end)) { hideSet.add(id); }
        else { showSet.add(id); }
      }
    }
  });

  for (const id of showSet) hideSet.delete(id);

  try {
    if (!ctxEl.__simVisInit) {
      v.impl?.visibilityManager?.setAllOn?.();
      ctxEl.__simVisInit = true;
    }

    try { v.clearThemingColors?.(model); } catch(_) {}
    try { v.clearThemingColors?.(); } catch(_) {}

    const showArr = [...showSet];
    const hideArr = [...hideSet];
    if (showArr.length) v.show(showArr, model);
    if (hideArr.length) v.hide(hideArr, model);

    const V4 = (r,g,b,a=1) => (window.THREE ? new window.THREE.Vector4(r,g,b,a) : { r,g,b,a });
    const cGreen = V4(0.16, 0.57, 0.20, 1);
    const cBlue  = V4(0.12, 0.45, 0.90, 1);
    const cRed   = V4(0.95, 0.27, 0.23, 1);

    const paintChunk = (ids, color) => {
      const CHUNK = 4000;
      for (let i = 0; i < ids.length; i += CHUNK) {
        const slice = ids.slice(i, i + CHUNK);
        for (let j = 0; j < slice.length; j++) {
          v.setThemingColor(slice[j], color, model);
        }
      }
    };
    if (themeC.size) paintChunk([...themeC], cGreen);
    if (themeT.size) paintChunk([...themeT], cBlue);
    if (themeD.size) paintChunk([...themeD], cRed);

    v.impl?.sceneUpdated?.(true);
    v.impl?.invalidate?.(true, true, true);
  } catch (err) {
    console.warn("[CurrentTask] policy apply error", err);
  }
}

/* ───────── 스타일/유틸 ───────── */
// ... (기존 applyInlineStyles, centerModal, svgIcon, etc. 동일)
// 아래 유틸만 추가/수정된 부분 포함

function msToISO(ms){ return new Date(ms).toISOString().slice(0,10); }
function addDaysISO(iso, days){
  const d = new Date(iso + "T00:00:00Z");
  d.setUTCDate(d.getUTCDate() + (Number(days)||0));
  return d.toISOString().slice(0,10);
}
function updateSliderRangeFromBounds(minISO, maxISO, sliderEl){
  if (!sliderEl || !isISO(minISO) || !isISO(maxISO)) return;
  const t = isoToday();
  const diffMin = Math.ceil((Date.parse(minISO) - Date.parse(t)) / 86400000);
  const diffMax = Math.ceil((Date.parse(maxISO) - Date.parse(t)) / 86400000);
  sliderEl.min = String(diffMin);
  sliderEl.max = String(diffMax);
  sliderEl.value = "0";
}

/* debounce */
function debounce(fn, ms){
  let t=0;
  return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
}
