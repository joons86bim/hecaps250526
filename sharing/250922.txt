// 루트가 비어있지 않을 때까지 짧게 재시도
async function waitForNonEmptyRoots(provider, { tries = 5, idleMs = 120 } = {}) {
  let roots = [];
  for (let i = 0; i < tries; i++) {
    try { roots = await provider.roots(); } catch { roots = []; }
    if (Array.isArray(roots) && roots.length > 0) return roots;
    await waitIdle(idleMs);
  }
  // 그래도 비면 마지막 값(또는 []) 반환
  return Array.isArray(roots) ? roots : [];
}

// Fancytree 초기화 직후 현황 카운트 더블 패스 (무조건 2회)
// 0 0 0 이더라도 "정의되면 OK"로 간주 → '…' 잔상 제거
async function wbsPostInit(provider) {
  const tree = $.ui.fancytree.getTree("#wbs-tree");
  const D = window.__WBS_DEBUG;
  if (!tree || !D?.ensureCountsForAllRoots) return;

  await D.ensureCountsForAllRoots(tree, provider);
  try { tree.render(true, true); } catch {}

  await waitIdle(100);

  await D.ensureCountsForAllRoots(tree, provider);
  try { tree.render(true, true); } catch {}
}


await initWbsPanelWithFancytree(wbsProvider, {
  primaryOrder: ["HEC.WBS","HEC.Level","HEC.Zone"]
});
console.log("[STEP 5] WBS fancytree init OK");

// ✅ 초기 집계는 무조건 2회 돌린다 (idempotent)
//    첫 패스: 빠른 준비 / 둘째 패스: 비동기 인덱싱 지연 흡수
try {
  await wbsPostInit(wbsProvider);
} catch (e) {
  console.warn("[WBS] wbsPostInit failed:", e);
}
