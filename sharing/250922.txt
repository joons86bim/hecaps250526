좋아—세이프 모드에서 안 멈추는 걸 확인했으니, 이제 “어디서 멈추는지”를 단계별로 확실히 좁혀가자. 아래 순서대로 한 단계씩만 해제 → 테스트 해줘. 각 단계는 main.js의 모델 선택 콜백 내부(= initTree("#tree", async (versionId) => { ... }) 안)에서 주석 해제/추가만 하면 돼. 내가 붙여둔 // STEP n: 주석을 그대로 써서 관리하면 편해.


---

1) Task만 켜기 (WBS/간트는 계속 OFF)

하는 곳: initTree 콜백 안, await waitViewerReady(viewer); 바로 아래

// STEP 1: Task 패널만 켠다 (버튼 포함). 실패해도 앱이 죽지 않게 try/catch
try {
  initTaskPanel(taskData);
  initTaskListButtons();
  console.log("[STEP 1] Task panel OK");
} catch (e) {
  console.warn("[STEP 1] Task init failed:", e);
}

여기서 안 멈추면 → 2단계로.



---

2) panel2-ready 이벤트만 켜서 간트 쪽 확인

하는 곳: 같은 콜백, STEP 1 바로 아래

// STEP 2: panel2-ready를 발행해서 index.html의 간트 초기화가 수행되게 한다.
try {
  window.dispatchEvent(new Event("panel2-ready"));
  console.log("[STEP 2] panel2-ready dispatched");
} catch (e) {
  console.warn("[STEP 2] panel2-ready failed:", e);
}

여기서 멈추면 간트 초기화가 원인.

안 멈추면 → 3단계로.



---

3) WBS provider만 생성 (warmup/트리 미실행)

하는 곳: 같은 콜백, STEP 2 아래

// STEP 3: WBS provider만 만든다. 트리/워밍업은 아직 안 함.
let wbsProvider = null;
try {
  const { provider } = await buildWbsProviderLazy(viewer, {
    source: "all",
    bucketThreshold: 400,
    bucketSize: 200
  });
  wbsProvider = provider;
  console.log("[STEP 3] WBS provider OK");
} catch (e) {
  console.warn("[STEP 3] WBS provider failed:", e);
}

여기서 멈추면 provider 빌드가 원인 (속도 이슈 또는 내부 비동기 루프).

안 멈추면 → 4단계로.



---

4) WBS 워밍업을 아주 약하게만 실행

하는 곳: 같은 콜백, STEP 3 아래

// STEP 4: 워밍업 (Depth 2, Cap 200으로 아주 작게)
try {
  if (wbsProvider) {
    const roots = await wbsProvider.roots();
    let q = roots.map(r => ({ path: [r.text], depth: 1 }));
    let c = 0;
    while (q.length && c < 200) {
      const { path, depth } = q.shift();
      if (depth >= 2) continue;
      const kids = await wbsProvider.childrenByPath(path);
      c += kids.length;
      kids.forEach(k => q.push({ path: [...path, k.text], depth: depth + 1 }));
    }
    console.log("[STEP 4] WBS warmup OK (depth<=2, cap<=200)");
  }
} catch (e) {
  console.warn("[STEP 4] WBS warmup failed:", e);
}

여기서 멈추면 워밍업 루프가 원인 → cap/depth 더 줄이고, 나중에 완전 제거도 고려.

안 멈추면 → 5단계로.



---

5) WBS 트리(Fancytree) 초기화 (최소 설정)

> 중요: extensions 배열에 checkbox를 넣지 마세요! 체크박스는 옵션입니다.
extensions: ["table","gridnav"] + checkbox:true 만 두면 됩니다.
예전에 멈춤/에러의 직접 원인이 여기였어요.



하는 곳: 같은 콜백, STEP 4 아래

// STEP 5: Fancytree WBS 초기화 (최소 옵션)
try {
  await initWbsPanelWithFancytree(wbsProvider, {
    primaryOrder: ["HEC.WBS","HEC.Level","HEC.Zone"]
  });
  console.log("[STEP 5] WBS fancytree init OK");
} catch (e) {
  console.warn("[STEP 5] WBS fancytree init failed:", e);
}

여기서 멈추면 트리 초기화/렌더 핸들러가 원인.



---

6) (필요 시) Resizer 다시 활성화

세로 분할 리사이저가 레이아웃 루프를 만들 가능성도 있어서, 맨 마지막에 다시 켭니다.

// STEP 6: 패널2 리사이저 복귀 (문제 없을 때)
try {
  bindPanel2Resizer(viewer);
  console.log("[STEP 6] panel2 resizer bound");
} catch (e) {
  console.warn("[STEP 6] resizer bind failed:", e);
}


---

WBS 트리 쪽 “정지” 예방 패치 (이미 반영했으면 패스)

이건 main.js 외 코드지만, 이전 프리즈의 흔한 두 원인을 한 번에 잡아줍니다.
다음 2가지만 fancy-tree-init.js에서 꼭 확인:

1. extensions에 ‘checkbox’를 넣지 않는다.



$("#wbs-tree").fancytree({
  extensions: ["table", "gridnav"], // ✅ 여기!
  checkbox: true,                   // ✅ 옵션으로만
  selectMode: 3,
  // ...
});

2. tree.renderRows()를 쓰지 말고, 모두 data.tree.render(true, true) 로 바꿔주세요.
(네 코드에서 과거에 이게 있었던 걸 봤어. 없는 메서드라 멈추기도 함)



// (예) 계산 완료 후 전체 갱신
// BAD: tree.renderRows();
data.tree.render(true, true);


---

왜 이 순서인가?

Task만 → 간트만 → Provider만 → 워밍업만 → 트리 → 리사이저
이렇게 켜면 한 번에 원인이 보입니다.

특히 Fancytree는 확장/렌더 타이밍에 무한 다시그리기 루프를 만들 수 있어요.
위의 작은 가이드(checkbox 확장 제거, renderRows 미사용)만으로도 프리즈가 쭉 사라집니다.



---

진행하면서 체크할 콘솔 로그

각 STEP에서 console.log 찍히는지 무조건 확인해줘.

마지막 로그가 어느 STEP인지 알려주면, 그 블록만 파고들어서 고쳐줄게.


필요하면 해당 단계에서 딱 그 파일(예: fancy-tree-init.js)만 붙여줘도 돼.

