// cross-version FragmentList getter
function getFragList(viewer, model) {
  if (model?.getFragmentList) return model.getFragmentList();        // 권장
  if (viewer?.model?.getFragmentList) return viewer.model.getFragmentList(); // 대체
  // (아주 구버전) viewer.impl.getFragmentList가 있을 수도 있으나 현재 없음
  return null;
}


function prepareFragStates(viewer, model, fragIds) {
  const THREE = window.THREE || Autodesk.Viewing.THREE;
  const matman = viewer.impl.matman?.(); // 없으면 undefined
  const fragList = getFragList(viewer, model); // ★ 여기!
  const store = [];

  // fragId -> dbId 매핑
  const fragToDb = {};
  if (!fragList) {
    console.warn('[test-btn] FragmentList not available.');
  } else {
    fragIds.forEach((fragId) => {
      try { fragToDb[fragId] = fragList.getDbId(fragId); } catch(_) {}
    });
  }

  for (const fragId of fragIds) {
    const proxy = viewer.impl.getFragmentProxy(model, fragId);
    proxy.getAnimTransform();
    const startPos = new THREE.Vector3(proxy.position.x, proxy.position.y, proxy.position.z);

    const rp = viewer.impl.getRenderProxy(model, fragId);
    const originalMat = rp?.material || null;

    let origColor = null;
    if (originalMat?.color) origColor = originalMat.color.clone();

    // 머티리얼 클론(공유 차단) + 투명세팅
    let cloneMat = null;
    if (originalMat) {
      cloneMat = matman?.cloneMaterial ? matman.cloneMaterial(originalMat) : originalMat.clone();
      cloneMat.transparent = true;
      cloneMat.opacity = 1.0;
      cloneMat.depthWrite = false;
      cloneMat.needsUpdate = true;

      // ★ 핵심: setMaterial 경로 우선 → 불가 시 fragList.setMaterial
      if (viewer.impl.setMaterial) {
        viewer.impl.setMaterial(model, fragId, cloneMat);
      } else if (fragList?.setMaterial) {
        fragList.setMaterial(fragId, cloneMat);
      } else if (viewer.impl.setFragmentMaterial) {
        viewer.impl.setFragmentMaterial(fragId, cloneMat); // 레거시
      }
    }

    store.push({
      model, fragId, dbId: fragToDb[fragId],   // ★ model을 보관해 둠
      proxy, startPos,
      renderProxy: rp,
      originalMat, cloneMat,
      origColor,
      themingSupported: Number.isInteger(fragToDb[fragId])
    });
  }
  viewer.impl.invalidate(true, true, true);
  return store;
}



function restoreFragStates(viewer, store) {
  const model = store[0]?.model;
  const fragList = getFragList(viewer, model);
  const byModel = {};

  for (const f of store) {
    // 위치 원복
    f.proxy.position.copy(f.startPos);
    f.proxy.updateAnimTransform();

    // 머티리얼 원복
    if (f.originalMat) {
      if (viewer.impl.setMaterial) {
        viewer.impl.setMaterial(f.model, f.fragId, f.originalMat);
      } else if (fragList?.setMaterial) {
        fragList.setMaterial(f.fragId, f.originalMat);
      } else if (viewer.impl.setFragmentMaterial) {
        viewer.impl.setFragmentMaterial(f.fragId, f.originalMat);
      }
    }
    if (f.cloneMat?.dispose) f.cloneMat.dispose();

    // 테마컬러 제거용 수집
    if (f.themingSupported) {
      byModel[f.model?.id || 0] ||= [];
      byModel[f.model?.id || 0].push(f.dbId);
    }
  }

  // 테마컬러 일괄 제거
  Object.keys(byModel).forEach(() => {
    const ids = byModel[model?.id || 0] || [];
    ids.forEach((dbId) => viewer.clearThemingColor(dbId, model));
  });

  viewer.impl.invalidate(true, true, true);
}