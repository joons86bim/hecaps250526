} else {
        const key  = node.data?.pathKey;

        //2-0 숫자 먼저 확보 (부모 직접값이 0이면 서브트리 합계 폴백 사용)
        let counts = key && getCounts(key);
        let sum0 = counts ? ((counts.c || 0) + (counts.t || 0) + (counts.d || 0)) : 0;
        if ((!counts || sum0 === 0) && node.data?.__aggCounts) {
          counts = node.data.__aggCounts;
          sum0 = (counts.c || 0) + (counts.t || 0) + (counts.d || 0);
        }
        
        //2-1 상태(색칠) = counts로 판정
        const st   = calcStateByCounts(counts);
        const cls  = stateToClass(st);
        $(node.tr).removeClass("wbs-c wbs-t wbs-d wbs-td");
        if (cls) $(node.tr).addClass(cls);
        
        //2-2 숫자 렌더
        const agg   = node.data.__aggCounts;

        if ((!counts || sum3(counts) === 0) && agg && sum3(agg) > 0) {
          counts = agg;
        }

        if (counts && (typeof counts.c === "number" || typeof counts.t === "number" || typeof counts.d === "number")) {
          $statusCell
            .addClass("text-center")
            .html(`
              <div class="wbs-status" style="justify-content: center;">
                <div class="nums">
                  <span class="b c" title="시공">${counts.c ?? 0}</span>
                  <span class="b t" title="가설">${counts.t ?? 0}</span>
                  <span class="b d" title="철거">${counts.d ?? 0}</span>
                </div>
              </div>
            `);
        } else {
          $statusCell.text("…");
          if (!node.data.__countsRequested && key) {
            node.data.__countsRequested = true;
            ensureCountsForNode(node)
              .then(() => { try { node.render(true); } catch {} })
              .finally(() => { node.data.__countsRequested = false; });
          }
        }
        
        // --- 숫자/상태 불일치 자동 복구 (1회) ---
        if (key) {
          const total = counts ? ((counts.c || 0) + (counts.t || 0) + (counts.d || 0)) : 0;
          const likelyWrong =
            ((node.data?.leafCount || 0) > 0) &&
            total === 0 &&
            !node.data.__countsRepairOnce;
            if (likelyWrong) {
              node.data.__countsRepairOnce = true;
              ensureCountsForSubtree(provider, node)
                .then(() => { try { node.render(true); } catch {} })
                .finally(() => { node.data.__countsRepairOnce = false; } );
            }
        }
      }
