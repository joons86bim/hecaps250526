function keyDepth(k){ return (k?.split("¦") || []).length; }

function addCounts(dst, src){
  if (!src) return;
  dst.c = (dst.c || 0) + Number(src.c || 0);
  dst.t = (dst.t || 0) + Number(src.t || 0);
  dst.d = (dst.d || 0) + Number(src.d || 0);
}

// 화면 표시용으로 td를 T/D에 반영
function toDisplayCounts(raw){
  if (!raw) return null;
  const td = Number(raw.td || 0);
  return {
    c: Number(raw.c || 0),
    t: Number(raw.t || 0) + td,
    d: Number(raw.d || 0) + td,
  };
}

// “데이터가 있나?” 판정할 때 td도 포함해야 함
function sum3(x){
  return Number(x?.c || 0) + Number(x?.t || 0) + Number(x?.d || 0) + Number(x?.td || 0);
}



async function ensureCountsForSubtree(provider, node){
  const key  = node?.data?.pathKey;
  const path = node?.data?.__path || buildPathFromNode(node);
  if (!key || !path) return;

  if (_subtreeBusy.has(key)) return; // 중복 실행 방지
  _subtreeBusy.add(key);

  try {
    const keys = await collectAllPathKeys(provider, path);
    const uniq = Array.from(new Set(keys.length ? keys : [key]));

    if (uniq.length) {
      // 1) 보장 + 상태계산
      await bulkEnsureForVisible(uniq);
      uniq.forEach(k => computePathState(k));

      // 2) 가장 깊은 레벨의 counts만 모아서 합산 (중복합산 방지)
      const levels = new Map(); // depth -> rawCounts[]
      for (const k of uniq){
        const c = getCounts(k);
        if (c && sum3(c) > 0){
          const d = keyDepth(k);
          if (!levels.has(d)) levels.set(d, []);
          levels.get(d).push(c);
        }
      }

      let totals = { c: 0, t: 0, d: 0 };
      if (levels.size){
        const depths = Array.from(levels.keys()).sort((a,b)=>a-b);
        const deepest = depths[depths.length - 1];

        // 화며 표시 기준: td를 T/D 양쪽에 더해준다
        for (const raw of (levels.get(deepest) || [])) {
          const disp = toDisplayCounts(raw);
          addCounts(totals, disp);
        }
      }
      node.data.__aggCounts = totals; // 폴백 합계 저장
    }

    try { node.render(true); } catch {}
  } finally {
    setTimeout(() => _subtreeBusy.delete(key), 50);
  }
}



// 2-2 카운트 렌더: getCounts → 화면표시 변환(toDisplayCounts) + __aggCounts 폴백
const raw = key && getCounts(key);
let counts = toDisplayCounts(raw);

if ((!counts || sum3(counts) === 0) && node.data.__aggCounts) {
  counts = node.data.__aggCounts; // 서브트리 집계 폴백 사용
}

if (counts && (typeof counts.c === "number" || typeof counts.t === "number" || typeof counts.d === "number")) {
  $statusCell
    .addClass("text-center")
    .html(`
      <div class="wbs-status" style="justify-content: center;">
        <div class="nums">
          <span class="b c" title="시공">${counts.c ?? 0}</span>
          <span class="b t" title="가설">${counts.t ?? 0}</span>
          <span class="b d" title="철거">${counts.d ?? 0}</span>
        </div>
      </div>
    `);
} else {
  $statusCell.text("…");
  if (!node.data.__countsRequested && key) {
    node.data.__countsRequested = true;
    ensureCountsForNode(node)
      .then(() => { try { node.render(true); } catch {} })
      .finally(() => { node.data.__countsRequested = false; });
  }
}



const D = window.__WBS_DEBUG;
const t = D.tree();
const n = t.getRootNode().children[1];

const keys = await D.collectAllPathKeys(D.provider, n.data.__path);
await D.bulkEnsureForVisible(keys);
keys.forEach(D.computePathState);

await D.ensureCountsForSubtree(D.provider, n);

console.log("raw on top =", D.getCounts(n.data.pathKey));     // {total, c, t, d, td}
console.log("agg on top =", n.data.__aggCounts);               // {c, t, d} (td 반영된 숫자)

t.render(true);