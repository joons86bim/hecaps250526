좋아—import 라인은 전혀 건드리지 않고, 현재 폴더/파일 구조 그대로 쓴다는 전제로, main.js에 “멈춤/응답없음 방지 + 로딩팝업 완전 비활성 + 카메라 줌인 보장”을 넣는 안전 패치를 “삽입 위치 기준”으로 딱 정리해 줄게.
(그대로 복붙하면 됩니다. import 라인 아래/뷰어 생성 직후/기존 호출부 교체 3곳만 만지면 끝!)


---

① import 라인 바로 아래에 “공통 유틸+스위치” 추가

(당신 파일의 import 구문 바로 다음 줄에 통째로 붙여넣기)

// === [SAFE PATCH 1/3] 공통 유틸 + 스위치 (imports 바로 아래) ==================

// lodash 없이도 안전하게 동작하는 throttle
const throttle = (window._?.throttle)
  ? window._.throttle
  : (fn, wait = 200) => {
      let last = 0, t = null, lastArgs;
      return (...args) => {
        const now = Date.now();
        lastArgs = args;
        if (now - last >= wait) { last = now; fn(...lastArgs); }
        else {
          clearTimeout(t);
          t = setTimeout(() => { last = Date.now(); fn(...lastArgs); }, wait - (now - last));
        }
      };
    };

// invalidate 폭주 방지: 한 프레임에 1회만 실제 invalidate
function withViewerBatch(viewer, work) {
  let invalid = false;
  const orig = viewer.impl.invalidate.bind(viewer.impl);
  viewer.impl.invalidate = () => { invalid = true; };
  try { work(); }
  finally {
    viewer.impl.invalidate = orig;
    if (invalid) requestAnimationFrame(() => orig(true, true, true));
  }
}

// 동시 로드 경쟁상태(race) 방지용 토큰
let __LOAD_TOKEN__ = 0;

// 로딩 오버레이 끄기/켜기 스위치 (지금은 끔)
const USE_LOADING_OVERLAY = false;

// 오버레이 호출부가 남아 있어도 터지지 않게 하는 no-op
const overlayNoop = { beginLoadFor() {}, setMessage() {}, finishFor() {} };
// 전역 핸들(초기값은 no-op)
let progressOverlay = overlayNoop;

// 전역 오류 로그(첫 에러 포착용, 선택)
window.addEventListener('error', e => console.error('[WindowError]', e.error || e.message));
window.addEventListener('unhandledrejection', e => console.error('[UnhandledRejection]', e.reason));
// =============================================================================


---

② viewer를 만들고 난 직후(initViewer 호출 바로 다음)에 두 블록 추가

뷰어 생성 코드(예: const viewer = await initViewer(...);) 바로 아래에 붙여넣기:

// === [SAFE PATCH 2/3] viewer 생성 직후에 넣기 ================================

// 지오메트리 로드 시 카메라 자동 맞춤 (1회)
viewer.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, () => {
  requestAnimationFrame(() => {
    try { viewer.fitToView(true); } catch (e) { console.warn('fitToView failed', e); }
  });
}, { once: true });

// 로딩 오버레이 확장: 스위치가 켜진 경우에만 실제 로드
if (USE_LOADING_OVERLAY) {
  try {
    // CSS/확장 경로는 기존 프로젝트의 경로를 사용하세요.
    // 예) ensureCss('/css/05-hec-progress-overlay.css'); // 프로젝트에 있으면 유지
    await import('./viewer/hec.ProgressOverlay.js');   // 현재 경로에 맞게
    const ext = await viewer.loadExtension?.('hec.ProgressOverlay', {
      startVisible: false,
      autoHideOnGeometryLoaded: true,
      autoHideDelayMs: 900,
      clickToDismiss: true,
      useToastOnDone: false,      // 완료 토스트 비활성
      keepAlive: 'off',
    });
    if (ext) progressOverlay = ext;
  } catch (e) {
    console.warn('ProgressOverlay disabled, fallback to noop.', e);
    progressOverlay = overlayNoop;
  }
}

// 디버그/전역 접근을 유지하고 싶다면 노출(노출이 불필요하면 제거)
window.progressOverlay = progressOverlay;
// =============================================================================

> 위 블록은 import 경로/파일명 안 건드립니다. 현재 프로젝트의 hec.ProgressOverlay.js 실제 위치가 다르면 그 상대경로만 맞춰주세요. (예: ../viewer/extensions/hec.ProgressOverlay.js 등)




---

③ 기존 코드 중 세 군데 패턴만 “안전 호출”로 교체

검색/치환으로 한 번에 끝납니다. (import는 그대로 두세요)

(A) 시작 표시(있다면)

- const ov = viewer.getExtension('hec.ProgressOverlay');
- ov?.beginLoadFor(urn, '모델을 로드하는 중입니다…');
+ const ov = progressOverlay; // 공용 핸들
+ ov.beginLoadFor?.(urn, '모델을 로드하는 중입니다…');   // 안전 호출

(B) 중간 메시지(있다면)

- progressOverlay.setMessage('WBS 준비 중…');
+ progressOverlay.setMessage?.('WBS 준비 중…');           // 안전 호출

(C) 완료 처리(있다면)

- progressOverlay.finishFor(urn, '모델 로딩이 완료되었습니다.');
+ progressOverlay.finishFor?.(urn, '모델 로딩이 완료되었습니다.'); // 안전 호출

> 팁: 파일 전체에서 getExtension('hec.ProgressOverlay')가 보이면 모두 progressOverlay로 통일하세요. 그러면 USE_LOADING_OVERLAY=false일 때도 절대 죽지 않습니다.




---

④ “모델 선택 시” 콜백 안에 race 가드 2줄만 추가

모델 버전을 빠르게 바꿔도 이전 콜백이 끼어들지 못하게 합니다.

initTree("#tree", async (versionId) => {
  const MY = ++__LOAD_TOKEN__;          // [추가] 이 선택 시퀀스의 토큰

  // ... 기존 초기화/URN 계산/데이터 로딩 ...

  await loadModel(viewer, urn);
  if (MY !== __LOAD_TOKEN__) return;    // [추가] 더 최신 로드가 시작되면 중단

  // ... OBJECT_TREE_CREATED_EVENT 이후 proceed() 실행 ...
});

> proceed() 같은 내부 비동기 함수가 있다면 그 안에서도 첫 줄에 if (MY !== __LOAD_TOKEN__) return; 한 번 더 넣어주면 완벽합니다.




---

⑤ resize에 쓰던 _.throttle는 그대로 두고 래퍼만 적용

기존 코드가 아래처럼 되어 있다면:

window.addEventListener('resize', _.throttle(() => {
  // ...
}, 200));

이걸 한 줄만 바꿔주세요:

- window.addEventListener('resize', _.throttle(() => {
+ window.addEventListener('resize', throttle(() => {
    // ...
- }, 200));
+ }, 200));

> 위에서 만든 throttle은 lodash가 있으면 그걸 쓰고, 없어도 자체 폴리필로 안전하게 동작합니다.




---

⑥ (선택) 대량 색칠/가시성 갱신에 배치 적용

dbId 많이 만질 때 아래처럼 감싸면 프레임 드랍/멈춤 체감이 확 줄어요.

withViewerBatch(viewer, () => {
  // viewer.setThemingColor(...), viewer.hide(...), show(...), isolate(...) 등
  // 갱신을 모아서 실행 → 마지막에 한 번만 invalidate
});


---

요약

import 라인 고정(현재 구조 유지)

삽입 2곳: (1) import 아래 공통 유틸/스위치, (2) viewer 생성 직후 카메라/오버레이 조건부

치환 3곳: overlay 호출부를 progressOverlay.*?.(...)로 안전화

race 가드 2줄: 모델 선택 콜백 시작/완료 직전

resize는 throttle 래퍼로 교체(폴리필 내장)


이대로 반영하면 로딩창은 완전히 꺼진 상태로 유지되면서, 페이지 멈춤/응답없음 원인(로드 경쟁, invalidate 폭주, lodash 미존재)까지 같이 잡힙니다.
적용 후 콘솔에 특정 에러가 뜨면 그 한 줄만 복사해서 보여줘—그 줄 기준으로 정확한 수정(diff)까지 바로 찍어줄게.

