// 1) 태스크 → 상태별 dbId 세트 (부모 상태 상속 + 객체 status 우선 + 숫자형 dbId 강제)
function buildStatusSetsFromTasks(tasks) {
  const S = { C:new Set(), T:new Set(), D:new Set(), TD:new Set() };

  const norm = (code) => {
    if (!code) return "";
    const raw = String(code).trim();
    if (raw === "시공") return "C";
    if (raw === "가설") return "T";
    if (raw === "철거") return "D";
    return raw.toUpperCase(); // "C" | "T" | "D" | "TD" | "X" ...
  };

  const put = (status, idRaw) => {
    const id = Number(idRaw);
    if (!Number.isFinite(id)) return;
    if (status === "C") S.C.add(id);
    else if (status === "T") S.T.add(id);
    else if (status === "D") S.D.add(id);
    else if (status === "TD" || status === "X") S.TD.add(id);
  };

  const walk = (arr, inherited) => {
    (arr||[]).forEach(t => {
      const tStatus = norm(t.status || t.selectedOption || inherited);
      (t.linkedObjects||[]).forEach(o => {
        const oStatus = norm(o.status || tStatus);
        put(oStatus, o.dbId);
      });
      if (t.children) walk(t.children, tStatus);
    });
  };

  walk(tasks, "");
  return S;
}

// 2) 특정 경로(path) 집계(문자↔숫자 불일치 방지)
function calcCountsForPath(provider, path, S) {
  let ids = [];
  try { ids = provider.getDbIdsForPath(path, { includeDescendants:true, allowUnbuilt:true }) || []; }
  catch {}
  const set = new Set(ids.map(Number));
  const r = { total: set.size, c:0, t:0, d:0, td:0 };
  for (const id of set) {
    if (S.C.has(id))  r.c++;
    if (S.T.has(id))  r.t++;
    if (S.D.has(id))  r.d++;
    if (S.TD.has(id)) r.td++;
  }
  return r;
}

// 3) 트리 전체에 폴백 집계 주입 (+렌더 2회)
async function installFallbackCounts(tree, provider) {
  const tasks = window.__SAVED_TASKS || [];
  if (!tree || !provider || !tasks.length) return;

  const S = buildStatusSetsFromTasks(tasks);
  console.log("[FA] sets size =", { C:S.C.size, T:S.T.size, D:S.D.size, TD:S.TD.size });

  const visit = (node, path) => {
    const counts = calcCountsForPath(provider, path, S);
    node.data = node.data || {};
    node.data.__aggCounts = counts;              // ★ 폴백 카운트
    (node.children||[]).forEach(ch => {
      visit(ch, ch.data?.__path || [...path, ch.title]);
    });
  };

  const root = tree.getRootNode();
  (root.children||[]).forEach(n => visit(n, n.data?.__path || [n.title]));

  try { tree.render(true, true); } catch {}
  requestAnimationFrame(() => { try { tree.render(true, true); } catch {} });
  console.log("[FA] fallback counts installed");
}