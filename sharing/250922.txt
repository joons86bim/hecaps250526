ì˜¤ì¼€ì´. â€œTasks íƒ­ ì „í™˜ ì‹œ ë©ˆì¶¤â€ì„ WBS ì´ˆê¸°í™” íƒ€ì´ë° ë¶„ë¦¬ + ìœ íœ´ ì‹œê°„ ì˜ˆì•½ìœ¼ë¡œ í’€ì—ˆìŠµë‹ˆë‹¤.
ì•„ë˜ main.jsë§Œ êµì²´í•˜ë©´ ë©ë‹ˆë‹¤. (ì˜¤ë²„ë ˆì´ëŠ” ê³„ì† êº¼ë‘ , ì½”ë“œ ì¶”ê°€ëŠ” ìµœì†Œí™”)

ë¬´ì—‡ì´ ë‹¬ë¼ì¡Œë‚˜ (í•µì‹¬ 3ì¤„ ìš”ì•½)

WBS í”„ë¡œë°”ì´ë” ë¹Œë“œë¥¼ ëª¨ë¸ ë¡œë“œ ì§í›„ requestIdleCallbackìœ¼ë¡œ ë¯¸ë¦¬ ì‹œì‘(ë°±ê·¸ë¼ìš´ë“œ ëŠë‚Œ).

Tasks íƒ­ í´ë¦­ ì‹œ WBS UIë§Œ ì´ˆê¸°í™”(í”„ë¡œë°”ì´ë”ê°€ ì¤€ë¹„ë¼ ìˆìœ¼ë©´ ì¦‰ì‹œ, ì•„ë‹ˆë©´ ì¤€ë¹„ë˜ëŠ” ì¦‰ì‹œ).

warmup/ì˜¤ë²„ë ˆì´/ë¶ˆí•„ìš” ëŒ€ê¸° ì œê±°ë¡œ í”„ë¦¬ì¦ˆ ìš”ì¸ ìµœì†Œí™”.



---

// /wwwroot/js/main.js

import { initTabs } from "./sidebar/init-tabs.js";
import { initTree } from "./sidebar/init-tree.js";
import { initViewer, loadModel } from "./viewer/init-viewer.js";
import { buildWbsProviderLazy } from "./sidebar/task-wbs/wbs/loader.js";
import { bindPanel2Resizer } from "./sidebar/task-wbs/layout/panel-resizer.js";

// âœ… task-wbs í¼ì‚¬ë“œ
import {
  initTaskPanel,
  initTaskListButtons,
  setSavedTaskData,
  disableViewerEscReset,
  initWbsPanelWithFancytree,   // â† WBS ì´ˆê¸°í™”(ì§€ì—° í˜¸ì¶œ)
} from "./sidebar/index.js";

/* ==============================
   ìƒìˆ˜ & ìœ í‹¸
============================== */
const SIDEBAR_MIN = 360;
const SIDEBAR_DEFAULT = 900;
const PREVIEW_MIN = 520;

function onceViewer(viewer, type) {
  return new Promise((resolve) => {
    const h = () => { viewer.removeEventListener(type, h); resolve(); };
    viewer.addEventListener(type, h);
  });
}
function hasObjectTree(viewer) {
  return !!viewer.model?.getData?.()?.instanceTree;
}
async function waitObjectTree(viewer) {
  if (hasObjectTree(viewer)) return;
  await onceViewer(viewer, Autodesk.Viewing.OBJECT_TREE_CREATED_EVENT);
}

// â± GEOMETRY ë¡œë”©: 2ì´ˆ íƒ€ì„ì•„ì›ƒ(ì‹ í˜¸ ëˆ„ë½ì‹œ ì§„í–‰)
async function waitGeometry(viewer, timeoutMs = 2000) {
  await new Promise((resolve) => {
    let done = false;
    const h = () => { if (done) return; done = true;
      try { viewer.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, h); } catch {}
      resolve();
    };
    viewer.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, h, { once: true });
    setTimeout(h, timeoutMs);
  });
}
function waitIdle(timeout = 60) {
  return new Promise((resolve) => {
    if (typeof window.requestIdleCallback === "function") {
      window.requestIdleCallback(() => resolve(), { timeout });
    } else {
      setTimeout(resolve, timeout);
    }
  });
}
async function waitViewerReady(viewer) {
  await waitObjectTree(viewer);
  await waitGeometry(viewer);
  await waitIdle(60);
}

function initSidebarWidth() {
  const root = document.documentElement;
  const stored = parseInt(localStorage.getItem("sidebarWidthPx") || "0", 10);
  const maxNow = Math.max(SIDEBAR_MIN, window.innerWidth - PREVIEW_MIN);
  const initial = Number.isFinite(stored) && stored >= SIDEBAR_MIN
    ? Math.min(maxNow, stored)
    : Math.min(maxNow, SIDEBAR_DEFAULT);
  root.style.setProperty("--sidebar-width", initial + "px");
  return initial;
}

function resetViewerInputAndCamera(viewer) {
  try {
    const tc = viewer.toolController;
    if (tc?.isToolActivated?.("BoxSelectionTool")) tc.deactivateTool("BoxSelectionTool");
    viewer.setNavigationLock(false);
    viewer.setActiveNavigationTool?.(viewer.impl?.is2d ? "pan" : "orbit");
    viewer.setSelectionMode(Autodesk.Viewing.SelectionMode.MIXED);
    viewer.clearSelection?.();
    if (!viewer.impl?.is2d) {
      viewer.navigation.setWorldUpVector(new THREE.Vector3(0, 0, 1), true);
      const bb = viewer.model?.getBoundingBox?.();
      if (bb) {
        const c = bb.getCenter(new THREE.Vector3());
        viewer.navigation.setPivotPoint(c);
        viewer.navigation.setTarget(c);
      }
    }
    viewer.fitToView?.();
  } catch (e) { console.warn("[init] resetViewerInputAndCamera failed:", e); }
}

/* ==============================
   ì „ì—­ ìƒíƒœ/ìƒ˜í”Œ
============================== */
window.__ALLOW_WBS_UPDATE = false;

const login = document.getElementById("login");
let taskData = [];
let wbsProviderPromise = null;   // ğŸ”¸ ì§€ì—° ì¤€ë¹„ìš©: í”„ë¡œë°”ì´ë” Promise (ì „ì—­ 1ê°œ)

const SAMPLE_TASK_DATA = [
  {
    no: "1",
    selectOptions: ["ì‹œê³µ", "ê°€ì„¤", "ì² ê±°"],
    selectedOption: "ì‹œê³µ",
    title: "Task A",
    start: "2024-06-25",
    end: "2024-07-01",
    linkedObjects: [{ urn: "SAMPLE_URN", dbId: 1001, text: "ë²½ì²´1" }],
    children: [
      {
        no: "1.1",
        selectOptions: ["ì‹œê³µ", "ê°€ì„¤", "ì² ê±°"],
        selectedOption: "ì‹œê³µ",
        title: "Subtask A1",
        start: "2024-06-26",
        end: "2024-06-30",
        linkedObjects: [{ urn: "SAMPLE_URN", dbId: 1002, text: "ë²½ì²´2" }],
      },
    ],
  },
  { no: "2", selectOptions: ["ì‹œê³µ", "ê°€ì„¤", "ì² ê±°"], selectedOption: "ì‹œê³µ", title: "Task B", start: "", end: "", linkedObjects: [] },
];

function safeUrn(urn) { return urn.replace(/[^a-zA-Z0-9]/g, "_"); }
function fillUrnRecursive(task, defaultUrn) {
  if (Array.isArray(task.linkedObjects)) {
    task.linkedObjects.forEach((o) => { if (!o.urn) o.urn = defaultUrn || window.CURRENT_MODEL_URN; });
  }
  if (Array.isArray(task.children)) task.children.forEach((ch) => fillUrnRecursive(ch, defaultUrn));
}

/* ==============================
   ë¦¬ì‚¬ì´ì¦ˆ(ì“°ë¡œí‹€)
============================== */
window.addEventListener("resize", _.throttle(() => {
  try {
    initSidebarWidth();
    window.viewer?.resize?.();
    window.viewer?.impl?.invalidate?.(true, true, true);
    if (window.gantt && window.taskTree) {
      window.gantt.renderFromTrees(window.taskTree, window.wbsTree);
    }
  } catch (e) { console.warn("[resize] redraw failed", e); }
}, 120));

/* ==============================
   ì•± ì „ì²´ ì´ˆê¸°í™”
============================== */
(async function () {
  try {
    // 1) ë¡œê·¸ì¸ ì²´í¬
    const resp = await fetch("/api/auth/profile", { credentials: "include" });
    if (!resp.ok) { window.location.replace("/api/auth/login"); return; }
    const user = await resp.json();
    login.innerText = `Logout (${user.name})`;
    login.onclick = () => {
      const iframe = document.createElement("iframe");
      iframe.style.visibility = "hidden";
      iframe.src = "https://accounts.autodesk.com/Authentication/LogOut";
      document.body.appendChild(iframe);
      iframe.onload = () => {
        window.location.replace("/api/auth/logout");
        document.body.removeChild(iframe);
      };
    };

    // 2) ë ˆì´ì•„ì›ƒ í‘œì‹œ & ì‚¬ì´ë“œë°” ì´ˆê¸°í­ ë°˜ì˜
    const Sidebar = document.getElementById("sidebar");
    const Header  = document.getElementById("header");
    const Preview = document.getElementById("preview");
    const sidebarResizer = document.getElementById("sidebar-resizer");
    const Loading = document.getElementById("loading");

    Sidebar.style.display = "";
    sidebarResizer.style.display = "";
    Preview.style.display = "";
    Header.style.display = "";
    Loading.style.display = "none"; // â›”ï¸ ë¡œë”©ì°½ ê°•ì œ ìˆ¨ê¹€
    login.style.visibility = "visible";

    Sidebar.style.removeProperty("width");
    Preview.style.removeProperty("left");
    sidebarResizer.style.removeProperty("left");

    initSidebarWidth();

    // 3) íƒ­/ë·°ì–´ ì´ˆê¸°í™”
    initTabs("#sidebar");
    const viewerHost = document.getElementById("viewer-host");
    const viewer = await initViewer(viewerHost);
    window.viewer = viewer;
    disableViewerEscReset(viewer);

    // â›”ï¸ ProgressOverlay ê´€ë ¨ ì „ë¶€ ë¹„í™œì„±í™”(ì£¼ì„ ìœ ì§€)

    bindPanel2Resizer(viewer);

    viewer.resize();
    viewer.impl?.invalidate?.(true, true, true);
    requestAnimationFrame(() => { try { viewer.resize(); viewer.impl?.invalidate?.(true, true, true); } catch {} });

    resetViewerInputAndCamera(viewer);

    requestAnimationFrame(() => {
      const sb = document.getElementById("sidebar");
      if (sb && sb.offsetWidth === 0) {
        document.documentElement.style.setProperty("--sidebar-width", SIDEBAR_DEFAULT + "px");
        viewer.resize();
        viewer.impl?.invalidate?.(true, true, true);
      }
    });

    // 4) í”„ë¡œì íŠ¸ íŠ¸ë¦¬ ì´ˆê¸°í™”(ëª¨ë¸ ì„ íƒ ì½œë°±)
    initTree("#tree", async (versionId) => {
      destroyTaskPanel();

      const urn = window.btoa(versionId).replace(/=/g, "");
      window.CURRENT_MODEL_URN = urn;
      window.CURRENT_MODEL_SAFE_URN = safeUrn(urn);

      taskData.length = 0;
      setSavedTaskData([]);
      await loadTaskDataIfExists();
      taskData.forEach((t) => fillUrnRecursive(t, urn));

      console.log("[main.js] ëª¨ë¸ ì„ íƒ!", versionId, urn);

      // â›”ï¸ ProgressOverlay ì‹œì‘ í˜¸ì¶œ ì•ˆí•¨
      await loadModel(viewer, urn);

      // ë·°ì–´ ì¤€ë¹„ ëŒ€ê¸°(ì§§ê²Œ)
      await waitViewerReady(viewer);

      // ì¹´ë©”ë¼/ì…ë ¥ ë³´ì •
      resetViewerInputAndCamera(viewer);
      viewer.resize();

      // â”€ Task íŒ¨ë„ ë¨¼ì €
      initTaskPanel(taskData);
      initTaskListButtons();
      window.dispatchEvent(new Event("panel2-ready"));

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // ğŸ”¹ WBS í”„ë¡œë°”ì´ë” 'ë¯¸ë¦¬' ì¤€ë¹„(ìœ íœ´ ì‹œê°„ ì˜ˆì•½)
      //    â†’ í´ë¦­ ì‹œ ë°”ë¡œ ì“°ê±°ë‚˜, ì•„ì§ì´ë©´ ì¤€ë¹„ë˜ëŠ” ì¦‰ì‹œ ì´ì–´ì„œ UI ì´ˆê¸°í™”
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const buildProvider = async () => {
        try {
          const { provider } = await buildWbsProviderLazy(viewer, {
            bucketThreshold: 400, bucketSize: 200, source: "all"
          });
          return provider;
        } catch (e) {
          console.warn("[main.js] WBS provider build ì‹¤íŒ¨:", e);
          return { __provider:true, roots: async()=>[], childrenByPath: async()=>[], countAt: ()=>0 };
        }
      };
      wbsProviderPromise = new Promise((resolve) => {
        const kickoff = () => { buildProvider().then(resolve); };
        if ("requestIdleCallback" in window) {
          requestIdleCallback(() => setTimeout(kickoff, 0), { timeout: 1200 });
        } else {
          setTimeout(kickoff, 200);
        }
      });

      // â”€ Tasks íƒ­ í´ë¦­ ì‹œ: WBS UI 1íšŒë§Œ ì´ˆê¸°í™”
      let wbsInitOnce = false;
      const tabBtnPanel2 = document.querySelector('.tab-button[data-target="panel2"]');
      const lazyInitWbs = () => {
        if (wbsInitOnce) return;
        wbsInitOnce = true;

        const host = document.getElementById("wbs-group-content");
        if (host) host.innerHTML = `<div style="padding:8px;color:#666">WBS ë¡œë”© ì¤‘â€¦</div>`;

        // í”„ë¡œë°”ì´ë” ì¤€ë¹„ ì™„ë£Œë¥¼ ê¸°ë‹¤ë ¸ë‹¤ê°€, ë‹¤ìŒ í”„ë ˆì„ì— UIë§Œ ì´ˆê¸°í™”
        (async () => {
          const provider = await (wbsProviderPromise || buildProvider());
          requestAnimationFrame(async () => {
            try {
              await initWbsPanelWithFancytree(provider, { primaryOrder: ["HEC.WBS","HEC.Level","HEC.Zone"] });
            } catch (e) {
              console.warn("[main.js] initWbsPanelWithFancytree ì‹¤íŒ¨:", e);
              if (host) host.innerHTML = `<div style="padding:8px;color:#b55">WBS ì´ˆê¸°í™” ì‹¤íŒ¨</div>`;
            }
          });
        })();
      };
      tabBtnPanel2?.addEventListener("click", lazyInitWbs, { once: true });

      // ê°„íŠ¸ 1íšŒ ë Œë”(ê°€ë³ê²Œ)
      requestAnimationFrame(() => {
        try { window.gantt?.renderFromTrees(window.taskTree, window.wbsTree); } catch {}
      });

      // â›”ï¸ ProgressOverlay finish ì—†ìŒ
    });
  } catch (err) {
    alert("Could not initialize the application. See console for more details.");
    console.error(err);
  }
})();

/* ==============================
   ë°ì´í„° ë¡œë“œ/íŒŒê´´ ìœ í‹¸
============================== */
async function loadTaskDataIfExists() {
  try {
    const safeUrnVal = window.CURRENT_MODEL_SAFE_URN;
    const url = `/api/tasks?urn=${safeUrnVal}`;
    const resp = await fetch(url, { credentials: "include" });
    if (resp.ok) {
      const data = await resp.json();
      taskData.length = 0;
      if (Array.isArray(data) && data.length > 0) {
        data.forEach((item) => taskData.push(item));
        setSavedTaskData(taskData);
      } else {
        SAMPLE_TASK_DATA.forEach((item) => taskData.push(structuredClone(item)));
        setSavedTaskData(taskData);
      }
    } else {
      taskData.length = 0;
      SAMPLE_TASK_DATA.forEach((item) => taskData.push(structuredClone(item)));
      setSavedTaskData(taskData);
    }
  } catch (err) {
    taskData.length = 0;
    SAMPLE_TASK_DATA.forEach((item) => taskData.push(structuredClone(item)));
    setSavedTaskData(taskData);
    console.warn("task ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ìƒ˜í”Œë¡œ ì´ˆê¸°í™”:", err);
  }
}

function destroyTaskPanel() {
  console.log("[destroy] panel2 destroy & ì¬ìƒì„±");
  try { $.ui.fancytree.getTree("#treegrid")?.destroy(); } catch {}
  window.taskTree = null;
  window.wbsTree = null;
  try { window.gantt?.drawFromRows?.([]); } catch {}
  $("#wbs-group-content").empty();
  $("#treegrid tbody").empty();
}

ì´ë ‡ê²Œ í•˜ë©´:

ëª¨ë¸ ë¡œë”© ì§í›„ì—” Taskë§Œ ì¦‰ì‹œ í‘œì‹œ â†’ í”„ë¦¬ì¦ˆ í•´ì†Œ

Tasks íƒ­ í´ë¦­ ì‹œì—ë„, í”„ë¡œë°”ì´ë”ê°€ ì´ë¯¸ ì¤€ë¹„ë¼ ìˆìœ¼ë©´ ë¹ ë¥´ê²Œ WBSê°€ ëœ¨ê³ , ì•„ë‹ˆë©´ â€œë¡œë”© ì¤‘â€¦â€ í‘œì‹œ í›„ ì¤€ë¹„ë˜ëŠ” ì¦‰ì‹œ ì´ˆê¸°í™”

ì˜¤ë²„ë ˆì´/ì›Œë°ì—…/ê¸´ ëŒ€ê¸° ì œê±°ë¡œ ì „ì²´ íë¦„ì´ ê°€ë¿í•´ì§‘ë‹ˆë‹¤.


