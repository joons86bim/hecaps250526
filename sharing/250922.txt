function keyDepth(k){ return (k?.split("¦") || []).length; }

function addCounts(dst, src){
  if (!src) return;
  dst.c = (dst.c || 0) + Number(src.c || 0);
  dst.t = (dst.t || 0) + Number(src.t || 0);
  dst.d = (dst.d || 0) + Number(src.d || 0);
}

function sum3(x){
  return Number(x?.c || 0) + Number(x?.t || 0) + Number(x?.d || 0);
}


async function ensureCountsForSubtree(provider, node){
  const key  = node?.data?.pathKey;
  const path = node?.data?.__path || buildPathFromNode(node);
  if (!key || !path) return;

  if (_subtreeBusy.has(key)) return; // 중복 실행 방지
  _subtreeBusy.add(key);

  try {
    const keys = await collectAllPathKeys(provider, path);
    const uniq = Array.from(new Set(keys.length ? keys : [key]));

    if (uniq.length) {
      // 1) 매트릭스 보장/상태 계산
      await bulkEnsureForVisible(uniq);
      uniq.forEach(k => computePathState(k));

      // 2) "가장 데이터가 많은(=가장 깊은) 레벨"의 counts만 모아 합산 → 중복합산 방지
      const levels = new Map(); // depth -> counts[]
      for (const k of uniq){
        const c = getCounts(k);
        if (c && sum3(c) > 0){
          const d = keyDepth(k);
          if (!levels.has(d)) levels.set(d, []);
          levels.get(d).push(c);
        }
      }

      let totals = { c: 0, t: 0, d: 0 };
      if (levels.size){
        const depths = Array.from(levels.keys()).sort((a,b)=>a-b);
        const deepest = depths[depths.length - 1];
        for (const c of (levels.get(deepest) || [])) addCounts(totals, c);
      }
      // 3) 폴백 합계 저장 (렌더에서 필요시 사용)
      node.data.__aggCounts = totals;
    }

    try { node.render(true); } catch {}
  } finally {
    setTimeout(() => _subtreeBusy.delete(key), 50);
  }
}


//2-2 카운트 렌더 (getCounts → __aggCounts 폴백)
let counts = key && getCounts(key);
const agg   = node.data.__aggCounts;

if ((!counts || sum3(counts) === 0) && agg && sum3(agg) > 0) {
  counts = agg;
}

if (counts && (typeof counts.c === "number" || typeof counts.t === "number" || typeof counts.d === "number")) {
  $statusCell
    .addClass("text-center")
    .html(`
      <div class="wbs-status" style="justify-content: center;">
        <div class="nums">
          <span class="b c" title="시공">${counts.c ?? 0}</span>
          <span class="b t" title="가설">${counts.t ?? 0}</span>
          <span class="b d" title="철거">${counts.d ?? 0}</span>
        </div>
      </div>
    `);
} else {
  $statusCell.text("…");
  if (!node.data.__countsRequested && key) {
    node.data.__countsRequested = true;
    ensureCountsForNode(node)
      .then(() => { try { node.render(true); } catch {} })
      .finally(() => { node.data.__countsRequested = false; });
  }
}




const D = window.__WBS_DEBUG;
const t = D.tree();
const n = t.getRootNode().children[1];

const keys = await D.collectAllPathKeys(D.provider, n.data.__path);
await D.bulkEnsureForVisible(keys);
keys.forEach(D.computePathState);

// 폴백 집계 강제
await D.ensureCountsForSubtree(D.provider, n);
console.log("top getCounts=", D.getCounts(n.data.pathKey), "agg=", n.data.__aggCounts);

t.render(true);
