highlight.js:4 [hec] wbs/highlight.js loaded
endpoints.js:236  getCdnRedirectUrl is deprecated and will be removed soon
endp.getCdnRedirectUrl @ endpoints.js:236
initializeCDN @ envinit.js:640
Initializer @ envinit.js:759
(anonymous) @ init-viewer.js:18
initViewer @ init-viewer.js:17
(anonymous) @ main.js:504
await in (anonymous)
(anonymous) @ main.js:591
WebGLRenderer.js:29 THREE.WebGLRenderer 71
WebGLRenderer.js:229 WebGL Renderer: ANGLE (NVIDIA, NVIDIA GeForce RTX 4080 SUPER (0x00002702) Direct3D11 vs_5_0 ps_5_0, D3D11)
WebGLRenderer.js:230 WebGL Vendor: Google Inc. (NVIDIA)
CustomViewerExtension.js:14 MyCustomViewerExtension이 로드되었습니다.
CustomViewerExtension.js:53 툴바가 생성되었습니다. 사용자 정의를 시작합니다.
CustomViewerExtension.js:207 툴바 커스터마이징 완료.
WebGLRenderer.js:29 THREE.WebGLRenderer 71
WebGLRenderer.js:229 WebGL Renderer: ANGLE (NVIDIA, NVIDIA GeForce RTX 4080 SUPER (0x00002702) Direct3D11 vs_5_0 ps_5_0, D3D11)
WebGLRenderer.js:230 WebGL Vendor: Google Inc. (NVIDIA)
(index):1 Autofocus processing was blocked because a document already has a focused element.
GeometryList.js:344 Total geometry size: 22.579627990722656 MB
GeometryList.js:345 Number of meshes: 6614
GeometryList.js:346 Num Meshes on GPU: 6647
GeometryList.js:347 Net GPU geom memory used: 75519924
main.js:548 [WBS] roots: 5
main.js:148 [persistTasksSnapshot] saved. count = 2
main.js:276 [FA] fallback map ready (keys = 2391 )
main.js:310 [FA] getCounts bridged
main.js:576 [STEP 5] WBS fancytree init OK
main.js:582 [STEP 6] panel2 resizer bound
main.js:583 [STEP 1] Task panel OK
main.js:584 [STEP 2] panel2-ready dispatched
gantt-view.js:171 [gantt-view] google loaded
window.__WBS_DBG__?.listTrees(); // WBS 트리 확인(checkbox=true, selectMode=3 인지)

const t = (function(){
  const all = Array.from(document.querySelectorAll('.fancytree-container'))
    .map(el => $.ui.fancytree.getTree(el)).filter(Boolean);
  const task = $.ui.fancytree.getTree('#treegrid');
  return all.find(x => x !== task && !!x.options?.checkbox);
})();
console.log('selected via API =',
  t?.getSelectedNodes(false).map(n=>({title:n.title, partsel:n.partsel, selected:n.selected}))
);

window.__WBS_DBG__?.getCheckedNodesFT()
  ?.map(n=>({title:n.title, idx:n.getIndexHier?.(), partsel:n.partsel}));
VM2476:9 selected via API = [{…}]0: partsel: trueselected: truetitle: "기초"[[Prototype]]: Objectlength: 1lastIndex: (...)lastItem: (...)[[Prototype]]: Array(0)
undefined



// /wwwroot/js/sidebar/task-wbs/core/wbs-store.js
// 목적: UI 트리 확장 여부와 무관하게, "정확히 체크된(V) 노드"의 모든 후손 leaf dbId를
//       가져올 수 있는 스냅샷/인덱스 저장소.
//
// 사용 요약:
//   initWbsStore({ tree: window.wbsTree, provider: window.__WBS_PROVIDER });
//   const nodes = getCheckedExactNodesInOrder();
//   const ids = await getAllDescendantDbIdsByPath(pathArr); // 확장 필요시 provider로 lazy load
//
// 제공 API:
//   initWbsStore({tree, provider})
//   setProvider(provider)
//   resetWbsStore()
//   refreshWbsStore()         // UI 트리 기반 인덱스 재빌드(보이는 범위 우선)
//   getCheckedExactNodesInOrder()
//   getAllDescendantDbIdsByPath(pathArr)
//   getOrderedDbIdsFromCheckedExact()  // ← 한 번에 (ids[], pathByDbId Map)
//   pathOfNode(node)

export const WbsStore = {
    tree: null,
    provider: null,
    nodesInOrder: [],
    pathKeyToDbIds: new Map(), // "A␁B␁C" -> [dbId...](자손 포함)
    dbIdToPath: new Map(),     // dbId -> ["A","B","C"]
    isReady: false,
  };
  
  const SEP = "\u0001"; // 경로 키 구분자
  
  export function initWbsStore({ tree, provider } = {}) {
    if (tree) WbsStore.tree = tree;
    if (provider) WbsStore.provider = provider;
    rebuildIndexFromVisibleTree();
    // fancytree 이벤트에 따라 가볍게 갱신
    try {
      const $root = $(WbsStore.tree?.$div || "#wbs-tree");
      $root.off(".wbsstore");
      $root.on("fancytreechange.wbsstore fancytreeexpand.wbsstore fancytreecollapse.wbsstore", debounce(rebuildIndexFromVisibleTree, 120));
    } catch(_) {}
  }
  
  export function setProvider(provider){
    WbsStore.provider = provider || null;
  }
  
  export function resetWbsStore(){
    WbsStore.nodesInOrder = [];
    WbsStore.pathKeyToDbIds.clear();
    WbsStore.dbIdToPath.clear();
    WbsStore.isReady = false;
  }
  
  export function refreshWbsStore(){
    rebuildIndexFromVisibleTree();
  }
  
  export function pathOfNode(n){
    const out = [];
    let cur = n;
    while (cur && cur.text && !(typeof cur.isRoot === "function" && cur.isRoot())) {
      out.unshift(String(cur.text));
      cur = cur.parent;
    }
    return out;
  }
  
  export function getCheckedExactNodesInOrder(){
    if (!WbsStore.isReady) rebuildIndexFromVisibleTree();
    return WbsStore.nodesInOrder.filter(isCheckedExact);
  }
  
  /** 체크(V)된 노드들의 자손 leaf dbId를 UI 확장 없이 수집 (WBS 순서 유지) */
  export async function getOrderedDbIdsFromCheckedExact(){
    const checked = getCheckedExactNodesInOrder();
    const orderedDbIds = [];
    const pathByDbId = new Map();
    const seen = new Set();
  
    for (const node of checked) {
      const pathArr = pathOfNode(node);
      const ids = await getAllDescendantDbIdsByPath(pathArr);
      for (const id of ids) {
        if (!seen.has(id)) {
          seen.add(id);
          orderedDbIds.push(id);
          pathByDbId.set(id, pathArr.slice());
        }
      }
    }
    return { orderedDbIds, pathByDbId };
  }
  
  /** 주어진 경로의 모든 자손 leaf dbId 반환(스냅샷에 없으면 provider로 lazy 확장 후 캐시) */
  export async function getAllDescendantDbIdsByPath(pathArr){
    if (!Array.isArray(pathArr) || !pathArr.length) return [];
    if (!WbsStore.isReady) rebuildIndexFromVisibleTree();
  
    const key = pathArr.join(SEP);
    let cached = WbsStore.pathKeyToDbIds.get(key);
    if (Array.isArray(cached) && cached.length) return cached.slice();
  
    // 없으면 provider로 lazy 확장
    const ids = await ensureSubtreeAndCollect(pathArr);
    if (ids.length) WbsStore.pathKeyToDbIds.set(key, ids.slice());
    return ids;
  }
  
  /* ============= 내부 구현 ============= */
  
  function rebuildIndexFromVisibleTree(){
    resetWbsStore();
    const tree = WbsStore.tree || window.wbsTree;
    const root = tree?.getRootNode?.();
    if (!root) return;
  
    root.visit((n) => {
      WbsStore.nodesInOrder.push(n);
      if (isLeafWithDb(n)) {
        const path = pathOfNode(n);
        const pkey = path.join(SEP);
        const id = Number(n.data?.dbId ?? n.dbId);
        if (Number.isFinite(id)) {
          WbsStore.dbIdToPath.set(id, path);
          appendToKeyArray(WbsStore.pathKeyToDbIds, pkey, id);
        }
      }
    });
  
    // 그룹 경로에 대해 현재 보이는 자손만이라도 집계
    root.visit((n) => {
      if (n.hasChildren && n.hasChildren()) {
        const path = pathOfNode(n);
        const pkey = path.join(SEP);
        const acc = [];
        n.visit((c) => {
          if (c !== n && isLeafWithDb(c)) {
            const id = Number(c.data?.dbId ?? c.dbId);
            if (Number.isFinite(id)) acc.push(id);
          }
        });
        if (acc.length) WbsStore.pathKeyToDbIds.set(pkey, uniqKeepOrder(acc));
      }
    });
  
    WbsStore.isReady = true;
  }
  
  async function ensureSubtreeAndCollect(pathArr){
    // provider가 전체 트리를 서비스할 수 있어야 함
    const p = WbsStore.provider;
    if (!p || typeof p.childrenByPath !== "function") return [];
    // BFS로 path 이하 모든 leaf까지 확장
    const queue = [ pathArr.slice() ];
    const leafIds = [];
    const seenPathKey = new Set();
  
    while (queue.length) {
      const curPath = queue.shift();
      const key = curPath.join(SEP);
      if (seenPathKey.has(key)) continue;
      seenPathKey.add(key);
  
      let children = [];
      try {
        children = await p.childrenByPath(curPath); // [{text, dbId?}] child list
      } catch(_){ children = []; }
  
      const subIds = [];
      for (const ch of (children || [])) {
        const text = String(ch.text || ch.name || "").trim();
        if (!text) continue;
        const nextPath = curPath.concat(text);
        const id = Number(ch.dbId ?? ch.data?.dbId);
        if (Number.isFinite(id)) {
          // leaf
          WbsStore.dbIdToPath.set(id, nextPath);
          subIds.push(id);
        } else {
          // group
          queue.push(nextPath);
        }
      }
  
      if (subIds.length) {
        const pkey = curPath.join(SEP);
        const merged = uniqKeepOrder([...(WbsStore.pathKeyToDbIds.get(pkey) || []), ...subIds]);
        WbsStore.pathKeyToDbIds.set(pkey, merged);
        leafIds.push(...subIds);
      }
    }
  
    // 최상위 pathArr의 자손 통합 결과
    const key = pathArr.join(SEP);
    return uniqKeepOrder([...(WbsStore.pathKeyToDbIds.get(key) || []), ...leafIds]);
  }
  
  /* 유틸 */
  
  function isCheckedExact(n){
    // 정확히 V 상태만 (부분선택/하이픈 제외)
    const sel = (typeof n.isSelected === "function") ? n.isSelected() : !!(n.selected || n.data?.selected === true || n.data?.checked === true);
    const part = (typeof n.isPartsel === "function") ? n.isPartsel() : !!n.partsel;
    return !!sel && !part;
  }
  
  function isLeafWithDb(n){
    const hasKids = (n.hasChildren && n.hasChildren());
    const id = Number(n.data?.dbId ?? n.dbId);
    return !hasKids && Number.isFinite(id);
  }
  
  function appendToKeyArray(map, key, val){
    const arr = map.get(key) || [];
    arr.push(val);
    map.set(key, arr);
  }
  
  function uniqKeepOrder(arr){
    const s = new Set(), out = [];
    for (const x of arr) if (!s.has(x)) { s.add(x); out.push(x); }
    return out;
  }
  
  function debounce(fn, ms){
    let t=0;
    return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); };
  }
  
