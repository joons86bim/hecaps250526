function ensureCountBadge(ftNode, provider){
  const span = ftNode?.span; if (!span) return;
  const titleEl = span.querySelector('.fancytree-title') || span;
  let badge = span.querySelector('.count-badge');
  if (!badge){
    badge = document.createElement('span');
    badge.className = 'count-badge';
    badge.style.marginLeft = '6px';
    badge.style.opacity = '0.8';
    titleEl.after(badge);
  }

  const isLeaf = Number.isFinite(Number(ftNode.data?.dbId));
  if (isLeaf){
    badge.textContent = '';
    badge.style.display = 'none';
    return;
  }

  let cnt = (typeof ftNode.data?.leafCount === 'number') ? ftNode.data.leafCount : undefined;
  if (cnt == null && provider && typeof provider.countAt === 'function'){
    try { cnt = provider.countAt(pathFor(ftNode)); } catch {}
  }

  badge.textContent = (typeof cnt === 'number') ? String(cnt) : '…';
  badge.style.display = '';
}



function mapItemsToFt(items, parentPath = []){
  if (!Array.isArray(items)) return [];
  const out = [];
  for (const item of items){
    if (item?._isBucket && Array.isArray(item.__bucket)){
      out.push(...mapItemsToFt(item.__bucket, parentPath)); // 버킷 평탄화
      continue;
    }
    const label = String(item?.text ?? "").trim();
    const dbId  = Number(item?.dbId);
    const isLeaf = Number.isFinite(dbId);

    // provider가 준 정규 경로(__path)가 있으면 그걸 쓰고, 없으면 parentPath+label
    const fallbackPath = parentPath.concat([label]);
    const canonicalPath = Array.isArray(item?.__path) ? item.__path : fallbackPath;

    const want = shouldBeChecked(canonicalPath);

    out.push({
      title: label || "(빈 항목)",
      key: pkey(canonicalPath),     // 경로 기반 고유키(정규 경로로)
      folder: !isLeaf,
      lazy: !isLeaf,                // 비-리프면 확장시 로드
      selected: (want === true) ? true : (want === false ? false : !!item?.selected),
      data: {
        dbId: isLeaf ? dbId : null,
        path: fallbackPath,         // 화면 표시는 사람친화 경로
        __path: canonicalPath       // provider 질의용 정규 경로
      }
    });
  }
  return out;
}



export async function bfsCollectDescendantDbIds(provider, pathArr, visibleNode){
  const canonical = visibleNode?.data?.__path || pathArr || [];

  // 0) provider가 통째로 내려줄 수 있으면 그게 제일 정확/빠름
  try {
    if (provider?.getDbIdsForPath){
      const fast = provider.getDbIdsForPath(canonical, { includeDescendants:true, allowUnbuilt:true }) || [];
      if (Array.isArray(fast) && fast.length) return Array.from(new Set(fast));
    }
  } catch {}

  // 1) 화면 표시 서브트리에서 leaf 수집(보조)
  const fromVisible = [];
  try {
    visibleNode?.visit?.((n) => {
      if (n !== visibleNode && !(n.hasChildren && n.hasChildren())) {
        const id = Number(n.data?.dbId ?? n.dbId);
        if (Number.isFinite(id)) fromVisible.push(id);
      }
    });
  } catch(_){}

  // 2) provider BFS (__path 우선 사용)
  const fromProvider = [];
  if (provider && typeof provider.childrenByPath === "function") {
    const queue = [ canonical.slice() ];
    const seenKey = new Set();
    const SEP = "\u0001";

    while (queue.length) {
      const cur = queue.shift();
      const key = cur.join(SEP);
      if (seenKey.has(key)) continue;
      seenKey.add(key);

      let children = [];
      try { children = await provider.childrenByPath(cur); } catch{ children = []; }

      for (const ch of (children || [])) {
        const id = Number(ch.dbId ?? ch.data?.dbId);
        if (Number.isFinite(id)) { fromProvider.push(id); continue; }

        const label = String(ch.text || ch.name || "").trim();
        const nextPath = Array.isArray(ch.__path) ? ch.__path : (label ? cur.concat(label) : null);
        if (nextPath) queue.push(nextPath);
      }
    }
  }

  // (화면 → provider) 순서 유지 유니크
  const out = [];
  const s = new Set();
  for (const x of fromVisible.concat(fromProvider)) if (!s.has(x)) { s.add(x); out.push(x); }
  return out;
}



async function buildFullIndexFromProvider() {
  const p = WbsStore.provider;
  if (!p || typeof p.childrenByPath !== "function") return;

  resetWbsStore();

  let roots = [];
  try {
    roots = (typeof p.roots === "function") ? (await p.roots()) : (await p.childrenByPath([]));
  } catch (_) { roots = []; }

  const queue = [];
  for (const r of (roots || [])) {
    const label = String(r?.text ?? r?.name ?? "").trim();
    const rPath = Array.isArray(r?.__path) ? r.__path : (label ? [label] : null);
    if (rPath) queue.push(rPath);
  }

  const SEP = "\u0001";

  while (queue.length) {
    const cur = queue.shift();
    const key = cur.join(SEP);

    // 가능하면 한 번에 자손 dbId를 받아서 저장(빠르고 정확)
    let got = [];
    try { got = p.getDbIdsForPath?.(cur, { includeDescendants:true, allowUnbuilt:true }) || []; } catch {}
    if (Array.isArray(got) && got.length) {
      const merged = uniqKeepOrder([...(WbsStore.pathKeyToDbIds.get(key) || []), ...got]);
      WbsStore.pathKeyToDbIds.set(key, merged);
      // dbId → leaf 경로는 children loop에서 보강됨
    }

    // children 순회로 leaf 경로/하위 큐 적재
    let children = [];
    try { children = await p.childrenByPath(cur); } catch { children = []; }

    for (const ch of (children || [])) {
      const label = String(ch?.text ?? ch?.name ?? "").trim();
      const id = Number(ch?.dbId ?? ch?.data?.dbId);
      const chPath = Array.isArray(ch?.__path) ? ch.__path : (label ? cur.concat(label) : null);

      if (Number.isFinite(id)) {
        // leaf: dbId → 정확한 경로 매핑
        if (chPath) WbsStore.dbIdToPath.set(id, chPath);
      } else if (chPath) {
        queue.push(chPath);
      }
    }
  }

  WbsStore.isReady = true;
}



// 1) 스토어 재구축
window.__WBS_STORE__?.refreshWbsStore()
  .then(()=>console.log('store ready?', window.__WBS_STORE__?.WbsStore?.isReady));

// 2) 체크된 항목 기준 dbId 회수(부분선택 포함)
window.__WBS_STORE__?.getOrderedDbIdsFromSelection({ includePartsel: true })
  .then(r => console.log('dbIds:', r.orderedDbIds.length, r.orderedDbIds.slice(0,30)));

// 3) 특정 루트(3, 4번) 노드를 클릭 후, 개별 경로로 직접 검증
//   - 선택한 노드를 n이라 가정
// const n = $.ui.fancytree.getTree('#wbs-tree').getActiveNode();
// const p = n.data.__path;
// window.WBS_PROVIDER.getDbIdsForPath(p, { includeDescendants:true, allowUnbuilt:true })


