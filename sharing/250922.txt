// /wwwroot/js/main.js — 첫 로딩 WBS 셀 색칠 보장 (배지 제거/최적화)

import { initTabs } from "./sidebar/init-tabs.js";
import { initTree } from "./sidebar/init-tree.js";
import { initViewer, loadModel } from "./viewer/init-viewer.js";
import { buildWbsProviderLazy } from "./sidebar/task-wbs/wbs/loader.js";
import { bindPanel2Resizer } from "./sidebar/task-wbs/layout/panel-resizer.js";

import {
  initMatrix,
  bulkEnsureForVisible,
  computePathState,
  getCounts as _getCountsImported,   // 로컬 import는 디버그 브릿지 대상 아님(참고용)
  markTasksChanged,
} from "./sidebar/task-wbs/core/matrix-index.js";

import { toKey } from "./sidebar/task-wbs/core/path-key.js";

import {
  initTaskPanel,
  initTaskListButtons,
  setSavedTaskData,
  disableViewerEscReset,
  initWbsPanelWithFancytree,
} from "./sidebar/index.js";

/* ──────────────────────────────────────────────────────────────
   전역/기본 설정
────────────────────────────────────────────────────────────── */
try {
  window.__WBS_DEBUG = window.__WBS_DEBUG || {};
  window.getCounts = _getCountsImported;
  window.markTasksChanged = markTasksChanged;
} catch {}

const SIDEBAR_MIN = 360;
const SIDEBAR_DEFAULT = 900;
const PREVIEW_MIN = 520;

window.__FA_FALLBACK_BY_KEY = Object.create(null); // 폴백 count 저장소

function initSidebarWidth() {
  const root = document.documentElement;
  const stored = parseInt(localStorage.getItem("sidebarWidthPx") || "0", 10);
  const maxNow = Math.max(SIDEBAR_MIN, window.innerWidth - PREVIEW_MIN);
  const initial = Number.isFinite(stored) && stored >= SIDEBAR_MIN
    ? Math.min(maxNow, stored)
    : Math.min(maxNow, SIDEBAR_DEFAULT);
  root.style.setProperty("--sidebar-width", initial + "px");
  return initial;
}

function resetViewerInputAndCamera(viewer) {
  try {
    const tc = viewer.toolController;
    if (tc?.isToolActivated?.("BoxSelectionTool")) tc.deactivateTool("BoxSelectionTool");
    viewer.setNavigationLock(false);
    const fallbackNav = viewer.impl?.is2d ? "pan" : "orbit";
    viewer.setActiveNavigationTool?.(fallbackNav);
    viewer.setSelectionMode(Autodesk.Viewing.SelectionMode.MIXED);
    viewer.clearSelection?.();
    if (!viewer.impl?.is2d) {
      viewer.navigation.setWorldUpVector(new THREE.Vector3(0, 0, 1), true);
      const bb = viewer.model?.getBoundingBox?.();
      if (bb) {
        const center = bb.getCenter(new THREE.Vector3());
        viewer.navigation.setPivotPoint(center);
        viewer.navigation.setTarget(center);
      }
    }
    viewer.fitToView?.();
  } catch {}
}

/* ──────────────────────────────────────────────────────────────
   뷰어 대기 유틸
────────────────────────────────────────────────────────────── */
function onceViewer(viewer, type) {
  return new Promise((resolve) => {
    const h = () => { try { viewer.removeEventListener(type, h); } catch {} ; resolve(); };
    viewer.addEventListener(type, h);
  });
}
function hasObjectTree(viewer) {
  return !!viewer.model?.getData?.()?.instanceTree;
}
async function waitObjectTree(viewer) {
  if (hasObjectTree(viewer)) return;
  await onceViewer(viewer, Autodesk.Viewing.OBJECT_TREE_CREATED_EVENT);
}
async function waitGeometry(viewer, timeoutMs = 180000) {
  await new Promise((resolve) => {
    let done = false;
    const h = () => { if (done) return; done = true; try { viewer.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, h); } catch {} ; resolve(); };
    viewer.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, h, { once: true });
    setTimeout(h, timeoutMs);
  });
}
async function waitPropertyDb(viewer, timeoutMs = 120000) {
  try { if (viewer?.model?.getPropertyDb?.()) return; } catch {}
  await new Promise((resolve) => {
    let done = false;
    const h = () => { if (done) return; done = true; try { viewer.removeEventListener(Autodesk.Viewing.PROPERTY_DB_CREATED_EVENT, h); } catch {} ; resolve(); };
    viewer.addEventListener(Autodesk.Viewing.PROPERTY_DB_CREATED_EVENT, h, { once: true });
    setTimeout(h, timeoutMs);
  });
}
function waitIdle(timeout = 60) {
  return new Promise((resolve) => {
    if (typeof window.requestIdleCallback === "function") {
      window.requestIdleCallback(() => resolve(), { timeout });
    } else setTimeout(resolve, timeout);
  });
}
async function waitViewerReady(viewer) {
  await Promise.all([ waitObjectTree(viewer), waitPropertyDb(viewer), waitGeometry(viewer) ]);
  await waitIdle(60);
}
async function focusCameraAndWait(viewer) {
  return new Promise((resolve) => {
    const onCam = () => { try { viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, onCam); } catch {}; requestAnimationFrame(() => resolve()); };
    viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, onCam, { once: true });
    resetViewerInputAndCamera(viewer);
  });
}

/* ──────────────────────────────────────────────────────────────
   태스크/URN 유틸
────────────────────────────────────────────────────────────── */
function safeUrn(urn) { return urn.replace(/[^a-zA-Z0-9]/g, "_"); }
function fillUrnRecursive(task, defaultUrn) {
  if (Array.isArray(task.linkedObjects)) {
    task.linkedObjects.forEach((o) => { if (!o.urn) o.urn = defaultUrn || window.CURRENT_MODEL_URN; });
  }
  if (Array.isArray(task.children)) {
    task.children.forEach((child) => fillUrnRecursive(child, defaultUrn));
  }
}
function persistTasksSnapshot(tasks) {
  const RAW  = window.CURRENT_MODEL_URN;
  const SAFE = window.CURRENT_MODEL_SAFE_URN;
  if (!RAW || !SAFE) return;
  try {
    const json = JSON.stringify(tasks || []);
    localStorage.setItem(`hec:tasks:${RAW}`, json);
    localStorage.setItem(`hec:tasks:${SAFE}`, json);
    window.__SAVED_TASKS = (tasks || []);
    console.log("[persistTasksSnapshot] saved. count =", window.__SAVED_TASKS.length);
  } catch (e) {
    console.warn("[persistTasksSnapshot] failed:", e);
  }
}

/* ──────────────────────────────────────────────────────────────
   Provider 워밍업 / 폴백 집계
────────────────────────────────────────────────────────────── */
async function seedDbIdMappings(provider, { maxDepth = 3, cap = 6000 } = {}) {
  const roots = await provider.roots().catch(() => []) || [];
  const q = roots.map(r => ({ path: [r.text], depth: 0 }));
  let visited = 0;
  while (q.length && visited < cap) {
    const { path, depth } = q.shift();
    try { provider.getDbIdsForPath?.(path, { includeDescendants: true, allowUnbuilt: true }); } catch {}
    if (depth < maxDepth) {
      let kids = [];
      try { kids = await provider.childrenByPath(path) || []; } catch {}
      visited += kids.length;
      for (const ch of kids) {
        const np = ch.__path || [...path, ch.text];
        q.push({ path: np, depth: depth + 1 });
      }
    }
  }
}

async function collectKeysForRoots(provider, { maxDepth = 3, cap = 6000 } = {}) {
  const roots = (await provider.roots().catch(() => [])) || [];
  const q = roots.map(r => ({ path: [r.text], depth: 0 }));
  const keys = new Set();
  let seen = 0;

  while (q.length && seen < cap) {
    const { path, depth } = q.shift();
    keys.add(toKey(path));

    let kids = [];
    try { kids = await provider.childrenByPath(path) || []; } catch {}
    seen += kids.length;

    if (depth < maxDepth) {
      for (const ch of kids) {
        const np = ch.__path || [...path, ch.text];
        q.push({ path: np, depth: depth + 1 });
      }
    }
  }
  return Array.from(keys);
}

// 태스크 → 상태별 dbId 세트
function buildStatusSetsFromTasks(tasks) {
  const stateById = new Map();
  const norm = (raw) => {
    if (!raw) return "";
    const s = String(raw).trim();
    const S = s.toUpperCase();
    if (s.includes("시공") || S.startsWith("C")) return "C";
    if (s.includes("가설") || S.startsWith("T")) return "T";
    if (s.includes("철거") || s.includes("해체") || S.startsWith("D")) return "D";
    if (S === "TD" || s.includes("동시") || s.includes("복합") || S.startsWith("X")) return "TD";
    return "";
  };
  const prio = { C:3, TD:2, D:1, T:0, "":-1 };
  function apply(id, sNew) {
    if (!id || !sNew) return;
    const cur = stateById.get(id);
    if (!cur) { stateById.set(id, sNew); return; }
    if ((cur === "T" && sNew === "D") || (cur === "D" && sNew === "T")) { stateById.set(id, "TD"); return; }
    stateById.set(id, prio[sNew] > prio[cur] ? sNew : cur);
  }
  (function walk(arr, inherited="") {
    (arr||[]).forEach(t => {
      const sTask = norm(t.status || t.selectedOption || inherited);
      (t.linkedObjects||[]).forEach(o => apply(o.dbId, norm(o.status || o.phase || sTask)));
      if (t.children) walk(t.children, sTask);
    });
  })(tasks);
  const S = { C:new Set(), T:new Set(), D:new Set(), TD:new Set() };
  for (const [id, s] of stateById.entries()) if (S[s]) S[s].add(id);
  return S;
}

function calcCountsForPath(provider, path, S) {
  let ids = [];
  try {
    ids = provider.getDbIdsForPath(path, { includeDescendants:true, allowUnbuilt:true }) || [];
  } catch {}
  if (!ids.length) return { total:0, c:0, t:0, d:0, td:0 };
  const set = new Set(ids);
  let c=0,t=0,d=0,td=0;
  for (const id of set) {
    if (S.C.has(id)) c++;
    if (S.T.has(id)) t++;
    if (S.D.has(id)) d++;
    if (S.TD.has(id)) td++;
  }
  return { total:set.size, c,t,d,td };
}

function keyFromPath(path) {
  const D = window.__WBS_DEBUG;
  return (D?.toKey ? D.toKey(path) : toKey(path));
}

async function buildFallbackMap(provider, { maxDepth=3, cap=6000 } = {}) {
  window.__FA_FALLBACK_BY_KEY = Object.create(null);
  const tasks = window.__SAVED_TASKS || [];
  const S = buildStatusSetsFromTasks(tasks);

  const roots = (await provider.roots().catch(()=>[])) || [];
  const q = roots.map(r => ({ path:[r.text], depth:0 }));
  let seen = 0;

  while (q.length && seen < cap) {
    const { path, depth } = q.shift();
    const key = keyFromPath(path);
    window.__FA_FALLBACK_BY_KEY[key] = calcCountsForPath(provider, path, S);

    let kids = [];
    try { kids = await provider.childrenByPath(path) || []; } catch {}
    seen += kids.length;
    if (depth < maxDepth) {
      for (const ch of kids) q.push({ path: (ch.__path || [...path, ch.text]), depth: depth+1 });
    }
  }
  console.log("[FA] fallback map ready (keys =", Object.keys(window.__FA_FALLBACK_BY_KEY).length, ")");
}

function patchGetCountsToUseFallback() {
  const D = window.__WBS_DEBUG;
  const fbMap = () => window.__FA_FALLBACK_BY_KEY || Object.create(null);

  if (!window.__FA_BRIDGED_GLOBAL) {
    const origGlobal = window.getCounts;
    window.getCounts = function (k) {
      const r = origGlobal ? (origGlobal(k) || {}) : {};
      const sum = ((r.c|0)+(r.t|0)+(r.d|0)+(r.td|0));
      if (sum > 0) return r;
      const fb = fbMap()[k];
      if (fb) { const total = Math.max((r.total|0), (fb.total|0)); return { total, c:fb.c|0, t:fb.t|0, d:fb.d|0, td:fb.td|0 }; }
      return r;
    };
    window.__FA_BRIDGED_GLOBAL = true;
  }

  if (D?.getCounts && !D.__patchedForFallback) {
    const orig = D.getCounts.bind(D);
    D.__origGetCounts = orig;
    D.getCounts = function (k) {
      const r = orig(k) || {};
      const sum = ((r.c|0)+(r.t|0)+(r.d|0)+(r.td|0));
      if (sum > 0) return r;
      const fb = fbMap()[k];
      if (fb) { const total = Math.max((r.total|0), (fb.total|0)); return { total, c:fb.c|0, t:fb.t|0, d:fb.d|0, td:fb.td|0 }; }
      return r;
    };
    D.__patchedForFallback = true;
  }

  console.log("[FA] getCounts bridged");
}

/* ──────────────────────────────────────────────────────────────
   WBS FancyTree 셀 색칠 (배지 제거)
────────────────────────────────────────────────────────────── */
const CELL_COLOR = {
  C:  "#ef4444", // 시공(빨강)
  T:  "#f59e0b", // 가설(주황)
  D:  "#6b7280", // 철거(회색)
  TD: "#2563eb"  // 가설+철거(파랑)
};

function injectWbsCellCss() {
  if (document.getElementById("wbs-cell-style")) return;
  const css = `
    .fancytree-node .fancytree-title {
      border-left: 4px solid transparent;
      padding-left: 8px;
      border-radius: 6px;
      transition: background-color .15s ease, border-color .15s ease;
    }
    .wbsCell--C  .fancytree-title  { background: ${CELL_COLOR.C}1a;  border-left-color: ${CELL_COLOR.C}; }
    .wbsCell--T  .fancytree-title  { background: ${CELL_COLOR.T}1a;  border-left-color: ${CELL_COLOR.T}; }
    .wbsCell--D  .fancytree-title  { background: ${CELL_COLOR.D}1a;  border-left-color: ${CELL_COLOR.D}; }
    .wbsCell--TD .fancytree-title  { background: ${CELL_COLOR.TD}1a; border-left-color: ${CELL_COLOR.TD}; }
  `.trim();
  const s = document.createElement("style");
  s.id = "wbs-cell-style";
  s.textContent = css;
  document.head.appendChild(s);
}

function normalizeCounts(x){
  // 어떤 형태로 와도 안전하게 객체로 변환
  if (x == null) return { total: 0, C: 0, T: 0, D: 0 };
  if (typeof x === "number") return { total: x, C: x, T: 0, D: 0 }; // 총합만 아는 형태
  // 객체일 때 필드 보정
  return {
    total: Number(x.total ?? x.count ?? 0),
    C:     Number(x.C ?? x.c ?? 0),
    T:     Number(x.T ?? x.t ?? 0),
    D:     Number(x.D ?? x.d ?? 0),
  };
}

function countsForPath(path){
  // 1) 브리지 함수가 있으면 우선 사용
  if (typeof window.__FA_GET_COUNTS__ === "function") {
    return normalizeCounts(window.__FA_GET_COUNTS__(path));
  }
  // 2) Provider에 countAt가 있으면 사용
  const provider = window.__WBS_PROVIDER;
  if (provider?.countAt) {
    return normalizeCounts(provider.countAt(path));
  }
  // 3) WbsStore가 있으면 스토어의 countAt 사용
  const store = window.__WBS_STORE__;
  if (store?.countAt) {
    return normalizeCounts(store.countAt(path));
  }
  // 4) 사전 계산 맵이 있다면 (키 조인은 스토어와 동일한 구분자 사용)
  const SEP = "\u0001";
  const key = (path || []).join(SEP);
  const m = window.__FA_COUNT_MAP__;
  if (m && typeof m.get === "function") {
    return normalizeCounts(m.get(key));
  }
  // 5) 전부 없으면 0으로
  return normalizeCounts(null);
}

function classForCounts(c) {
  if (!c) return null;
  if ((c.td|0) > 0) return "wbsCell--TD";
  if ((c.c|0)  > 0) return "wbsCell--C";
  if ((c.t|0)  > 0) return "wbsCell--T";
  if ((c.d|0)  > 0) return "wbsCell--D";
  return null;
}

function repaintNode(node) {
  const $ = window.jQuery || window.$;
  if (!$ || !node || !node.span || node.isRoot?.()) return;

  // __path가 없으면 아직 매핑 전 → 이번 프레임 스킵 (재시도 루프가 다시 칠함)
  const path = node.data?.__path;
  if (!path) return;

  const counts = countsForPath(path);
  const $li = $(node.li);
  $li.removeClass("wbsCell--C wbsCell--T wbsCell--D wbsCell--TD");
  const cls = classForCounts(counts);
  if (cls) $li.addClass(cls);
}

function repaintTree(tree) {
  if (!tree) return;
  tree.visit(repaintNode);
}

// 첫 로딩 셀 칠하기 재시도 루프(최대 1초)
function startFirstPaintRetry(tree) {
  let tries = 0;
  const maxTries = 10;
  const step = () => {
    tries++;
    repaintTree(tree);
    if (tries >= maxTries) return;
    setTimeout(step, 100);
  };
  setTimeout(step, 0);
}

function installWbsDecorators(tree) {
  const $ = window.jQuery || window.$;
  if (!tree) tree = $.ui?.fancytree?.getTree("#wbs-tree");
  if (!tree) return;

  injectWbsCellCss();

  // 기존 훅 체이닝
  const prevRenderNode = tree.options.renderNode;
  tree.$div.fancytree("option", "renderNode", function(event, data) {
    try { if (typeof prevRenderNode === "function") prevRenderNode.call(this, event, data); } catch {}
    try { repaintNode(data.node); } catch {}
  });
  tree.$div.fancytree("option", "createNode", function(_ev, data) {
    try { repaintNode(data.node); } catch {}
  });
  tree.$div.fancytree("option", "expand", function(_ev, data) {
    if (data.node?.expanded) setTimeout(() => { try { repaintTree(tree); } catch {} }, 0);
  });

  // 초기 두 프레임 + 재시도 루프
  try { repaintTree(tree); } catch {}
  requestAnimationFrame(() => { try { repaintTree(tree); } catch {} });
  startFirstPaintRetry(tree);

  // 디버그 훅
  tree.__wbsHelpers = tree.__wbsHelpers || {};
  tree.__wbsHelpers.repaintTree = () => { try { repaintTree(tree); } catch {} };
}

/* ──────────────────────────────────────────────────────────────
   태스크 로드(API 대체 샘플)
────────────────────────────────────────────────────────────── */
const SAMPLE_TASK_DATA = [
  {
    no: "1", title: "Task A", selectedOption: "시공",
    start: "2024-06-25", end: "2024-07-01",
    linkedObjects: [{ urn: "SAMPLE_URN", dbId: 1001, text: "벽체1" }],
    children: [
      { no: "1.1", title: "Subtask A1", selectedOption: "시공",
        start: "2024-06-26", end: "2024-06-30",
        linkedObjects: [{ urn: "SAMPLE_URN", dbId: 1002, text: "벽체2" }] }
    ],
  },
  { no: "2", title: "Task B", selectedOption: "가설", start: "", end: "", linkedObjects: [] },
];

async function fetchTaskDataForCurrentModel() {
  try {
    const safeUrnVal = window.CURRENT_MODEL_SAFE_URN;
    const url = `/api/tasks?urn=${safeUrnVal}`;
    const resp = await fetch(url, { credentials: "include" });
    if (resp.ok) {
      const data = await resp.json();
      if (Array.isArray(data) && data.length > 0) return data;
    }
  } catch (err) {
    console.warn("task 데이터를 불러오지 못했습니다. 샘플로 대체:", err);
  }
  return SAMPLE_TASK_DATA.map(x => structuredClone(x));
}

/* ──────────────────────────────────────────────────────────────
   리사이즈
────────────────────────────────────────────────────────────── */
window.addEventListener("resize", _.throttle(() => {
  try {
    initSidebarWidth();
    window.viewer?.resize?.();
    window.viewer?.impl?.invalidate?.(true, true, true);
  } catch (e) { console.warn("[resize] redraw failed", e); }
}, 120));

/* ──────────────────────────────────────────────────────────────
   main
────────────────────────────────────────────────────────────── */
(async function () {
  try {
    // 1) 로그인
    const resp = await fetch("/api/auth/profile", { credentials: "include" });
    if (!resp.ok) { window.location.replace("/api/auth/login"); return; }
    const user = await resp.json();
    const login = document.getElementById("login");
    login.innerText = `Logout (${user.name})`;
    login.onclick = () => {
      const iframe = document.createElement("iframe");
      iframe.style.visibility = "hidden";
      iframe.src = "https://accounts.autodesk.com/Authentication/LogOut";
      document.body.appendChild(iframe);
      iframe.onload = () => { window.location.replace("/api/auth/logout"); document.body.removeChild(iframe); };
    };

    // 2) 레이아웃
    const Sidebar = document.getElementById("sidebar");
    const Header  = document.getElementById("header");
    const Preview = document.getElementById("preview");
    const sidebarResizer = document.getElementById("sidebar-resizer");
    const Loading = document.getElementById("loading");
    Sidebar.style.display = "";
    sidebarResizer.style.display = "";
    Preview.style.display = "";
    Header.style.display = "";
    Loading.style.display = "none";
    login.style.visibility = "visible";
    Sidebar.style.removeProperty("width");
    Preview.style.removeProperty("left");
    sidebarResizer.style.removeProperty("left");
    initSidebarWidth();

    // 3) 탭/뷰어
    initTabs("#sidebar");
    const viewerHost = document.getElementById("viewer-host");
    const viewer = await initViewer(viewerHost);
    window.viewer = viewer;
    disableViewerEscReset(viewer);

    viewer.resize();
    viewer.impl?.invalidate?.(true, true, true);
    requestAnimationFrame(() => { try { viewer.resize(); viewer.impl?.invalidate?.(true, true, true); } catch {} });
    resetViewerInputAndCamera(viewer);

    requestAnimationFrame(() => {
      const sb = document.getElementById("sidebar");
      if (sb && sb.offsetWidth === 0) {
        document.documentElement.style.setProperty("--sidebar-width", SIDEBAR_DEFAULT + "px");
        viewer.resize();
        viewer.impl?.invalidate?.(true, true, true);
      }
    });

    // 4) 모델 선택
    initTree("#tree", async (versionId) => {
      const urn = window.btoa(versionId).replace(/=/g, "");
      window.CURRENT_MODEL_URN = urn;
      window.CURRENT_MODEL_SAFE_URN = safeUrn(urn);

      // 기존 WBS 파괴
      try { $.ui.fancytree.getTree("#wbs-tree")?.destroy(); } catch {}
      $("#wbs-group-content").empty();

      // (A) 모델 로드 & 안정화
      await loadModel(viewer, urn);
      await waitViewerReady(viewer);
      await focusCameraAndWait(viewer);
      viewer.resize();

      // (B) WBS Provider 생성
      let provider = null;
      try {
        const PRIMARY = ["HEC.WBS","HEC.Level","HEC.Zone"];
        const { provider: p } = await buildWbsProviderLazy(viewer, {
          primaryOrder: PRIMARY, source: "all", bucketThreshold: 400, bucketSize: 200,
        });
        provider = p;
        window.WBS_PROVIDER = provider;
        const roots = await provider.roots();
        console.log("[WBS] roots:", Array.isArray(roots) ? roots.length : roots);
      } catch (e) {
        console.warn("[WBS] provider failed:", e);
        provider = { __provider:true, roots:async()=>[], childrenByPath:async()=>[] };
        window.WBS_PROVIDER = provider;
      }

      // (C) 태스크 로드/정규화/영속
      const tasks = await fetchTaskDataForCurrentModel();
      tasks.forEach((t) => fillUrnRecursive(t, urn));
      persistTasksSnapshot(tasks);

      // (D) provider 맵 워밍업 → 매트릭스 초기화 → 태스크 데이터 UI로 공유
      await seedDbIdMappings(provider, { maxDepth: 3, cap: 6000 });
      await initMatrix({ primaryOrder:["HEC.WBS","HEC.Level","HEC.Zone"], provider });
      setSavedTaskData(tasks);

      // (E) 폴백맵 준비 & getCounts 브릿지
      await buildFallbackMap(provider, { maxDepth:3, cap:6000 });
      patchGetCountsToUseFallback();

      // (F) 선계산(루트~깊이3)
      const preKeys = await collectKeysForRoots(provider, { maxDepth: 3, cap: 6000 });
      await bulkEnsureForVisible(preKeys);
      preKeys.forEach(computePathState);

      // (G) 트리 init → 핸들 확보 → 데코레이터 설치 → 첫 칠하기 재시도
      await initWbsPanelWithFancytree(provider, { primaryOrder: ["HEC.WBS","HEC.Level","HEC.Zone"] });
      console.log("[STEP 5] WBS fancytree init OK");

      const tree = $.ui.fancytree.getTree("#wbs-tree");
      installWbsDecorators(tree); // ★ 셀 색칠 전용(배지 없음)

      // (H) 나머지
      try { bindPanel2Resizer(viewer); console.log("[STEP 6] panel2 resizer bound"); } catch {}
      try { initTaskPanel(tasks); initTaskListButtons(); console.log("[STEP 1] Task panel OK"); } catch {}
      try { window.dispatchEvent(new Event("panel2-ready")); console.log("[STEP 2] panel2-ready dispatched"); } catch {}
    });

  } catch (err) {
    alert("Could not initialize the application. See console for more details.");
    console.error(err);
  }
})();


<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="https://cdn.autodesk.io/favicon.ico" />

    <!-- Autodesk Viewer 스타일 -->
    <link rel="stylesheet" href="https://developer.api.autodesk.com/modelderivative/v2/viewers/7.*/style.css" />

    <!-- Inspire Tree 스타일 -->
    <link rel="stylesheet" href="https://unpkg.com/inspire-tree-dom@4.0.6/dist/inspire-tree-light.min.css" />

    <!-- flatpickr CSS/JS CDN -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>

    <!-- Fancytree -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery.fancytree@2/dist/skin-win8/ui.fancytree.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/jquery.fancytree@2/dist/jquery.fancytree-all-deps.min.js"></script>

    <!-- 입력 마스킹 -->
    <script src="https://unpkg.com/imask"></script>

    <!-- 전역 CSS -->
    <link rel="stylesheet" href="/css/00-base.css">
    <link rel="stylesheet" href="/css/05-hec-progress-overlay.css">
    <link rel="stylesheet" href="/css/10-layout.css">
    <link rel="stylesheet" href="/css/20-sidebar.css">
    <link rel="stylesheet" href="/css/30-task-wbs.css">
    <link rel="stylesheet" href="/css/35-wbs-matrix.css">
    <link rel="stylesheet" href="/css/40-viewer-ui.css">
    <link rel="stylesheet" href="/css/gantt.css">
    <link rel="stylesheet" href="/css/95-modal-current-task.css">
    
    <!-- Lucide Icons -->
    <link rel="stylesheet" href="https://unpkg.com/lucide-static/font/css/lucide.css" />

    <title>HEC-BIM 객체 공정 매핑도구</title>
  </head>

  <body>
    <!-- Google Charts loader -->
    <script src="https://www.gstatic.com/charts/loader.js"></script>

    <script type="module">
      import { initGanttView } from "/js/sidebar/task-wbs/ui/gantt-view.js";;

      window.addEventListener('DOMContentLoaded', () => {
        // 간트 스플리터
        (function splitter(){
          const host = document.getElementById('preview');
          const sp   = document.getElementById('gantt-splitter');
          const open = document.getElementById('gantt-open-btn');
          if (!host || !sp) return;

          const saved = localStorage.getItem('ganttHeight');
          if (saved) host.style.setProperty('--gantt-height', saved);

          let dragging = false, startY = 0, startH = 0;

          function onDown(e){
            if (host.classList.contains('gantt-collapsed')) return;
            dragging = true;
            startY = e.clientY || (e.touches?.[0]?.clientY ?? 0);
            const cs = getComputedStyle(host);
            startH = parseFloat(cs.getPropertyValue('--gantt-height')) || 320;
            document.body.style.userSelect = 'none';
          }
          function onMove(e){
            if (!dragging) return;
            const y = e.clientY || (e.touches?.[0]?.clientY ?? 0);
            const dy = y - startY;
            let h = Math.max(120, startH - dy);
            h = Math.min(h, window.innerHeight - 160);
            host.style.setProperty('--gantt-height', h + 'px');
          }
          function onUp(){
            if (!dragging) return;
            dragging = false;
            document.body.style.userSelect = '';
            const cs = getComputedStyle(host);
            localStorage.setItem('ganttHeight', cs.getPropertyValue('--gantt-height').trim());
            setTimeout(()=> window.gantt?.renderFromTrees(window.taskTree, window.wbsTree), 80);
          }

          sp.addEventListener('mousedown', onDown);
          sp.addEventListener('touchstart', onDown, { passive: true });
          window.addEventListener('mousemove', onMove);
          window.addEventListener('touchmove', onMove, { passive: false });
          window.addEventListener('mouseup', onUp);
          window.addEventListener('touchend', onUp);

          sp.addEventListener('dblclick', () => {
            host.classList.toggle('gantt-collapsed');
            setTimeout(()=> window.gantt?.renderFromTrees(window.taskTree, window.wbsTree), 120);
          });
          document.addEventListener('click', (e) => {
            if (e.target?.id === 'gantt-toggle') {
              host.classList.toggle('gantt-collapsed');
              setTimeout(()=> window.gantt?.renderFromTrees(window.taskTree, window.wbsTree), 120);
            }
          });
          open?.addEventListener('click', () => {
            const wasCollapsed = host.classList.contains('gantt-collapsed');
            host.classList.remove('gantt-collapsed');
            if (wasCollapsed) setTimeout(()=> window.gantt?.renderFromTrees(window.taskTree, window.wbsTree), 120);
          });
        })();

        // panel2 준비되면 간트 초기화
        window.addEventListener("panel2-ready", async () => {
          if (!window.gantt) {
            window.gantt = await initGanttView({
              container: "#gantt-chart",
              saveBtn:   "#gantt-save-png"
            });
          }
          if (window.taskTree) {
            window.gantt.renderFromTrees(window.taskTree, window.wbsTree);
          }
        });
      });
    </script>

    <!-- 로딩 중 -->
    <div id="loading" style="display:flex;flex-direction:column;justify-content:center;align-items:center;position:fixed;inset:0;width:100vw;height:100vh;font-size:2rem;font-weight:500;color:#555;background:#f7f8fa;z-index:9999;">
      <h1>Welcome to HEC-BIM Platform...!!</h1>
    </div>

    <!-- 헤더 -->
    <div id="header" style="display: none">
      <img class="logo" src="/images/hec_logo.png" alt="HYUNDAI ENGINEERING" />
      <span class="title" style="font-size: 25px">BIM 객체 공정 매핑도구</span>
      <button id="login" style="visibility: visible">Login</button>
    </div>

    <!-- 사이드바 -->
    <div id="sidebar" style="display: none">
      <div class="tabs">
        <button class="tab-button active" data-target="panel1">Files</button>
        <button class="tab-button" data-target="panel2">Tasks</button>
      </div>

      <div class="panels">
        <!-- 1번 패널: 파일 트리 -->
        <div id="panel1" class="panel active">
          <div class="panel-content">
            <div id="tree"></div>
          </div>
        </div>

        <!-- 2번 패널: Task / WBS -->
        <div id="panel2" class="panel">
          <div id="vertical-split-container">
            <div id="task-list-panel">
              <div class="panel-header sticky-task-header">
                <span class="title">Task List</span>
                <div class="button-group">
                  <button id="btn-add">추가</button>
                  <button id="btn-delete">삭제</button>
                  <button id="btn-select">객체 선택</button>
                  <button id="btn-link">데이터 연결</button>
                  <button id="btn-unlink">연결 해제</button>
                  <button id="btn-date">공정현황</button>
                  <button id="btn-test">테스트</button>
                  <button id="btn-update">저장</button>
                </div>
              </div>
              <div id="task-list-content">
                <table id="treegrid" style="width: 100%" class="fancytree-ext-table">
                  <colgroup>
                    <col width="40px" />
                    <col width="60px" />
                    <col width="260px" />
                    <col width="100px" />
                    <col width="100px" />
                    <col width="100px" />
                    <col width="60px" />
                  </colgroup>
                  <thead>
                    <tr>
                      <th>No.</th>
                      <th>구분</th>
                      <th>작업명</th>
                      <th>시작일</th>
                      <th>소요시간(Day)</th>
                      <th>완료일</th>
                      <th>객체개수</th>
                    </tr>
                  </thead>
                  <tbody></tbody>
                </table>
              </div>
            </div>

            <!-- 드래그 바 -->
            <div id="resizer"></div>

            <div class="sidebar-panel" id="wbs-group-list-panel">
              <div class="panel-header">
                <span class="title">WBS Group List</span>
              </div>
              <div class="panel-content" id="wbs-group-content">
                <div id="wbs-tree"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- 사이드바 리사이저 -->
    <div id="sidebar-resizer" style="display: none"></div>

    <!-- 뷰어 + 간트 -->
    <div id="preview" style="display:none">
      <div id="viewer-host"><div id="forgeViewerMount"></div></div>
      <div id="gantt-splitter" title="드래그하여 간트 높이 조절"></div>
      <button id="gantt-open-btn" class="gantt-open-btn" title="간트 펼치기">▲ 간트</button>
      <section id="gantt-pane">
        <div class="gantt-toolbar">
          <strong>공정현황개발중</strong>
          <span id="gantt-range" class="gantt-range"></span>
          <span style="flex:1"></span>
          <button id="gantt-save-png" class="btn btn-sm">PNG 저장</button>
          <button id="gantt-toggle"   class="btn btn-sm">접기/펼치기</button>
        </div>
        <div id="gantt-top-axis" class="gantt-top-axis"><div class="axis-track"></div></div>
        <div id="gantt-chart"></div>
      </section>
    </div>

    <!-- 외부 라이브러리 -->
    <script src="https://developer.api.autodesk.com/modelderivative/v2/viewers/7.*/viewer3D.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script src="https://unpkg.com/inspire-tree@4.3.1/dist/inspire-tree.js"></script>
    <script src="https://unpkg.com/inspire-tree-dom@4.0.6/dist/inspire-tree-dom.min.js"></script>

    <!-- 메인 부트스트랩 -->
    <script type="module" src="/js/viewer/CustomViewerExtension.js"></script>
    <script type="module" src="/js/main.js"></script>

    <!-- ⚠️ 유지: 좌측 사이드바(파일탭) 리사이저가 이 파일에 있다면 필요 -->
    <script type="module" src="/js/sidebar/task-wbs/layout/sidebar-resizer.js"></script>

    <!-- ⚠️ 제거: main.js에서 import하여 중복 바인딩되던 항목 -->
    <!-- <script type="module" src="/js/sidebar/task-wbs/layout/panel2-resizer.js"></script> -->

    <!-- 뷰 선택 모달 -->
    <div id="view-select-modal" style="display:none;position:fixed;left:50%;top:42%;transform:translate(-50%,-40%);min-width:330px;background:#fff;border-radius:12px;box-shadow:0 4px 32px #2223;z-index:10001;padding:28px 24px 22px 24px;">
      <div style="font-weight:600;font-size:1.1em;margin-bottom:12px;letter-spacing:0.02em;">
        뷰 선택
        <button id="view-close-btn" style="float:right;background:none;border:none;font-size:22px;color:#888;cursor:pointer;margin-right:-8px;margin-top:-8px;" aria-label="닫기">&times;</button>
      </div>
      <div style="margin-bottom:10px">
        <label for="view-type-dropdown" style="font-size:0.97em;font-weight:500">뷰 타입</label>
        <select id="view-type-dropdown" style="width:100%;padding:6px;font-size:1em;margin-top:4px">
          <option value="3d">3D 뷰</option>
          <option value="2d">2D 뷰</option>
        </select>
      </div>
      <div style="margin-bottom:14px">
        <label for="view-list-dropdown" style="font-size:0.97em;font-weight:500">뷰 리스트</label>
        <select id="view-list-dropdown" style="width:100%;padding:6px;font-size:1em;margin-top:4px">
          <!-- JS로 동적 생성 -->
        </select>
      </div>
      <div style="text-align:right">
        <button id="view-ok-btn" style="padding:7px 20px;font-size:1em;background:#1976d2;color:#fff;border:none;border-radius:5px;">확인</button>
        <button id="view-cancel-btn" style="padding:7px 20px;margin-right:8px;font-size:1em">취소</button>
      </div>
    </div>
  </body>
</html>


// /wwwroot/js/sidebar/task-wbs/layout/panel-resizer.js
export function bindPanel2Resizer(viewer){
  const resizer = document.getElementById('sidebar-resizer');
  const root = document.documentElement;
  if (!resizer) return;

  const MIN = 360;       // 사이드바 최소 폭
  const PREVIEW_MIN = 520; // 뷰어 최소 폭(좌표 틀어짐 방지 위한 여유)

  const getMax = () => Math.max(MIN, window.innerWidth - PREVIEW_MIN);

  const getWidth = () => {
    const v = getComputedStyle(root).getPropertyValue('--sidebar-width').trim();
    const n = parseInt(v || '0', 10);
    return Number.isFinite(n) && n > 0 ? n : 900;
  };

  function apply(px){
    const clamped = Math.min(getMax(), Math.max(MIN, Math.round(px)));
    root.style.setProperty('--sidebar-width', clamped + 'px');
    localStorage.setItem('sidebarWidthPx', String(clamped));
    // 좌표 어긋남 방지: 즉시/다음 프레임 두 번 갱신
    try {
      viewer?.resize?.();
      viewer?.impl?.invalidate?.(true, true, true);
      requestAnimationFrame(()=>{
        viewer?.resize?.();
        viewer?.impl?.invalidate?.(true, true, true);
      });
    } catch {}
  }

  // ── Drag handlers
  let dragging = false;
  let startX = 0, startWidth = 0;

  function onDown(e){
    dragging = true;
    startX = e.clientX;
    startWidth = getWidth();
    document.body.classList.add('resizing-x');
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp, { once:true });
    e.preventDefault();
  }
  function onMove(e){
    if (!dragging) return;
    const delta = e.clientX - startX;
    apply(startWidth + delta);
  }
  function onUp(){
    dragging = false;
    document.body.classList.remove('resizing-x');
    window.removeEventListener('mousemove', onMove);
    // 최종 보정
    apply(getWidth());
  }

  // ── Wire events
  resizer.addEventListener('mousedown', onDown);
  resizer.addEventListener('dblclick', () => apply(900));

  // 창 크기 변경 시 현재 폭이 최대치 넘지 않도록 보정
  window.addEventListener('resize', () => {
    const maxNow = getMax();
    const cur = getWidth();
    if (cur > maxNow) apply(maxNow);
  });

  // ── 초기 진입: 저장값 복원 or 900px 기본값
  const stored = parseInt(localStorage.getItem('sidebarWidthPx') || '0', 10);
  const initial = Number.isFinite(stored) && stored >= MIN
    ? Math.min(getMax(), stored)
    : Math.min(getMax(), 900);
  apply(initial);
}


// wwwroot/js/sidebar/sidebar-resizer.js

const sidebar = document.getElementById("sidebar");
const resizer = document.getElementById("sidebar-resizer");
const preview = document.getElementById("preview");
const minWidth = 220; // 최소폭
const maxWidth = 750; // 최대폭

function setSidebarWidth(px) {
  sidebar.style.width = px + "px";
  resizer.style.left = px + "px";
  if (preview) preview.style.left = px + "px";
}

resizer.addEventListener("mousedown", function (e) {
  e.preventDefault();
  document.body.style.cursor = "ew-resize";

  function onMouseMove(e2) {
    let newWidth = e2.clientX;
    if (newWidth < minWidth) newWidth = minWidth;
    if (newWidth > maxWidth) newWidth = maxWidth;
    setSidebarWidth(newWidth);
  }

  function onMouseUp() {
    document.body.style.cursor = "";
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", onMouseUp);
  }

  document.addEventListener("mousemove", onMouseMove);
  document.addEventListener("mouseup", onMouseUp);
});

window.addEventListener("DOMContentLoaded", () => {
  const sidebarRect = sidebar.getBoundingClientRect();
  setSidebarWidth(sidebarRect.width);
});







