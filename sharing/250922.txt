// /wwwroot/js/sidebar/task-wbs/task-buttons.js
import { normalizeTaskCategory, enforceCategoryInheritance } from "./core/categories.js";
import { aggregateTaskFields } from "./logic/task-aggregate.js";
import { scheduleWbsRepaint } from "./ui/wbs-highlight.js";
import { showCurrentTaskModal } from "./ui/current-task-modal.js";
import { notifyCoverageDirtyAndRepaint } from "./ui/wbs-fixed-paint.js";
import { ensureElementIdIndexForDbIds, getElementIdFor, formatObjectLabel } from "./core/element-id.js";

import {
  initWbsStore,
  setProvider as setWbsProvider,
  refreshWbsStore,
  getOrderedDbIdsFromCheckedExact,
  pathOfNode
} from "./core/wbs-store.js";

// ìƒíƒœ ë°˜ì˜ ì•Œë¦¼
function notifyWbsStatusRefresh(){
  try { window.__WBS_MARK_TASKS_CHANGED?.(); } catch {}
}

// íŽ˜ì¸íŠ¸ ë°°ì¹˜(ê°„ë‹¨ ë½)
async function runWbsHighlightBatch(cb){
  const prev = window.__WBS_PAINT_LOCK === true;
  window.__WBS_PAINT_LOCK = true;
  try { await cb(); }
  finally {
    window.__WBS_PAINT_LOCK = prev;
    requestAnimationFrame(()=>{ try{ window.updateWBSHighlight?.(); } catch{} });
  }
}

// ì™¸ë¶€ ì €ìž¥ ìŠ¤ëƒ…ìƒ·
export function setSavedTaskData(data) {
  window.savedTaskData = JSON.parse(JSON.stringify(data ?? []));
}

export function initTaskListButtons() {
  window.__ALLOW_WBS_UPDATE = window.__ALLOW_WBS_UPDATE ?? false;

  // âœ… WBS ì €ìž¥ì†Œ ì´ˆê¸°í™”(íŠ¸ë¦¬/í”„ë¡œë°”ì´ë”)
  try { initWbsStore({ tree: window.wbsTree, provider: window.__WBS_PROVIDER }); } catch(_) {}
  // í”„ë¡œë°”ì´ë”ê°€ ë‚˜ì¤‘ì— ì¤€ë¹„ë  ìˆ˜ë„ ìžˆìœ¼ë‹ˆ í›… ì œê³µ(ì„ íƒ)
  window.__SET_WBS_PROVIDER__ = (p) => { try { setWbsProvider(p); refreshWbsStore(); } catch(_) {} };

  function withWbsGate(fn){
    const prev = window.__ALLOW_WBS_UPDATE;
    window.__ALLOW_WBS_UPDATE = true;
    try { return fn(); }
    finally { window.__ALLOW_WBS_UPDATE = prev; }
  }

  function flush(recalc = false) {
    if (recalc && window.requestTaskRecalcAndFlush) {
      window.requestTaskRecalcAndFlush();
    } else if (window.requestTaskTreeFlush) {
      window.requestTaskTreeFlush();
    } else {
      const tree = $.ui.fancytree.getTree("#treegrid");
      tree.render(true, true);
    }
    if (!window.__WBS_PAINT_LOCK) scheduleWbsRepaint();
  }

  // [ì¶”ê°€]
  $("#btn-add").off("click").on("click", function () {
    const tree = $.ui.fancytree.getTree("#treegrid");
    const sel = tree.getActiveNode();
    const parentNode = sel || null;
    const baseCat = (parentNode?.data?.selectedOption) || "ì‹œê³µ";
    const no = generateNo(parentNode);
    const nodeData = {
      no,
      selectOptions: ["ì‹œê³µ", "ê°€ì„¤", "ì² ê±°"],
      selectedOption: baseCat,
      title: "ìƒˆ ìž‘ì—…",
      start: "",
      end: "",
      linkedObjects: []
    };
    if (parentNode) {
      if (Array.isArray(parentNode.data?.linkedObjects) && parentNode.data.linkedObjects.length) {
        parentNode.data.linkedObjects = [];
        parentNode.render && parentNode.render();
      }
      parentNode.addChildren(nodeData);
      parentNode.setExpanded(true);
      parentNode.data.start = "";
      parentNode.data.end = "";
      parentNode.render && parentNode.render();
    } else {
      tree.getRootNode().addChildren(nodeData);
    }
    enforceCategoryInheritance(tree);
    flush(true);
  });

  // [ì‚­ì œ]
  $("#btn-delete").off("click").on("click", function(){
    const tree = $.ui.fancytree.getTree("#treegrid");
    const sel = tree.getActiveNode();
    if (sel && !sel.isRoot()) {
      sel.remove();
      flush(true);
    }
  });

  // [ê°ì²´ì„ íƒ] â†’ 3D viewer select
  $("#btn-select").off("click").on("click", function() {
    const taskTree = $.ui.fancytree.getTree("#treegrid");
    const selected = taskTree.getActiveNode();
    if (!selected) return alert("Taskë¥¼ ì„ íƒí•˜ì„¸ìš”!");

    const objects = aggregateTaskFields(selected).objects;
    if (!objects || objects.length === 0) return alert("ì´ Task(ë° í•˜ìœ„ Task)ì— ì—°ê²°ëœ ê°ì²´ê°€ ì—†ìŠµë‹ˆë‹¤.");

    const byUrn = {};
    objects.forEach(obj => {
      if (!byUrn[obj.urn]) byUrn[obj.urn] = [];
      byUrn[obj.urn].push(obj.dbId);
    });
    Object.entries(byUrn).forEach(([urn, dbIds]) => {
      if (urn === window.CURRENT_MODEL_URN && window.viewer) {
        window.viewer.select(dbIds);
      }
    });
  });

  // [ì—…ë°ì´íŠ¸] ì €ìž¥
  $("#btn-update").off("click").on("click", async function () {
    const safeUrnVal = window.CURRENT_MODEL_SAFE_URN;
    const url = `/api/tasks?urn=${safeUrnVal}`;
    const currentTaskData = getCurrentTaskDataFromTree();
    const current = JSON.stringify(currentTaskData ?? []);
    const saved   = JSON.stringify(window.savedTaskData ?? []);

    if (!window.savedTaskData || (Array.isArray(window.savedTaskData) && window.savedTaskData.length === 0 && currentTaskData.length > 0)) {
      // ìµœì´ˆ ì €ìž¥ í—ˆìš©
    } else if (current === saved) {
      alert("ìˆ˜ì •ëœ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
      return;
    }

    try {
      const resp = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        credentials: "include",
        body: JSON.stringify(currentTaskData),
      });
      if (resp.ok) {
        alert("Task ë°ì´í„°ê°€ ì €ìž¥ë˜ì—ˆìŠµë‹ˆë‹¤!");
        window.savedTaskData = JSON.parse(JSON.stringify(currentTaskData));
      } else {
        alert("Task ë°ì´í„° ì €ìž¥ ì‹¤íŒ¨!");
      }
    } catch (err) {
      alert("ì €ìž¥ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: " + err.message);
    }
  });

  // [ë°ì´í„°ì—°ê²°] â€” ì²´í¬ë°•ìŠ¤(V) ê¸°ì¤€, í™•ìž¥ ì—†ì´ í›„ì† leaf ìˆ˜ì§‘(WBS ìˆœì„œ ë³´ìž¥) + í´ë°±
  $("#btn-link").off("click").on("click", async function () {
    const taskTree = $.ui.fancytree.getTree("#treegrid");
    const selectedTaskNode = taskTree.getActiveNode();
    if (!selectedTaskNode) return alert("Taskë¥¼ ì„ íƒí•˜ì„¸ìš”!");
    if (selectedTaskNode.hasChildren && selectedTaskNode.hasChildren()) {
      alert("í•˜ìœ„ ìž‘ì—…ì´ ìžˆëŠ” Taskì—ëŠ” ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n ìµœí•˜ìœ„ Taskë¥¼ ì„ íƒí•´ ì£¼ì„¸ìš”.");
      return;
    }

    // ì²´í¬ ìƒíƒœ ìµœì‹ í™”
    try { refreshWbsStore(); } catch(_) {}

    const urn = window.CURRENT_MODEL_URN;
    const catSel = normalizeTaskCategory(selectedTaskNode.data?.selectedOption); // "C"|"T"|"D"
    const catLabel = catSel === "C" ? "ì‹œê³µ" : (catSel === "T" ? "ê°€ì„¤" : "ì² ê±°");

    // 1ì°¨: ì €ìž¥ì†Œ ê¸°ë°˜(ì •í™•ížˆ ì²´í¬ëœ V) â†’ ì‹¤íŒ¨ ì‹œ 2ì°¨ í´ë°±
    let orderedDbIds = [], pathByDbId = new Map();
    try {
      const res = await getOrderedDbIdsFromCheckedExact();
      orderedDbIds = res?.orderedDbIds || [];
      pathByDbId = res?.pathByDbId || new Map();
    } catch(_) {}

    if (!orderedDbIds.length) {
      // ðŸ” í´ë°±: UI íŠ¸ë¦¬ì—ì„œ ì²´í¬ëœ ë…¸ë“œ ìˆ˜ì§‘ â†’ provider BFSë¡œ ìžì† leaf ìˆ˜ì§‘
      const fb = await collectDbIdsFromUITreeFallback();
      orderedDbIds = fb.orderedDbIds;
      pathByDbId = fb.pathByDbId;
    }

    if (!orderedDbIds.length) return alert("WBSì—ì„œ 'ì²´í¬(V)'ëœ í•­ëª©ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");

    // ElementId í”„ë¦¬íŽ˜ì¹˜
    try { await ensureElementIdIndexForDbIds(orderedDbIds); } catch {}

    // ì €ìž¥ìš© ì˜¤ë¸Œì íŠ¸(ê²½ë¡œë¼ë²¨ ë³´ì¡´: "A - B - C - [ElementId|dbId]")
    const toLink = orderedDbIds.map((d) => {
      const p = pathByDbId.get(d) || [];
      const el = getElementIdFor(urn, d);
      const bracket = `[${el || d}]`;
      const pathLabel = p.length ? (p.join(" - ") + " - " + bracket) : bracket;
      return { urn, dbId: d, elementId: el || null, text: pathLabel };
    });

    // ==== ì ìœ /ì¶©ëŒ ì²˜ë¦¬(ê¸°ì¡´ ë¡œì§ ìœ ì§€) ====
    await runWbsHighlightBatch(async () => {
      const occupancy = new Map();
      taskTree.getRootNode().visit(n => {
        const cat = normalizeTaskCategory(n.data?.selectedOption);
        if (!cat) return;
        (n.data?.linkedObjects || []).forEach(o => {
          const key = `${o.urn || urn}:${o.dbId}`;
          const slot = occupancy.get(key) || { C: null, T: null, D: null };
          if (cat === "C" && !slot.C) slot.C = n;
          if (cat === "T" && !slot.T) slot.T = n;
          if (cat === "D" && !slot.D) slot.D = n;
          occupancy.set(key, slot);
        });
      });

      const allowed = [];
      const conflictsForC = [];
      const conflictsC = [];
      const conflictsSame = [];

      toLink.forEach(obj => {
        const key = `${obj.urn}:${obj.dbId}`;
        const slot = occupancy.get(key) || { C: null, T: null, D: null };

        if (catSel === "C") {
          if (!slot.C && !slot.T && !slot.D) allowed.push(obj);
          else conflictsForC.push({ obj, slot });
        } else if (catSel === "T") {
          if (slot.C) conflictsC.push({ obj, slot });
          else if (slot.T) conflictsSame.push({ obj, slot });
          else allowed.push(obj);
        } else if (catSel === "D") {
          if (slot.C) conflictsC.push({ obj, slot });
          else if (slot.D) conflictsSame.push({ obj, slot });
          else allowed.push(obj);
        }
      });

      function unlinkFromNode(node, obj) {
        if (!node) return;
        node.data.linkedObjects = (node.data.linkedObjects || []).filter(
          o => !(String(o.urn || urn) === String(obj.urn) && Number(o.dbId) === Number(obj.dbId))
        );
        node.render && node.render();
      }

      if (catSel === "C" && conflictsForC.length) {
        const res = prompt([
          `ì„ íƒí•œ ê°ì²´ ì¤‘ ${conflictsForC.length}ê°œëŠ” ì´ë¯¸ ë‹¤ë¥¸ Taskì— ì—°ê²°ë˜ì–´ ìžˆìŠµë‹ˆë‹¤.`,
          `ê·œì¹™ìƒ 'ì‹œê³µ'ì€ ë‹¨ë… ì—°ê²°ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤.`,
          ``,
          `1. ê¸°ì¡´ ì—°ê²° í•´ì œ í›„ ì´ Task(ì‹œê³µ)ë¡œ ìƒˆë¡œ ì—°ê²°`,
          `2. ì´ë¯¸ ì—°ê²°ëœ ê°ì²´ë§Œ ì œì™¸í•˜ê³  ì§„í–‰`,
          `3. ì·¨ì†Œ`,
          ``,
          `ë²ˆí˜¸ë¥¼ ìž…ë ¥í•˜ì„¸ìš” (1/2/3)`
        ].join("\n"), "2");
        if (res === "3" || res == null) return;
        if (res === "1") {
          conflictsForC.forEach(({ obj, slot }) => {
            unlinkFromNode(slot.C, obj);
            unlinkFromNode(slot.T, obj);
            unlinkFromNode(slot.D, obj);
            allowed.push(obj);
          });
        }
      }

      if ((catSel === "T" || catSel === "D") && conflictsC.length) {
        const res = prompt([
          `ë‹¤ìŒ ê°ì²´ëŠ” 'ì‹œê³µ'ì— ì´ë¯¸ ì—°ê²°ë˜ì–´ ìžˆì–´ ${catLabel}ê³¼(ì™€) ë³‘í–‰í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`,
          ``,
          `1. ì‹œê³µ ì—°ê²° í•´ì œ í›„ ì´ Task(${catLabel})ë¡œ ìƒˆë¡œ ì—°ê²°`,
          `2. ì´ë¯¸ ì—°ê²°ëœ ê°ì²´ë§Œ ì œì™¸í•˜ê³  ì§„í–‰`,
          `3. ì·¨ì†Œ`,
          ``,
          `ë²ˆí˜¸ë¥¼ ìž…ë ¥í•˜ì„¸ìš” (1/2/3)`
        ].join("\n"), "2");
        if (res === "3" || res == null) return;
        if (res === "1") {
          conflictsC.forEach(({ obj, slot }) => { unlinkFromNode(slot.C, obj); allowed.push(obj); });
        }
      }

      if ((catSel === "T" || catSel === "D") && conflictsSame.length) {
        const label = catLabel;
        const res = prompt([
          `ë‹¤ìŒ ê°ì²´ëŠ” ì´ë¯¸ '${label}'ì— ì—°ê²°ë˜ì–´ ìžˆìŠµë‹ˆë‹¤.`,
          ``,
          `1. ê¸°ì¡´ '${label}' ì—°ê²°ì„ ì´ Taskë¡œ êµì²´ (í•´ë‹¹ ì¹´í…Œê³ ë¦¬ë§Œ êµì²´)`,
          `2. ì´ë¯¸ ì—°ê²°ëœ ê°ì²´ë§Œ ì œì™¸í•˜ê³  ì§„í–‰`,
          `3. ì·¨ì†Œ`,
          ``,
          `ë²ˆí˜¸ë¥¼ ìž…ë ¥í•˜ì„¸ìš” (1/2/3)`
        ].join("\n"), "2");
        if (res === "3" || res == null) return;
        if (res === "1") {
          conflictsSame.forEach(({ obj, slot }) => {
            if (catSel === "T") unlinkFromNode(slot.T, obj);
            if (catSel === "D") unlinkFromNode(slot.D, obj);
            allowed.push(obj);
          });
        }
      }

      if (allowed.length > 0) {
        const existing = selectedTaskNode.data.linkedObjects || [];
        const merged = [];
        const seenKey = new Set();
        const pushUniq = (o) => { const k = o.urn + ":" + o.dbId; if (!seenKey.has(k)) { seenKey.add(k); merged.push(o); } };
        // WBS ìˆœì„œ(allowed) ë¨¼ì €, ê·¸ ë‹¤ìŒ ê¸°ì¡´ í•­ëª©
        allowed.forEach(pushUniq);
        existing.forEach(pushUniq);
        selectedTaskNode.data.linkedObjects = merged;
      }

      withWbsGate(() => {
        flush(true);
        try { window.gantt?.renderFromTrees(window.taskTree, window.wbsTree); } catch(_) {}
      });

      try { await notifyCoverageDirtyAndRepaint(); } catch {}
    });

    notifyWbsStatusRefresh();
  });

  // [ì—°ê²° í•´ì œ]
  $("#btn-unlink").off("click").on("click", async function () {
    const taskTree = $.ui.fancytree.getTree("#treegrid");
    const selectedNode = taskTree.getActiveNode();
    if (!selectedNode) return alert("ì—°ê²°ì„ í•´ì œí•  Taskë¥¼ ì„ íƒí•˜ì„¸ìš”!");

    await runWbsHighlightBatch(async () => {
      (function unlinkAll(node){
        node.data.linkedObjects = [];
        if (node.hasChildren()) node.children.forEach(unlinkAll);
      })(selectedNode);

      withWbsGate(() => {
        flush(true);
        try { window.gantt?.renderFromTrees(window.taskTree, window.wbsTree); } catch(_) {}
      });

      try { await notifyCoverageDirtyAndRepaint(); } catch {}
    });
    notifyWbsStatusRefresh();
  });

  // ê³µì •í˜„í™© ë²„íŠ¼
  $("#btn-date").off("click").on("click", function(){
    showCurrentTaskModal();
  });

  // TEST ë²„íŠ¼
  $("#btn-test").off("click").on("click", async function() {
    initTaskWbsButtons(window.viewer);
  });
}

/* ---------- Fallback: UI íŠ¸ë¦¬ì—ì„œ ì§ì ‘ ì²´í¬ ìˆ˜ì§‘ + provider BFS ---------- */
async function collectDbIdsFromUITreeFallback(){
  const tree = window.wbsTree;
  const provider = window.__WBS_PROVIDER;
  const pathByDbId = new Map();
  const orderedDbIds = [];
  const seen = new Set();

  if (!tree) return { orderedDbIds, pathByDbId };

  // ì²´í¬ ë…¸ë“œ ìˆ˜ì§‘(ì •í™•ížˆ V: partsel ì œì™¸)
  let nodes = [];
  if (typeof tree.getSelectedNodes === "function") {
    nodes = tree.getSelectedNodes(true) || []; // includeHidden=true
  } else if (typeof tree.checked === "function") {
    nodes = tree.checked() || [];
  } else {
    // ì „ìˆ˜ ìˆœíšŒ
    const root = tree.getRootNode?.();
    if (root?.visit) {
      root.visit((n) => {
        const sel = typeof n.isSelected === "function" ? n.isSelected() : !!(n.selected || n.data?.selected || n.data?.checked);
        const part = typeof n.isPartsel === "function" ? n.isPartsel() : !!n.partsel;
        if (sel && !part) nodes.push(n);
      });
    }
  }

  // ë¬¸ì„œ ìˆœì„œ ì •ë ¬
  nodes.sort((a,b) => {
    const ia = (typeof a.getIndexHier === "function") ? a.getIndexHier() : (a.key || a.title || a.text || "");
    const ib = (typeof b.getIndexHier === "function") ? b.getIndexHier() : (b.key || b.title || b.text || "");
    return String(ia).localeCompare(String(ib), undefined, { numeric:true });
  });

  // ê° ë…¸ë“œ ê²½ë¡œì˜ ëª¨ë“  ìžì† leaf dbId ìˆ˜ì§‘(BFS, íŠ¸ë¦¬ ë¯¸í™•ìž¥ë„ ì»¤ë²„)
  for (const node of nodes) {
    const p = pathOfNode(node);
    const ids = await bfsCollectDescendantDbIdsByPath(provider, p, node);
    for (const id of ids) {
      if (!seen.has(id)) {
        seen.add(id);
        orderedDbIds.push(id);
        pathByDbId.set(id, p.slice());
      }
    }
  }
  return { orderedDbIds, pathByDbId };
}

async function bfsCollectDescendantDbIdsByPath(provider, pathArr, visibleNode){
  // 1) ìš°ì„  í™”ë©´ì— ë³´ì´ëŠ” ì„œë¸ŒíŠ¸ë¦¬ì—ì„œ leaf dbId ìˆ˜ì§‘
  const fromVisible = [];
  if (visibleNode?.visit) {
    visibleNode.visit((n) => {
      if (n !== visibleNode && !(n.hasChildren && n.hasChildren())) {
        const id = Number(n.data?.dbId ?? n.dbId);
        if (Number.isFinite(id)) fromVisible.push(id);
      }
    });
  }

  // 2) providerê°€ ìžˆìœ¼ë©´ ë¯¸í‘œì‹œ ìžì†ê¹Œì§€ BFSë¡œ ë³´ê°•
  const fromProvider = [];
  if (provider && typeof provider.childrenByPath === "function") {
    const queue = [ pathArr.slice() ];
    const seenKey = new Set();
    const SEP = "\u0001";

    while (queue.length) {
      const cur = queue.shift();
      const key = cur.join(SEP);
      if (seenKey.has(key)) continue;
      seenKey.add(key);

      let children = [];
      try { children = await provider.childrenByPath(cur); } catch(_) { children = []; }

      for (const ch of (children || [])) {
        const text = String(ch.text || ch.name || "").trim();
        if (!text) continue;
        const id = Number(ch.dbId ?? ch.data?.dbId);
        if (Number.isFinite(id)) {
          fromProvider.push(id);
        } else {
          queue.push(cur.concat(text));
        }
      }
    }
  }

  // ìœ ë‹ˆí¬ + ìˆœì„œ ìœ ì§€(í™”ë©´ â†’ provider)
  const out = [];
  const s = new Set();
  for (const x of fromVisible.concat(fromProvider)) if (!s.has(x)) { s.add(x); out.push(x); }
  return out;
}

/* ---------- Helpers ---------- */

function generateNo(parentNode) {
  if (!parentNode || parentNode.isRoot()) {
    const roots = $.ui.fancytree.getTree("#treegrid").getRootNode().children || [];
    return String(roots.length + 1);
  } else {
    const siblings = parentNode.children || [];
    const baseNo = parentNode.data.no || parentNode.title;
    return baseNo + "." + (siblings.length + 1);
  }
}

function getCurrentTaskDataFromTree() {
  const tree = $.ui.fancytree.getTree("#treegrid");
  const urn = window.CURRENT_MODEL_URN;
  function nodeToData(node) {
    const obj = {
      no: node.data.no,
      selectOptions: node.data.selectOptions ?? ["ì‹œê³µ", "ê°€ì„¤", "ì² ê±°"],
      selectedOption: node.data.selectedOption ?? "ì‹œê³µ",
      title: node.data.title ?? node.title,
      start: node.data.start,
      end: node.data.end,
      linkedObjects: (node.data.linkedObjects || []).map(o => ({
        urn: o.urn ?? urn,
        dbId: o.dbId,
        elementId: o.elementId ?? null,
        text: o.text ?? formatObjectLabel(o),
      })),
    };
    if (node.hasChildren()) obj.children = node.children.map(nodeToData);
    return obj;
  }
  return (tree.getRootNode().children || []).map(nodeToData);
}

/* ====== Test ë²„íŠ¼ ê´€ë ¨ (ê¸°ì¡´) ====== */
export function initTaskWbsButtons(viewer) {
  let btn = document.getElementById('btn-test');
  if (!btn || !viewer) return;

  // ê¸°ì¡´ ë¦¬ìŠ¤ë„ˆ ì¤‘ë³µ ë°©ì§€: í´ë¡  êµì²´
  const clone = btn.cloneNode(true);
  btn.parentNode.replaceChild(clone, btn);
  btn = clone;

  btn.addEventListener('click', async () => {
    try {
      await runTestAnimation(viewer);
    } catch (e) {
      console.error('[test-btn] error:', e);
    }
  });
}

async function runTestAnimation(viewer) {
  const sel = getSelectionSmart(viewer);
  if (!sel || !sel.model || !sel.dbIds.length) {
    console.warn('[test-btn] ë¨¼ì € ê°ì²´ë¥¼ ì„ íƒí•˜ì„¸ìš”.');
    return;
  }

  const { model, dbIds } = sel;
  viewer.clearSelection();

  const fragIds = collectFragIds(model, dbIds);
  if (!fragIds.length) return;

  const store = prepareFragStates(viewer, model, fragIds);

  const MOVE_Z = 5.0; // m ê¸°ì¤€
  const D1 = 2000;    // 2ì´ˆ: ì´ë™ + íŽ˜ì´ë“œì•„ì›ƒ
  const HOLD = 1000;  // 1ì´ˆ ì •ì§€
  const D2 = 2000;    // 2ì´ˆ: ë³µê·€ + íŽ˜ì´ë“œì¸

  const THREE = window.THREE || Autodesk.Viewing.THREE;
  const FALLBACK_COLOR = new THREE.Color(1.0, 0.45, 0.0); // #FF7300

  // OUT
  await animate(D1, (t) => {
    const k = easeInOutSine(t);
    const alphaOut = 1 - k;
    const dz = lerp(0, MOVE_Z, k);

    for (const f of store) {
      f.proxy.position.z = f.startPos.z + dz;
      f.proxy.updateAnimTransform();

      if (f.cloneMat) {
        f.cloneMat.opacity = alphaOut;
        f.cloneMat.transparent = true;
        f.cloneMat.needsUpdate = true;

        if (f.cloneMat.color && f.originalColor) {
          f.cloneMat.color.copy(f.originalColor).lerp(FALLBACK_COLOR, k);
        }
      }
    }
    viewer.impl.invalidate(true, true, true);
  });

  await delay(HOLD);

  // IN
  await animate(D2, (t) => {
    const k = easeInOutSine(t);
    const alphaIn = k;
    const dz = lerp(MOVE_Z, 0, k);

    for (const f of store) {
      f.proxy.position.z = f.startPos.z + dz;
      f.proxy.updateAnimTransform();

      if (f.cloneMat) {
        f.cloneMat.opacity = alphaIn;
        f.cloneMat.transparent = true;
        f.cloneMat.needsUpdate = true;

        if (f.cloneMat.color && f.originalColor) {
          f.cloneMat.color.copy(FALLBACK_COLOR).lerp(f.originalColor, k);
        }
      }
    }
    viewer.impl.invalidate(true, true, true);
  });

  // ë³µêµ¬
  restoreFragStates(viewer, store);
}

// ================= Helpers for Test =================

function getSelectionSmart(viewer) {
  const agg = viewer.getAggregateSelection?.();
  if (agg && agg.length > 0) {
    const a = agg[0];
    const ids = (a.selection || []).slice();
    return ids.length ? { model: a.model, dbIds: ids, aggregate: true } : null;
  }
  const ids = viewer.getSelection?.() || [];
  return (ids && ids.length) ? { model: viewer.model, dbIds: ids, aggregate: false } : null;
}

function collectFragIds(model, dbIds) {
  const it = model.getData().instanceTree;
  const fragIds = [];
  dbIds.forEach((dbId) => {
    it.enumNodeFragments(dbId, (fragId) => fragIds.push(fragId), true);
  });
  return fragIds;
}

function getFragList(viewer, model) {
  if (model?.getFragmentList) return model.getFragmentList();
  if (viewer?.model?.getFragmentList) return viewer.model.getFragmentList();
  return null;
}

function prepareFragStates(viewer, model, fragIds) {
  const THREE = window.THREE || Autodesk.Viewing.THREE;
  const matman = viewer.impl.matman ? viewer.impl.matman() : null;
  const fragList = getFragList(viewer, model);
  const store = [];

  const fragToDb = {};
  if (fragList) {
    fragIds.forEach((fragId) => {
      try { fragToDb[fragId] = fragList.getDbId(fragId); } catch (_) {}
    });
  }

  for (const fragId of fragIds) {
    const proxy = viewer.impl.getFragmentProxy(model, fragId);
    proxy.getAnimTransform();
    const startPos = new THREE.Vector3(proxy.position.x, proxy.position.y, proxy.position.z);

    const rp = viewer.impl.getRenderProxy(model, fragId);
    const originalMat = rp?.material || null;

    let originalColor = null;
    if (originalMat && originalMat.color) originalColor = originalMat.color.clone();

    let cloneMat = null;
    if (originalMat) {
      cloneMat = (matman && matman.cloneMaterial) ? matman.cloneMaterial(originalMat) : originalMat.clone();
      cloneMat.transparent = true;
      cloneMat.opacity = 1.0;
      cloneMat.depthWrite = false;
      cloneMat.side = originalMat.side;
      cloneMat.needsUpdate = true;

      if (viewer.impl.setMaterial) {
        viewer.impl.setMaterial(model, fragId, cloneMat);
      } else if (fragList?.setMaterial) {
        fragList.setMaterial(fragId, cloneMat);
      } else if (viewer.impl.setFragmentMaterial) {
        viewer.impl.setFragmentMaterial(fragId, cloneMat);
      }
    }

    store.push({
      model, fragId,
      dbId: fragToDb[fragId],
      proxy, startPos,
      renderProxy: rp,
      originalMat, cloneMat,
      originalColor
    });
  }
  viewer.impl.invalidate(true, true, true);
  return store;
}

function restoreFragStates(viewer, store) {
  if (!store.length) return;
  const model = store[0].model;
  const fragList = getFragList(viewer, model);

  for (const f of store) {
    f.proxy.position.copy(f.startPos);
    f.proxy.updateAnimTransform();

    if (f.originalMat) {
      if (viewer.impl.setMaterial) {
        viewer.impl.setMaterial(f.model, f.fragId, f.originalMat);
      } else if (fragList?.setMaterial) {
        fragList.setMaterial(f.fragId, f.originalMat);
      } else if (viewer.impl.setFragmentMaterial) {
        viewer.impl.setFragmentMaterial(f.fragId, f.originalMat);
      }
    }
    if (f.cloneMat?.dispose) f.cloneMat.dispose();
  }

  viewer.impl.invalidate(true, true, true);
}

function lerp(a, b, t) { return a + (b - a) * t; }
function delay(ms) { return new Promise((res) => setTimeout(res, ms)); }

function animate(duration, step) {
  return new Promise((resolve) => {
    const start = performance.now();
    function frame(now) {
      const t = Math.min(1, (now - start) / duration);
      step(t);
      if (t < 1) requestAnimationFrame(frame);
      else resolve();
    }
    requestAnimationFrame(frame);
  });
}

function easeInOutSine(t){ return 0.5 - 0.5 * Math.cos(Math.PI * t); }