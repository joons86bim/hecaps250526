import { toKey } from "../core/path-key.js";
import {
  initMatrix, 
  bulkEnsureForVisible,
  computePathState, 
  getCounts,
  markTasksChanged
} from "../core/matrix-index.js";

const HIDDEN_KEYS = new Set();
const _subtreeBusy = new Set();

// --- 현황 계산 헬퍼 ---
function keyDepth(k){ return (k?.split("¦") || []).length; }

function addCounts(dst, src){
  if (!src) return;
  dst.c = (dst.c || 0) + Number(src.c || 0);
  dst.t = (dst.t || 0) + Number(src.t || 0);
  dst.d = (dst.d || 0) + Number(src.d || 0);
}

// 화면 표시용으로 td를 T/D에 반영
function toDisplayCounts(raw){
  if (!raw) return null;
  const td = Number(raw.td || 0);
  return {
    c: Number(raw.c || 0),
    t: Number(raw.t || 0) + td,
    d: Number(raw.d || 0) + td,
  };
}

// “데이터가 있나?” 판정할 때 td도 포함해야 함
function sum3(x){
  return Number(x?.c || 0) + Number(x?.t || 0) + Number(x?.d || 0) + Number(x?.td || 0);
}

function calcStateByCounts(counts) {
  if (!counts) return "";
  if ((counts.t || 0) > 0 && (counts.d || 0) > 0) return "TD";
  if ((counts.c || 0) > 0) return "C";
  if ((counts.t || 0) > 0) return "T";
  if ((counts.d || 0) > 0) return "D";
  return "";
}

async function ensureCountsForNode(node){
  const key = node?.data?.pathKey;
  if (!key) return;
  if (getCounts(key)) return; // 이미 계산돼 있으면 스킵
  await bulkEnsureForVisible([key]);
  computePathState(key);
}

function normalizeSeg(s) {
  let x = (s ?? "").toString();
  x = x.replace(/\s+/g, " ").trim();
  x = x.replace(/[\u2010-\u2015\u2212\u2043]/g, "-");
  x = x.replace(/[\u200B-\u200D\uFEFF]/g, "");
  return x;
}

function normalizePath(pathArr) {
  return (pathArr || []).map(normalizeSeg);
}

// 브랜치(자기+자식) 보장+계산 (렌더는 옵션)
async function ensureCountsForSubtree(provider, node, { noRender = false } = {}){
  const key  = node?.data?.pathKey;
  const path = node?.data?.__path || buildPathFromNode(node);
  if (!key || !path) return;

  if (_subtreeBusy.has(key)) return; // 중복 실행 방지
  _subtreeBusy.add(key);

  try {
    const keys = await collectAllPathKeys(provider, path);
    const uniq = Array.from(new Set(keys.length ? keys : [key]));

    if (uniq.length) {
      await bulkEnsureForVisible(uniq);
      uniq.forEach(k => computePathState(k));

      // 가장 깊은 레벨만 합산
      const levels = new Map(); // depth -> rawCounts[]
      for (const k of uniq){
        const c = getCounts(k);
        if (c && sum3(c) > 0){
          const d = keyDepth(k);
          if (!levels.has(d)) levels.set(d, []);
          levels.get(d).push(c);
        }
      }

      let totals = { c: 0, t: 0, d: 0 };
      if (levels.size){
        const depths = Array.from(levels.keys()).sort((a,b)=>a-b);
        const deepest = depths[depths.length - 1];
        for (const raw of (levels.get(deepest) || [])) {
          const disp = toDisplayCounts(raw);
          addCounts(totals, disp);
        }
      }
      node.data.__aggCounts = totals; // 폴백 합계 저장
    }

    if (!noRender) {
      const tree = node.tree;
      setTimeout(() => { try { tree.render(true); } catch {} }, 0);
    }
  } finally {
    setTimeout(() => _subtreeBusy.delete(key), 50);
  }
}

async function ensureCountsForAllRoots(tree, provider){
  const roots = tree.getRootNode().children || [];
  const all = [];
  for (const r of roots){
    const p = r.data?.__path || [r.title];
    const ks = await collectAllPathKeys(provider, p);
    all.push(...ks);
  }
  const uniq = Array.from(new Set(all));
  if (uniq.length) {
    await bulkEnsureForVisible(uniq);
    uniq.forEach(k => computePathState(k));
  }
  try { tree.render(true, true); } catch {}
}

// -----------------------------------------------------------------------------------

// 서브트리 pathKey 전부 수집 (트리 확장 여부와 무관)
async function collectAllPathKeys(provider, startPath, cap = 20000) {
  const keys = [];
  const q = [normalizePath(startPath)];
  const seen = new Set();
  while (q.length && cap > 0) {
    const p = q.shift();
    const k = toKey(p);
    if (seen.has(k)) continue;
    seen.add(k);
    keys.push(k);
    let children = [];
    try { children = await provider.childrenByPath(p) || []; } catch {}
    cap -= children.length;
    for (const ch of children) {
      const cp = ch.__path ? normalizePath(ch.__path) : [...p, normalizeSeg(ch.text)];
      q.push(cp);
    }
  }
  return keys;
}

// 토글 전용: 미구축이면 서브트리를 강제 구축 후, 완전한 id 목록을 반환
async function getAllDbIdsForPathStrict(provider, node, path){
  const out = new Set();
  const q = [path];
  let guard = 0;
  while (q.length && guard < 50000) {
    const p = q.shift();
    //현재 경로의 직접 매핑 강제 확보
    let here = provider.getDbIdsForPath(p, { includeDescendants:false, allowUnbuilt:true }) || [];
    if (!here.length) {
      //그룹노드 보정: 자손 매핑이라도 즉시 반영
      here = provider.getDbIdsForPath(p, { includeDescendants:true, allowUnbuilt:true }) || [];
    }
    for (const id of here) out.add(id);
    //자식 로드 & 큐잉
    let children = [];
    try { children = await provider.childrenByPath(p) || []; } catch {}
    for (const ch of children) {
      const cp = ch.__path || [...p, ch.text];
      q.push(cp);
    }
    guard += children.length + here.length;
  }
  //마지막으로 '완전체'가 있으면 합쳐서 반환
  const all = provider.getDbIdsForPath(path, { includeDescendants:true, allowUnbuilt:true }) || [];
  for (const id of all) out.add(id);
  return Array.from(out);
}

// 지정 경로의 자손들을 제한적으로 미리 로드 (BFS)
async function warmupDescendants(provider, path, maxDepth = 6, cap = 1200) {
  const q = [{ path, depth: 0 }];
  let seen = 0;
  while (q.length && seen < cap) {
    const { path: p, depth } = q.shift();
    let children = [];
    try { children = await provider.childrenByPath(p) || []; } catch {}
    seen += children.length;
    if (depth >= maxDepth) continue;
    for (const ch of children) {
      if (ch?.children === true) {
        const np = ch.__path || [...p, ch.text];
        q.push({ path: np, depth: depth + 1 });
      }
    }
  }
}

// 현재 노드의 눈알 아이콘(class/markup)만 즉시 갱신
function updateEyeDom(n) {
  if (!n?.span) return;
  const s = calcEyeStateForNode(n);
  const $nodeSpan = $(n.span);
  let $eye = $nodeSpan.children(".eye-toggle");
  const icon = (s === "none") ? Eye : EyeOff;

  if ($eye.length === 0) {
    const $icon = $nodeSpan.children(".fancytree-icon");
    $icon.hide().addClass("eye-hidden");
    $eye = $(`<span class="eye-toggle ${s}" title="가시성 토글">${icon}</span>`);
    $icon.before($eye);
  } else {
    $eye.removeClass("mixed none").addClass(s).html(icon);
  }
}

function buildPathFromNode(node){
  const out = [];
  let cur = node;
  while (cur && !cur.isRoot()) {
     out.unshift(normalizeSeg(cur.title));
     cur = cur.parent; 
  }
  return out;
}

function stateToClass(st){
  if (st === "C") return "wbs-c";
  if (st === "TD" || st === "T" || st === "D") return "wbs-td";
  return "";
}

//값이 Promise든 배열이든/undefined든 전부 Promise로 감싸서 처리
function asPromise(v){
  return (v && typeof v.then === "function") ? v : Promise.resolve(v);
}

// 눈알 SVG
const Eye = `
<svg viewBox="0 0 24 24" aria-hidden="true">
  <path d="M12 5c5 0 9 4 10 7-1 3-5 7-10 7S3 15 2 12c1-3 5-7 10-7Zm0 3a4 4 0 100 8 4 4 0 000-8Z"/>
</svg>`;
const EyeOff = `
<svg viewBox="0 0 24 24" aria-hidden="true">
  <path d="M3 3l18 18M10.58 10.58A4 4 0 0012 16a4 4 0 002.83-6.83M12 5c5 0 9 4 10 7-.43 1.28-1.33 2.7-2.6 3.98M6.62 6.62C4.62 8.05 3.28 9.94 2 12c1 3 5 7 10 7 1.28 0 2.5-.22 3.62-.62"/>
</svg>`;

// 경로→dbId 수집 (click/dblclick 때만 호출: 초기 렌더에는 안 돌게)
async function getAllDbIdsForPath(provider, path){
  let ids = provider.getDbIdsForPath(path, { includeDescendants:true, allowUnbuilt:true });
  if (ids != null) return ids;
  try { await warmupDescendants(provider, path, 6, 1200); } catch {}
  ids = provider.getDbIdsForPath(path, { includeDescendants:true, allowUnbuilt:true });
  if (ids != null) return ids;
  return provider.getDbIdsForPath(path, { includeDescendants:true, allowUnbuilt:false }) || [];
}

function calcEyeStateForNode(node){
  const key = node.data?.pathKey;
  if (!key) return "none";
  if (HIDDEN_KEYS.has(key)) return "mixed"; // 자기자신 숨김→mixed

  // 1) 조상 중 하나라도 숨김이면 mixed
  const ancestors = node.getParentList(false, true) || [];
  for (const p of ancestors) {
    const k = p.data?.pathKey;
    if (k && HIDDEN_KEYS.has(k)) return "mixed";
  }

  // 2) 자손 중 숨김이 있으면 mixed
  let anyHidden = false;
  node.visit(n => {
    const k = n.data?.pathKey;
    if (k && HIDDEN_KEYS.has(k)) anyHidden = true;
  });
  return anyHidden ? "mixed" : "none";
}

export async function initWbsWithFancytree(provider, { primaryOrder } = {}) {
  if(!window.__MATRIX_READY) {
    await initMatrix({ primaryOrder, provider });
    window.__MATRIX_READY = true;
  }

  // 테이블 뼈대
  const host = document.getElementById("wbs-group-content");
  host.innerHTML = `
    <table id="wbs-tree" class="table table-sm wbs-table">
      <colgroup>
        <col class="col-title" />
        <col class="col-count" />
        <col class="col-status" />
      </colgroup>
      <thead>
        <tr>
          <th>항목</th>
          <th class="text-center">개수</th>
          <th>현황</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  `;

  $("#wbs-tree").fancytree({
    extensions: ["table", "gridnav"],   // checkbox 확장 넣지 마세요
    checkbox: true,                     // 체크박스는 옵션으로만
    selectMode: 3,

    // ✅ source: jQuery Deferred
    source: function(){
      const d = new $.Deferred();
      try{
        asPromise(provider?.roots?.()).then((nodes) => {
          const arr = Array.isArray(nodes) ? nodes : [];
          d.resolve(arr.map(ch => {
            const basePath = ch.__path ? normalizePath(ch.__path) : [normalizeSeg(ch.text)];
            return {
              title: ch.text,
              lazy: ch.children === true,
              data: {
                __path: basePath,
                pathKey: toKey(basePath),
                leafCount: ch.leafCount || 0,
                dbId: ch.dbId,
                elementId: ch.elementId
              }
            }
          }));
        }).catch(() => d.resolve([]));
      } catch {
        d.resolve([]);
      }
      return d.promise();
    },

    // ✅ lazyLoad: 역시 Deferred
    lazyLoad: function(event, data){
      const node = data.node;
      const path = node.data?.__path || buildPathFromNode(node);
      const d = new $.Deferred();
      try {
        asPromise(provider?.childrenByPath?.(path)).then((children)=>{
          const arr = Array.isArray(children) ? children : [];
          d.resolve(arr.map(ch => {
            const seg    = normalizeSeg(ch.text);
            const __path = ch.__path ? normalizePath(ch.__path) : [...path, seg];
            return {
              title: seg,
              lazy: ch.children === true,
              data: {
                __path,
                pathKey: toKey(__path),
                leafCount: ch.leafCount || 0,
                dbId: ch.dbId,
                elementId: ch.elementId
              }
            };  
          }));
        }).catch(() => d.resolve([]));
      } catch {
        d.resolve([]);
      }
      data.result = d.promise();
    },

    loadChildren: async function(event, data){
      try {
        // 계산만 하고(렌더 금지)
        await ensureCountsForSubtree(provider, data.node, { noRender: true });
      } catch (e) {
        console.warn("[WBS] loadChildren compute failed:", e);
      } finally {
        // 콜스택을 벗어난 뒤에 테이블 전체 렌더 1회
        const tree = data.tree;
        setTimeout(() => { try { tree.render(true); } catch {} }, 0);
      }
    },

    table: { indentation: 14, nodeColumnIdx: 0 },

    // 초기 렌더: 계산 유발 금지
    renderColumns: function(_event, data) {
      const node  = data.node;
      const $tds  = $(node.tr).find(">td");

      // 0) 타이틀 칼럼: 눈알
      const $nodeSpan  = $(node.span);
      const eyeState   = calcEyeStateForNode(node);
      const $eye       = $nodeSpan.children(".eye-toggle");
      const icon       = (eyeState === "none") ? Eye : EyeOff;

      if ($eye.length) {
        $eye.removeClass("mixed none")
          .addClass(eyeState)
          .attr("title", "가시성 토글")
          .html(icon);
      } else {
        const $iconSpan  = $nodeSpan.children(".fancytree-icon");
        $iconSpan.hide().addClass("eye-hidden");
        $iconSpan.before(
          $(`<span class="eye-toggle ${eyeState}" title="가시성 토글">${icon}</span>`)
        );
      }

      // 1) 개수 칼럼: 가운데 정렬
      const $cntCell = $tds.eq(1).removeClass("text-end").addClass("text-center");
      if (node.data?.dbId != null) {
        $cntCell.text("");
      } else {
        const cnt = node.data?.leafCount;
        $cntCell.text((typeof cnt === "number") ? String(cnt) : "…");
      }

      // 2) 현황 칼럼
      const $statusCell = $tds.eq(2);
      if (node.data?.dbId != null) {
        $statusCell.text(""); // 말단은 빈칸
      } else {
        const key = node.data?.pathKey;
        const raw = key && getCounts(key);
        let counts = toDisplayCounts(raw);

        if ((!counts || sum3(counts) === 0) && node.data?.__aggCounts) {
          counts = node.data.__aggCounts;
        }

        const st  = calcStateByCounts(counts);
        const cls = stateToClass(st);
        $(node.tr).removeClass("wbs-c wbs-t wbs-d wbs-td");
        if (cls) $(node.tr).addClass(cls);

        if (counts && (typeof counts.c === "number" || typeof counts.t === "number" || typeof counts.d === "number")) {
          $statusCell
            .addClass("text-center")
            .html(`
              <div class="wbs-status" style="justify-content: center;">
                <div class="nums">
                  <span class="b c" title="시공">${counts.c ?? 0}</span>
                  <span class="b t" title="가설">${counts.t ?? 0}</span>
                  <span class="b d" title="철거">${counts.d ?? 0}</span>
                </div>
              </div>
            `);
        } else {
          $statusCell.text("…");
          if (!node.data.__countsRequested && key) {
            node.data.__countsRequested = true;
            ensureCountsForNode(node)
              .then(() => {
                const tree = $.ui.fancytree.getTree("#wbs-tree");
                setTimeout(() => { try { tree.render(true); } catch {} }, 0);
              })
              .finally(() => { node.data.__countsRequested = false; });
          }
        }

        // 불일치 자동 복구 (1회)
        if (key) {
          const totalShown = (counts?.c || 0) + (counts?.t || 0) + (counts?.d || 0);
          const likelyWrong =
            ((node.data?.leafCount || 0) > 0) &&
            totalShown === 0 &&
            !node.data.__countsRepairOnce;

          if (likelyWrong) {
            node.data.__countsRepairOnce = true;
            ensureCountsForSubtree(provider, node)
              .then(() => { try { node.render(true); } catch {} })
              .finally(() => { node.data.__countsRepairOnce = false; });
          }
        }
      }
    },

    // 확장: 계산만 하고(렌더는 다음 틱)
    expand: async function(_event, data) {
      try {
        await ensureCountsForSubtree(provider, data.node, { noRender: true });
      } catch(e) {
        console.warn("[WBS] expand compute failed:", e);
      } finally {
        const tree = data.tree;
        setTimeout(() => { try { tree.render(true); } catch {} }, 0);
      }
    },

    // 더블클릭: 선택 동작 유지(확장/축소 차단)
    dblclick: function(event, data){
      const node = data.node;
      (async ()=>{
        const viewer = window.viewer;
        if (!viewer) return;
        let ids = [];
        if (node.data?.dbId != null) {
          ids = [node.data.dbId];
        } else {
          const path = node.data?.__path || buildPathFromNode(node);
          ids = await getAllDbIdsForPath(provider, path);
        }
        try {
          const cur = viewer.getSelection();
          const same = (cur?.length === ids.length) && cur.every((v,i)=>v===ids[i]);
          viewer.clearSelection();
          if (!same && ids?.length) viewer.select(ids);
        } catch {}
      })();
      if (event?.preventDefault) event.preventDefault();
      if (data?.originalEvent?.preventDefault) data.originalEvent.preventDefault();
      return false;
    },

    // 클릭: 눈알은 통과, 그 외 title/icon은 기본 막음
    click: function(event, data){
      const t = data.targetType; // expander | title | icon | checkbox
      const isEye = event?.originalEvent?.target?.closest?.(".eye-toggle");
      if (isEye) return; // 눈알은 위임 핸들러가 처리
      if (t === "expander" || t === "checkbox") return; // 기본 동작 허용
      event.preventDefault();
      return false;
    },

    // 초기 데이터 로드 후 루트 한 번 계산
    init: function(event, data){
      setTimeout(async () => {
        try {
          await ensureCountsForAllRoots(data.tree, provider);
        } catch(e) {
          console.warn("[WBS] initial compute failed:", e);
        }
      }, 0);
    },

    // 선택 후 안전하게 전체 1회 렌더
    select: function(_event, data){
      const tree = data.tree;
      setTimeout(() => { try { tree.render(true); } catch {} }, 0);
    }
  });

  window.wbsTree = $.ui.fancytree.getTree("#wbs-tree");

  //디버깅
  window.__WBS_DEBUG = {
    tree: () => $.ui.fancytree.getTree("#wbs-tree"),
    provider,
    getCounts,
    computePathState,
    bulkEnsureForVisible,
    collectAllPathKeys,
    ensureCountsForSubtree,
    ensureCountsForNode,
    toKey
  };

  // 눈알 토글: 위임
  $("#wbs-tree").on("click", ".eye-toggle", async (e) => {
    e.stopPropagation();
    const el = e.currentTarget;
    const node = $.ui.fancytree.getNode(el);
    if (!node) return;
  
    const viewer = window.viewer;
    if (!viewer) return;
  
    const state   = calcEyeStateForNode(node);
    const hideAll = (state === "none");         // none → 숨기기, mixed → 보이기
  
    const path   = node.data?.__path || buildPathFromNode(node);
    const idsAll = await getAllDbIdsForPathStrict(provider, node, path);
    if (!idsAll?.length) return;
    const allKeys = await collectAllPathKeys(provider, path);
    
    console.debug("[eye] hideAll=", hideAll, "ids=", idsAll.length, idsAll.slice(0, 10));

    try {
      if (hideAll) {
        viewer.hide(idsAll);
        allKeys.forEach(k => HIDDEN_KEYS.add(k));
      } else {
        viewer.show(idsAll);
        allKeys.forEach(k => HIDDEN_KEYS.delete(k));
      }
    } finally {
      // 즉시 : 자신/자식들 아이콘 갱신 + 해당 행/부모행 재렌더
      node.visit(updateEyeDom);
      node.getParentList(false, true)?.forEach(updateEyeDom);
      try { node.render(true); } catch {}
      try { node.getParentList(false, true)?.forEach(p => p.render(true)); } catch {}
    }
  });

  // Task 갱신 → 현황 반영(배치 1회)
  window.__WBS_MARK_TASKS_CHANGED = function(){
    try {
      markTasksChanged();
      const tree = $.ui.fancytree.getTree("#wbs-tree");
      if (!tree) return;
      const keys = [];
      tree.getRootNode().visit(n => { if (n.data?.pathKey) keys.push(n.data.pathKey); });
      bulkEnsureForVisible(keys).then(() => {
        keys.forEach(k => computePathState(k));
        tree.render(true, true);
      });
    } catch(e) {
      console.warn("[WBS] tasks changed failed:", e);
    }
  };
}



// /wwwroot/js/main.js — 첫 로딩 WBS 셀 색칠 보장 (배지 제거/최적화)

import { initTabs } from "./sidebar/init-tabs.js";
import { initTree } from "./sidebar/init-tree.js";
import { initViewer, loadModel } from "./viewer/init-viewer.js";
import { buildWbsProviderLazy } from "./sidebar/task-wbs/wbs/loader.js";
import { bindPanel2Resizer } from "./sidebar/task-wbs/layout/panel-resizer.js";

import {
  initMatrix,
  bulkEnsureForVisible,
  computePathState,
  getCounts as _getCountsImported,
  markTasksChanged,
} from "./sidebar/task-wbs/core/matrix-index.js";

import { toKey } from "./sidebar/task-wbs/core/path-key.js";
import { initWbsStore } from "./sidebar/task-wbs/core/wbs-store.js";

import {
  initTaskPanel,
  initTaskListButtons,
  setSavedTaskData,
  disableViewerEscReset,
  initWbsPanelWithFancytree,
} from "./sidebar/index.js";

/* ──────────────────────────────────────────────────────────────
   전역/기본 설정
────────────────────────────────────────────────────────────── */
try {
  window.__WBS_DEBUG = window.__WBS_DEBUG || {};
  window.getCounts = _getCountsImported;
  window.markTasksChanged = markTasksChanged;
} catch {}

const SIDEBAR_MIN = 360;
const SIDEBAR_DEFAULT = 900;
const PREVIEW_MIN = 520;

window.__FA_FALLBACK_BY_KEY = Object.create(null); // 폴백 count 저장소

function initSidebarWidth() {
  const root = document.documentElement;
  const stored = parseInt(localStorage.getItem("sidebarWidthPx") || "0", 10);
  const maxNow = Math.max(SIDEBAR_MIN, window.innerWidth - PREVIEW_MIN);
  const initial = Number.isFinite(stored) && stored >= SIDEBAR_MIN
    ? Math.min(maxNow, stored)
    : Math.min(maxNow, SIDEBAR_DEFAULT);
  root.style.setProperty("--sidebar-width", initial + "px");
  return initial;
}

function resetViewerInputAndCamera(viewer) {
  try {
    const tc = viewer.toolController;
    if (tc?.isToolActivated?.("BoxSelectionTool")) tc.deactivateTool("BoxSelectionTool");
    viewer.setNavigationLock(false);
    const fallbackNav = viewer.impl?.is2d ? "pan" : "orbit";
    viewer.setActiveNavigationTool?.(fallbackNav);
    viewer.setSelectionMode(Autodesk.Viewing.SelectionMode.MIXED);
    viewer.clearSelection?.();
    if (!viewer.impl?.is2d) {
      viewer.navigation.setWorldUpVector(new THREE.Vector3(0, 0, 1), true);
      const bb = viewer.model?.getBoundingBox?.();
      if (bb) {
        const center = bb.getCenter(new THREE.Vector3());
        viewer.navigation.setPivotPoint(center);
        viewer.navigation.setTarget(center);
      }
    }
    viewer.fitToView?.();
  } catch {}
}

/* ──────────────────────────────────────────────────────────────
   뷰어 대기 유틸
────────────────────────────────────────────────────────────── */
function onceViewer(viewer, type) {
  return new Promise((resolve) => {
    const h = () => { try { viewer.removeEventListener(type, h); } catch {} ; resolve(); };
    viewer.addEventListener(type, h);
  });
}
function hasObjectTree(viewer) {
  return !!viewer.model?.getData?.()?.instanceTree;
}
async function waitObjectTree(viewer) {
  if (hasObjectTree(viewer)) return;
  await onceViewer(viewer, Autodesk.Viewing.OBJECT_TREE_CREATED_EVENT);
}
async function waitGeometry(viewer, timeoutMs = 180000) {
  await new Promise((resolve) => {
    let done = false;
    const h = () => { if (done) return; done = true; try { viewer.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, h); } catch {} ; resolve(); };
    viewer.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, h, { once: true });
    setTimeout(h, timeoutMs);
  });
}
async function waitPropertyDb(viewer, timeoutMs = 120000) {
  try { if (viewer?.model?.getPropertyDb?.()) return; } catch {}
  await new Promise((resolve) => {
    let done = false;
    const h = () => { if (done) return; done = true; try { viewer.removeEventListener(Autodesk.Viewing.PROPERTY_DB_CREATED_EVENT, h); } catch {} ; resolve(); };
    viewer.addEventListener(Autodesk.Viewing.PROPERTY_DB_CREATED_EVENT, h, { once: true });
    setTimeout(h, timeoutMs);
  });
}
function waitIdle(timeout = 60) {
  return new Promise((resolve) => {
    if (typeof window.requestIdleCallback === "function") {
      window.requestIdleCallback(() => resolve(), { timeout });
    } else setTimeout(resolve, timeout);
  });
}
async function waitViewerReady(viewer) {
  await Promise.all([ waitObjectTree(viewer), waitPropertyDb(viewer), waitGeometry(viewer) ]);
  await waitIdle(60);
}
async function focusCameraAndWait(viewer) {
  return new Promise((resolve) => {
    const onCam = () => { try { viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, onCam); } catch {}; requestAnimationFrame(() => resolve()); };
    viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, onCam, { once: true });
    resetViewerInputAndCamera(viewer);
  });
}

/* ──────────────────────────────────────────────────────────────
   태스크/URN 유틸
────────────────────────────────────────────────────────────── */
function safeUrn(urn) { return urn.replace(/[^a-zA-Z0-9]/g, "_"); }
function fillUrnRecursive(task, defaultUrn) {
  if (Array.isArray(task.linkedObjects)) {
    task.linkedObjects.forEach((o) => { if (!o.urn) o.urn = defaultUrn || window.CURRENT_MODEL_URN; });
  }
  if (Array.isArray(task.children)) {
    task.children.forEach((child) => fillUrnRecursive(child, defaultUrn));
  }
}
function persistTasksSnapshot(tasks) {
  const RAW  = window.CURRENT_MODEL_URN;
  const SAFE = window.CURRENT_MODEL_SAFE_URN;
  if (!RAW || !SAFE) return;
  try {
    const json = JSON.stringify(tasks || []);
    localStorage.setItem(`hec:tasks:${RAW}`, json);
    localStorage.setItem(`hec:tasks:${SAFE}`, json);
    window.__SAVED_TASKS = (tasks || []);
    console.log("[persistTasksSnapshot] saved. count =", window.__SAVED_TASKS.length);
  } catch (e) {
    console.warn("[persistTasksSnapshot] failed:", e);
  }
}

/* ──────────────────────────────────────────────────────────────
   Provider 워밍업 / 폴백 집계
────────────────────────────────────────────────────────────── */
async function seedDbIdMappings(provider, { maxDepth = 3, cap = 6000 } = {}) {
  const roots = await provider.roots().catch(() => []) || [];
  const q = roots.map(r => ({ path: [r.text], depth: 0 }));
  let visited = 0;
  while (q.length && visited < cap) {
    const { path, depth } = q.shift();
    try { provider.getDbIdsForPath?.(path, { includeDescendants: true, allowUnbuilt: true }); } catch {}
    if (depth < maxDepth) {
      let kids = [];
      try { kids = await provider.childrenByPath(path) || []; } catch {}
      visited += kids.length;
      for (const ch of kids) {
        const np = ch.__path || [...path, ch.text];
        q.push({ path: np, depth: depth + 1 });
      }
    }
  }
}

async function collectKeysForRoots(provider, { maxDepth = 3, cap = 6000 } = {}) {
  const roots = (await provider.roots().catch(() => [])) || [];
  const q = roots.map(r => ({ path: [r.text], depth: 0 }));
  const keys = new Set();
  let seen = 0;

  while (q.length && seen < cap) {
    const { path, depth } = q.shift();
    keys.add(toKey(path));

    let kids = [];
    try { kids = await provider.childrenByPath(path) || []; } catch {}
    seen += kids.length;

    if (depth < maxDepth) {
      for (const ch of kids) {
        const np = ch.__path || [...path, ch.text];
        q.push({ path: np, depth: depth + 1 });
      }
    }
  }
  return Array.from(keys);
}

// 태스크 → 상태별 dbId 세트
function buildStatusSetsFromTasks(tasks) {
  const stateById = new Map();
  const norm = (raw) => {
    if (!raw) return "";
    const s = String(raw).trim();
    const S = s.toUpperCase();
    if (s.includes("시공") || S.startsWith("C")) return "C";
    if (s.includes("가설") || S.startsWith("T")) return "T";
    if (s.includes("철거") || s.includes("해체") || S.startsWith("D")) return "D";
    if (S === "TD" || s.includes("동시") || s.includes("복합") || S.startsWith("X")) return "TD";
    return "";
  };
  const prio = { C:3, TD:2, D:1, T:0, "":-1 };
  function apply(id, sNew) {
    if (!id || !sNew) return;
    const cur = stateById.get(id);
    if (!cur) { stateById.set(id, sNew); return; }
    if ((cur === "T" && sNew === "D") || (cur === "D" && sNew === "T")) { stateById.set(id, "TD"); return; }
    stateById.set(id, prio[sNew] > prio[cur] ? sNew : cur);
  }
  (function walk(arr, inherited="") {
    (arr||[]).forEach(t => {
      const sTask = norm(t.status || t.selectedOption || inherited);
      (t.linkedObjects||[]).forEach(o => apply(o.dbId, norm(o.status || o.phase || sTask)));
      if (t.children) walk(t.children, sTask);
    });
  })(tasks);
  const S = { C:new Set(), T:new Set(), D:new Set(), TD:new Set() };
  for (const [id, s] of stateById.entries()) if (S[s]) S[s].add(id);
  return S;
}

function calcCountsForPath(provider, path, S) {
  let ids = [];
  try {
    ids = provider.getDbIdsForPath(path, { includeDescendants:true, allowUnbuilt:true }) || [];
  } catch {}
  if (!ids.length) return { total:0, c:0, t:0, d:0, td:0 };
  const set = new Set(ids);
  let c=0,t=0,d=0,td=0;
  for (const id of set) {
    if (S.C.has(id)) c++;
    if (S.T.has(id)) t++;
    if (S.D.has(id)) d++;
    if (S.TD.has(id)) td++;
  }
  return { total:set.size, c,t,d,td };
}

function keyFromPath(path) {
  const D = window.__WBS_DEBUG;
  return (D?.toKey ? D.toKey(path) : toKey(path));
}

async function buildFallbackMap(provider, { maxDepth=3, cap=6000 } = {}) {
  window.__FA_FALLBACK_BY_KEY = Object.create(null);
  const tasks = window.__SAVED_TASKS || [];
  const S = buildStatusSetsFromTasks(tasks);

  const roots = (await provider.roots().catch(()=>[])) || [];
  const q = roots.map(r => ({ path:[r.text], depth:0 }));
  let seen = 0;

  while (q.length && seen < cap) {
    const { path, depth } = q.shift();
    const key = keyFromPath(path);
    window.__FA_FALLBACK_BY_KEY[key] = calcCountsForPath(provider, path, S);

    let kids = [];
    try { kids = await provider.childrenByPath(path) || []; } catch {}
    seen += kids.length;
    if (depth < maxDepth) {
      for (const ch of kids) q.push({ path: (ch.__path || [...path, ch.text]), depth: depth+1 });
    }
  }
  console.log("[FA] fallback map ready (keys =", Object.keys(window.__FA_FALLBACK_BY_KEY).length, ")");
}

function patchGetCountsToUseFallback() {
  const D = window.__WBS_DEBUG;
  const fbMap = () => window.__FA_FALLBACK_BY_KEY || Object.create(null);

  if (!window.__FA_BRIDGED_GLOBAL) {
    const origGlobal = window.getCounts;
    window.getCounts = function (k) {
      const r = origGlobal ? (origGlobal(k) || {}) : {};
      const sum = ((r.c|0)+(r.t|0)+(r.d|0)+(r.td|0));
      if (sum > 0) return r;
      const fb = fbMap()[k];
      if (fb) { const total = Math.max((r.total|0), (fb.total|0)); return { total, c:fb.c|0, t:fb.t|0, d:fb.d|0, td:fb.td|0 }; }
      return r;
    };
    window.__FA_BRIDGED_GLOBAL = true;
  }

  if (D?.getCounts && !D.__patchedForFallback) {
    const orig = D.getCounts.bind(D);
    D.__origGetCounts = orig;
    D.getCounts = function (k) {
      const r = orig(k) || {};
      const sum = ((r.c|0)+(r.t|0)+(r.d|0)+(r.td|0));
      if (sum > 0) return r;
      const fb = fbMap()[k];
      if (fb) { const total = Math.max((r.total|0), (fb.total|0)); return { total, c:fb.c|0, t:fb.t|0, d:fb.d|0, td:fb.td|0 }; }
      return r;
    };
    D.__patchedForFallback = true;
  }

  console.log("[FA] getCounts bridged");
}

/* ──────────────────────────────────────────────────────────────
   WBS FancyTree 셀 색칠 (배지 제거)
────────────────────────────────────────────────────────────── */
const CELL_COLOR = {
  C:  "#ef4444", // 시공(빨강)
  T:  "#f59e0b", // 가설(주황)
  D:  "#6b7280", // 철거(회색)
  TD: "#2563eb"  // 가설+철거(파랑)
};

function injectWbsCellCss() {
  if (document.getElementById("wbs-cell-style")) return;
  const css = `
    .fancytree-node .fancytree-title {
      border-left: 4px solid transparent;
      padding-left: 8px;
      border-radius: 6px;
      transition: background-color .15s ease, border-color .15s ease;
    }
    .wbsCell--C  .fancytree-title  { background: ${CELL_COLOR.C}1a;  border-left-color: ${CELL_COLOR.C}; }
    .wbsCell--T  .fancytree-title  { background: ${CELL_COLOR.T}1a;  border-left-color: ${CELL_COLOR.T}; }
    .wbsCell--D  .fancytree-title  { background: ${CELL_COLOR.D}1a;  border-left-color: ${CELL_COLOR.D}; }
    .wbsCell--TD .fancytree-title  { background: ${CELL_COLOR.TD}1a; border-left-color: ${CELL_COLOR.TD}; }
  `.trim();
  const s = document.createElement("style");
  s.id = "wbs-cell-style";
  s.textContent = css;
  document.head.appendChild(s);
}

function normalizeCounts(x){
  if (x == null) return { total: 0, C: 0, T: 0, D: 0 };
  if (typeof x === "number") return { total: x, C: x, T: 0, D: 0 };
  return {
    total: Number(x.total ?? x.count ?? 0),
    C:     Number(x.C ?? x.c ?? 0),
    T:     Number(x.T ?? x.t ?? 0),
    D:     Number(x.D ?? x.d ?? 0),
  };
}

function countsForPath(path){
  // 1) 브리지 우선
  if (typeof window.__FA_GET_COUNTS__ === "function") {
    return normalizeCounts(window.__FA_GET_COUNTS__(path));
  }
  // 2) Provider의 countAt 사용 (변수명 통일)
  const provider = window.WBS_PROVIDER;
  if (provider?.countAt) {
    return normalizeCounts(provider.countAt(path));
  }
  // 3) WbsStore의 countAt 사용
  const store = window.__WBS_STORE__;
  if (store?.countAt) {
    return normalizeCounts(store.countAt(path));
  }
  // 4) 사전 계산 맵
  const SEP = "\u0001";
  const key = (path || []).join(SEP);
  const m = window.__FA_COUNT_MAP__;
  if (m && typeof m.get === "function") {
    return normalizeCounts(m.get(key));
  }
  return normalizeCounts(null);
}

function classForCounts(c) {
  if (!c) return null;
  if ((c.td|0) > 0) return "wbsCell--TD";
  if ((c.c|0)  > 0) return "wbsCell--C";
  if ((c.t|0)  > 0) return "wbsCell--T";
  if ((c.d|0)  > 0) return "wbsCell--D";
  return null;
}

function repaintNode(node) {
  const $ = window.jQuery || window.$;
  if (!$ || !node || !node.span || node.isRoot?.()) return;
  const path = node.data?.__path;
  if (!path) return;

  const counts = countsForPath(path);
  const $li = $(node.li);
  $li.removeClass("wbsCell--C wbsCell--T wbsCell--D wbsCell--TD");
  const cls = classForCounts(counts);
  if (cls) $li.addClass(cls);
}

function repaintTree(tree) {
  if (!tree) return;
  tree.visit(repaintNode);
}

// 첫 로딩 셀 칠하기 재시도 루프(최대 1초)
function startFirstPaintRetry(tree) {
  let tries = 0;
  const maxTries = 10;
  const step = () => {
    tries++;
    repaintTree(tree);
    if (tries >= maxTries) return;
    setTimeout(step, 100);
  };
  setTimeout(step, 0);
}

function installWbsDecorators(tree) {
  const $ = window.jQuery || window.$;
  if (!tree) tree = $.ui?.fancytree?.getTree("#wbs-tree");
  if (!tree) return;

  injectWbsCellCss();

  // 기존 훅 체이닝
  const prevRenderNode = tree.options.renderNode;
  tree.$div.fancytree("option", "renderNode", function(event, data) {
    try { if (typeof prevRenderNode === "function") prevRenderNode.call(this, event, data); } catch {}
    try { repaintNode(data.node); } catch {}
  });

  tree.$div.fancytree("option", "createNode", function(_ev, data) {
    try { repaintNode(data.node); } catch {}
  });

  // ★ expand 체이닝: 기존 expand 먼저, 그 다음 색칠 보강
  const prevExpand = tree.options.expand;
  tree.$div.fancytree("option", "expand", function(ev, data) {
    try { if (typeof prevExpand === "function") prevExpand.call(this, ev, data); } catch {}
    if (data.node?.expanded) {
      setTimeout(() => { try { repaintTree(tree); } catch {} }, 0);
    }
  });

  // 초기 두 프레임 + 재시도 루프
  try { repaintTree(tree); } catch {}
  requestAnimationFrame(() => { try { repaintTree(tree); } catch {} });
  startFirstPaintRetry(tree);

  // 디버그 훅
  tree.__wbsHelpers = tree.__wbsHelpers || {};
  tree.__wbsHelpers.repaintTree = () => { try { repaintTree(tree); } catch {} };
}

/* ──────────────────────────────────────────────────────────────
   태스크 로드(API 대체 샘플)
────────────────────────────────────────────────────────────── */
const SAMPLE_TASK_DATA = [
  {
    no: "1", title: "Task A", selectedOption: "시공",
    start: "2024-06-25", end: "2024-07-01",
    linkedObjects: [{ urn: "SAMPLE_URN", dbId: 1001, text: "벽체1" }],
    children: [
      { no: "1.1", title: "Subtask A1", selectedOption: "시공",
        start: "2024-06-26", end: "2024-06-30",
        linkedObjects: [{ urn: "SAMPLE_URN", dbId: 1002, text: "벽체2" }] }
    ],
  },
  { no: "2", title: "Task B", selectedOption: "가설", start: "", end: "", linkedObjects: [] },
];

async function fetchTaskDataForCurrentModel() {
  try {
    const safeUrnVal = window.CURRENT_MODEL_SAFE_URN;
    const url = `/api/tasks?urn=${safeUrnVal}`;
    const resp = await fetch(url, { credentials: "include" });
    if (resp.ok) {
      const data = await resp.json();
      if (Array.isArray(data) && data.length > 0) return data;
    }
  } catch (err) {
    console.warn("task 데이터를 불러오지 못했습니다. 샘플로 대체:", err);
  }
  return SAMPLE_TASK_DATA.map(x => structuredClone(x));
}

/* ──────────────────────────────────────────────────────────────
   리사이즈
────────────────────────────────────────────────────────────── */
window.addEventListener("resize", _.throttle(() => {
  try {
    initSidebarWidth();
    window.viewer?.resize?.();
    window.viewer?.impl?.invalidate?.(true, true, true);
  } catch (e) { console.warn("[resize] redraw failed", e); }
}, 120));

/* ──────────────────────────────────────────────────────────────
   main
────────────────────────────────────────────────────────────── */
(async function () {
  try {
    // 1) 로그인
    const resp = await fetch("/api/auth/profile", { credentials: "include" });
    if (!resp.ok) { window.location.replace("/api/auth/login"); return; }
    const user = await resp.json();
    const login = document.getElementById("login");
    login.innerText = `Logout (${user.name})`;
    login.onclick = () => {
      const iframe = document.createElement("iframe");
      iframe.style.visibility = "hidden";
      iframe.src = "https://accounts.autodesk.com/Authentication/LogOut";
      document.body.appendChild(iframe);
      iframe.onload = () => { window.location.replace("/api/auth/logout"); document.body.removeChild(iframe); };
    };

    // 2) 레이아웃
    const Sidebar = document.getElementById("sidebar");
    const Header  = document.getElementById("header");
    const Preview = document.getElementById("preview");
    const sidebarResizer = document.getElementById("sidebar-resizer");
    const Loading = document.getElementById("loading");
    Sidebar.style.display = "";
    sidebarResizer.style.display = "";
    Preview.style.display = "";
    Header.style.display = "";
    Loading.style.display = "none";
    login.style.visibility = "visible";
    Sidebar.style.removeProperty("width");
    Preview.style.removeProperty("left");
    sidebarResizer.style.removeProperty("left");
    initSidebarWidth();

    // 3) 탭/뷰어
    initTabs("#sidebar");
    const viewerHost = document.getElementById("viewer-host");
    const viewer = await initViewer(viewerHost);
    window.viewer = viewer;
    disableViewerEscReset(viewer);

    viewer.resize();
    viewer.impl?.invalidate?.(true, true, true);
    requestAnimationFrame(() => { try { viewer.resize(); viewer.impl?.invalidate?.(true, true, true); } catch {} });
    resetViewerInputAndCamera(viewer);

    requestAnimationFrame(() => {
      const sb = document.getElementById("sidebar");
      if (sb && sb.offsetWidth === 0) {
        document.documentElement.style.setProperty("--sidebar-width", SIDEBAR_DEFAULT + "px");
        viewer.resize();
        viewer.impl?.invalidate?.(true, true, true);
      }
    });

    // 4) 모델 선택
    initTree("#tree", async (versionId) => {
      const urn = window.btoa(versionId).replace(/=/g, "");
      window.CURRENT_MODEL_URN = urn;
      window.CURRENT_MODEL_SAFE_URN = safeUrn(urn);

      // 기존 WBS 파괴
      try { $.ui.fancytree.getTree("#wbs-tree")?.destroy(); } catch {}
      $("#wbs-group-content").empty();

      // (A) 모델 로드 & 안정화
      await loadModel(viewer, urn);
      await waitViewerReady(viewer);
      await focusCameraAndWait(viewer);
      viewer.resize();

      // (B) WBS Provider 생성
      let provider = null;
      try {
        const PRIMARY = ["HEC.WBS","HEC.Level","HEC.Zone"];
        const { provider: p } = await buildWbsProviderLazy(viewer, {
          primaryOrder: PRIMARY, source: "all", bucketThreshold: 400, bucketSize: 200,
        });
        provider = p;
        window.WBS_PROVIDER = provider;      // ← 사용 일관화
        window.__WBS_PROVIDER = provider;    // ← 호환용(혹시 남은 코드 대비)
        const roots = await provider.roots();
        console.log("[WBS] roots:", Array.isArray(roots) ? roots.length : roots);
      } catch (e) {
        console.warn("[WBS] provider failed:", e);
        provider = { __provider:true, roots:async()=>[], childrenByPath:async()=>[] };
        window.WBS_PROVIDER = provider;
        window.__WBS_PROVIDER = provider;
      }

      // (C) 태스크 로드/정규화/영속
      const tasks = await fetchTaskDataForCurrentModel();
      tasks.forEach((t) => fillUrnRecursive(t, urn));
      persistTasksSnapshot(tasks);

      // (D) provider 맵 워밍업 → 매트릭스 초기화 → 태스크 데이터 UI로 공유
      await seedDbIdMappings(provider, { maxDepth: 3, cap: 6000 });
      await initMatrix({ primaryOrder:["HEC.WBS","HEC.Level","HEC.Zone"], provider });
      setSavedTaskData(tasks);

      // (E) 폴백맵 준비 & getCounts 브릿지
      await buildFallbackMap(provider, { maxDepth:3, cap:6000 });
      patchGetCountsToUseFallback();

      // (F) 선계산(루트~깊이3)
      const preKeys = await collectKeysForRoots(provider, { maxDepth: 3, cap: 6000 });
      await bulkEnsureForVisible(preKeys);
      preKeys.forEach(computePathState);

      // (G) 트리 init → 핸들 확보 → 데코레이터 설치 → 첫 칠하기 재시도
      await initWbsPanelWithFancytree(provider, { primaryOrder: ["HEC.WBS","HEC.Level","HEC.Zone"] });
      console.log("[STEP 5] WBS fancytree init OK");

      const tree = $.ui.fancytree.getTree("#wbs-tree");
      // 데코레이터: 기존 expand 체이닝(계산 로직 유지)
      (function installWbsDecorators(tree) {
        const $ = window.jQuery || window.$;
        if (!tree) return;

        injectWbsCellCss();

        const prevRenderNode = tree.options.renderNode;
        tree.$div.fancytree("option", "renderNode", function(event, data) {
          try { if (typeof prevRenderNode === "function") prevRenderNode.call(this, event, data); } catch {}
          try { repaintNode(data.node); } catch {}
        });

        tree.$div.fancytree("option", "createNode", function(_ev, data) {
          try { repaintNode(data.node); } catch {}
        });

        const prevExpand = tree.options.expand;
        tree.$div.fancytree("option", "expand", function(ev, data) {
          try { if (typeof prevExpand === "function") prevExpand.call(this, ev, data); } catch {}
          if (data.node?.expanded) {
            setTimeout(() => { try { repaintTree(tree); } catch {} }, 0);
          }
        });

        try { repaintTree(tree); } catch {}
        requestAnimationFrame(() => { try { repaintTree(tree); } catch {} });
        startFirstPaintRetry(tree);

        tree.__wbsHelpers = tree.__wbsHelpers || {};
        tree.__wbsHelpers.repaintTree = () => { try { repaintTree(tree); } catch {} };
      })(tree);

      // (H) 인덱스(경로↔dbId) 선구축: provider 우선
      try {
        await initWbsStore({ tree, provider, eager: "provider" });
      } catch (e) {
        console.warn("[WBS] store init failed, fallback to tree:", e);
        try { await initWbsStore({ tree, provider, eager: "tree" }); } catch {}
      }

      // (I) 나머지
      try { bindPanel2Resizer(viewer); console.log("[STEP 6] panel2 resizer bound"); } catch {}
      try { initTaskPanel(tasks); initTaskListButtons(); console.log("[STEP 1] Task panel OK"); } catch {}
      try { window.dispatchEvent(new Event("panel2-ready")); console.log("[STEP 2] panel2-ready dispatched"); } catch {}
    });

  } catch (err) {
    alert("Could not initialize the application. See console for more details.");
    console.error(err);
  }
})();



// 목적: 첫 로딩시에 WBS "전체"를 인덱싱(경로 <-> dbId 맵)하여
//       이후에는 UI 확장/프로바이더 없이도 즉시 조회 가능.
// 지원 소스:
//  1) provider가 있으면 provider.roots()/childrenByPath() BFS로 전체 수집
//  2) provider가 없으면 Fancytree를 보이지 않게 deep-load 해서 전체 수집

export const WbsStore = {
  tree: null,            // Fancytree instance
  provider: null,        // { roots?, childrenByPath?, getDbIdsForPath? }
  isReady: false,

  // 인덱스
  nodesInOrder: [],           // Fancytree Node[] in document order (로깅/디버그용)
  pathKeyToDbIds: new Map(),  // "A␁B␁C" -> [dbId...](자손 leaf 포함, 정렬 유지)
  dbIdToPath: new Map(),      // dbId -> ["A","B","C"]

  // 경로 → 노드 title 규칙: title > key > data.text (+ 정규화)
  normalizeLabel(n) {
    let x = String(n?.title ?? n?.key ?? n?.data?.text ?? "").trim();
    x = x.replace(/\s+/g, " ").trim();              // 내부 연속 공백 축소
    x = x.replace(/[\u2010-\u2015\u2212\u2043]/g, "-"); // 유사 하이픈 통일
    x = x.replace(/[\u200B-\u200D\uFEFF]/g, "");    // 제어문자 제거
    return x;
  },
};

const SEP = "\u0001";

// === Public API ==============================================================
export async function initWbsStore({ tree, provider, eager = "auto" } = {}) {
  if (tree) WbsStore.tree = tree;
  if (provider) WbsStore.provider = provider;

  resetWbsStore();

  // 전체 인덱스 선구축
  if (eager === "provider" || (eager === "auto" && provider)) {
    await buildFullIndexFromProvider();
  } else if (eager === "tree" || (eager === "auto" && tree)) {
    await buildFullIndexFromFancytree();
  }

  // UI 이벤트에 맞춰 필요시 재색인(가볍게)
  try {
    const $root = $(WbsStore.tree?.$div || "#wbs-tree");
    $root.off(".wbsstore");
    $root.on(
      "fancytreechange.wbsstore fancytreeexpand.wbsstore fancytreecollapse.wbsstore",
      debounce(() => { /* 전체 인덱스는 이미 준비돼 있으므로 noop */ }, 150)
    );
  } catch (_) {}

  WbsStore.isReady = true;
}

export function setProvider(provider) {
  WbsStore.provider = provider || null;
}

export function refreshWbsStore() {
  // 필요 시 재구축(여기서는 안전상 provider 우선)
  return initWbsStore({ tree: WbsStore.tree, provider: WbsStore.provider, eager: "auto" });
}

export function resetWbsStore() {
  WbsStore.nodesInOrder = [];
  WbsStore.pathKeyToDbIds.clear();
  WbsStore.dbIdToPath.clear();
  WbsStore.isReady = false;
}

export function pathOfNode(n) {
  const out = [];
  let cur = n;
  while (cur && typeof cur.isRoot === "function" && !cur.isRoot()) {
    out.unshift(WbsStore.normalizeLabel(cur));
    cur = cur.parent;
  }
  return out;
}

// 선택 노드(체크) 수집: includePartsel=true면 부분선택도 포함
export function getCheckedNodesInOrder({ includePartsel = true } = {}) {
  const t = WbsStore.tree;
  if (!t) return [];
  const nodes = t.getSelectedNodes?.(false) || [];
  return nodes.filter(n => (includePartsel ? true : !n.partsel));
}

/** 체크된 노드들로부터 dbId들을 "인덱스(사전 구축)"에서 바로 회수 */
export async function getOrderedDbIdsFromSelection({ includePartsel = true } = {}) {
  if (!WbsStore.isReady) await refreshWbsStore();

  const selected = getCheckedNodesInOrder({ includePartsel });
  // 문서 순서 정렬
  selected.sort((a, b) => a.getIndexHier().localeCompare(b.getIndexHier(), undefined, { numeric: true }));

  const orderedDbIds = [];
  const pathByDbId = new Map();
  const seen = new Set();

  for (const node of selected) {
    const pathArr = pathOfNode(node);
    const key = pathArr.join(SEP);
    const ids = WbsStore.pathKeyToDbIds.get(key) || [];
    for (const id of ids) {
      if (!seen.has(id)) {
        seen.add(id);
        orderedDbIds.push(id);
        pathByDbId.set(id, pathArr.slice());
      }
    }
  }
  return { orderedDbIds, pathByDbId };
}

/** (호환용) 정확히 체크(V)만 대상으로 수집 */
export async function getOrderedDbIdsFromCheckedExact() {
  return getOrderedDbIdsFromSelection({ includePartsel: false });
}

/** 특정 경로의 모든 자손 leaf dbId 반환(이미 인덱스에 있음) */
export async function getAllDescendantDbIdsByPath(pathArr) {
  if (!Array.isArray(pathArr) || !pathArr.length) return [];
  if (!WbsStore.isReady) await refreshWbsStore();
  return (WbsStore.pathKeyToDbIds.get(pathArr.join(SEP)) || []).slice();
}

// === Internal: Build Index ====================================================

async function buildFullIndexFromProvider() {
  const p = WbsStore.provider;
  if (!p || typeof p.childrenByPath !== "function") return;

  resetWbsStore();

  let roots = [];
  try {
    roots = (typeof p.roots === "function") ? (await p.roots()) : (await p.childrenByPath([]));
  } catch (_) { roots = []; }

  const queue = [];
  for (const r of (roots || [])) {
    const label = String(r?.text ?? r?.name ?? "").trim();
    const rPath = Array.isArray(r?.__path) ? r.__path : (label ? [label] : null);
    if (rPath) queue.push(rPath);
  }

  while (queue.length) {
    const cur = queue.shift();
    const key = cur.join(SEP);

    // 가능하면 한 번에 자손 dbId를 받아서 저장(빠르고 정확)
    let got = [];
    try { got = p.getDbIdsForPath?.(cur, { includeDescendants:true, allowUnbuilt:true }) || []; } catch {}
    if (Array.isArray(got) && got.length) {
      const merged = uniqKeepOrder([...(WbsStore.pathKeyToDbIds.get(key) || []), ...got]);
      WbsStore.pathKeyToDbIds.set(key, merged);
      // dbId → leaf 경로는 children loop에서 보강됨
    }

    // children 순회로 leaf 경로/하위 큐 적재
    let children = [];
    try { children = await p.childrenByPath(cur); } catch { children = []; }

    for (const ch of (children || [])) {
      const label = String(ch?.text ?? ch?.name ?? "").trim();
      const id = Number(ch?.dbId ?? ch?.data?.dbId);
      const chPath = Array.isArray(ch?.__path) ? ch.__path : (label ? cur.concat(label) : null);

      if (Number.isFinite(id)) {
        // leaf: dbId → 정확한 경로 매핑
        if (chPath) WbsStore.dbIdToPath.set(id, chPath);
      } else if (chPath) {
        queue.push(chPath);
      }
    }
  }

  WbsStore.isReady = true;
}

async function buildFullIndexFromFancytree() {
  const t = WbsStore.tree;
  if (!t) return;

  resetWbsStore();

  // 1) 전체 로드(보이지 않게)
  const root = t.getRootNode?.();
  if (!root) return;

  await deepLoadNode(root);

  // 2) 전체 트리 순회하여 인덱싱
  root.visit(n => {
    WbsStore.nodesInOrder.push(n);
    const hasKids = (n.hasChildren && n.hasChildren());
    const id = Number(n.data?.dbId ?? n.dbId);
    if (!hasKids && Number.isFinite(id)) {
      const path = pathOfNode(n);
      WbsStore.dbIdToPath.set(id, path);
    }
  });

  // 그룹 경로마다 자손 leaf 집계
  root.visit(n => {
    const hasKids = (n.hasChildren && n.hasChildren());
    if (!hasKids) return;
    const path = pathOfNode(n);
    const key = path.join(SEP);
    const acc = [];
    n.visit(c => {
      if (c === n) return;
      const leaf = !(c.hasChildren && c.hasChildren());
      const id = Number(c.data?.dbId ?? c.dbId);
      if (leaf && Number.isFinite(id)) acc.push(id);
    });
    if (acc.length) WbsStore.pathKeyToDbIds.set(key, uniqKeepOrder(acc));
  });

  WbsStore.isReady = true;
}

// Fancytree: lazy node들을 실제로 children까지 모두 로드(확장하지 않고)
async function deepLoadNode(node) {
  if (node.lazy && !node.children && typeof node.load === "function") {
    try { await node.load(true); } catch(_) {}
  } else if (node.lazy && !node.children) {
    const wasExpanded = node.expanded;
    try { await node.setExpanded(true, { noAnimation: true, noEvents: true }); } catch(_) {}
    if (!wasExpanded) {
      try { await node.setExpanded(false, { noAnimation: true, noEvents: true }); } catch(_) {}
    }
  }

  if (node.children && node.children.length) {
    for (const ch of node.children) {
      await deepLoadNode(ch);
    }
  }
}

// === Utils ===================================================================
function uniqKeepOrder(arr) {
  const s = new Set(); const out = [];
  for (const x of arr) if (!s.has(x)) { s.add(x); out.push(x); }
  return out;
}

function debounce(fn, ms) {
  let t = 0;
  return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
}

// ── Fuzzy 조회: 경로가 정확히 안 맞아도 가장 가까운 자손/조상에서 찾기
function getIdsByPathFuzzy(pathArr) {
  const key = (pathArr || []).join(SEP);
  const map = WbsStore.pathKeyToDbIds;
  if (map.has(key)) return map.get(key) || [];

  // (1) 자손 키들 합집합
  const prefix = key ? (key + SEP) : "";
  let acc = [];
  for (const [k, ids] of map.entries()) {
    if (prefix && k.startsWith(prefix)) {
      acc = uniqKeepOrder(acc.concat(ids || []));
    }
  }
  if (acc.length) return acc;

  // (2) 조상 키로 폴백
  const buf = (pathArr || []).slice();
  while (buf.length) {
    buf.pop();
    const k2 = buf.join(SEP);
    if (map.has(k2)) return map.get(k2) || [];
  }
  return [];
}

// === expose to window for console/debug ======================================
if (typeof window !== "undefined") {
  window.__WBS_STORE__ = {
    WbsStore,
    initWbsStore,
    setProvider,
    refreshWbsStore,
    pathOfNode,
    getCheckedNodesInOrder,
    getOrderedDbIdsFromSelection,
    getOrderedDbIdsFromCheckedExact,
    getAllDescendantDbIdsByPath,
    countAt, // ← 외부에서 바로 사용 가능하게 노출
  };
}

export function countAt(pathArr){
  if (!Array.isArray(pathArr)) return 0;
  // 인덱스가 아직이면 비동기 재구축 트리거(동기 블로킹 없음)
  if (!WbsStore.isReady) { try { refreshWbsStore(); } catch {} }
  const ids = getIdsByPathFuzzy(pathArr);
  return Array.isArray(ids) ? ids.length : 0;
}




