// /wwwroot/js/sidebar/task-wbs/task-buttons.js
import { normalizeTaskCategory, enforceCategoryInheritance } from "./core/categories.js";
import { aggregateTaskFields } from "./logic/task-aggregate.js";
import { scheduleWbsRepaint } from "./ui/wbs-highlight.js";
import { showCurrentTaskModal } from "./ui/current-task-modal.js";
import { notifyCoverageDirtyAndRepaint } from "./ui/wbs-fixed-paint.js";
import { ensureElementIdIndexForDbIds, getElementIdFor, formatObjectLabel } from "./core/element-id.js";

// 상태 반영을 위해 추가:
function notifyWbsStatusRefresh(){
  try { window.__WBS_MARK_TASKS_CHANGED?.(); } catch {}
}

// 페인트 배치(간단 락)
async function runWbsHighlightBatch(cb){
  const prev = window.__WBS_PAINT_LOCK === true;
  window.__WBS_PAINT_LOCK = true;
  try { await cb(); }
  finally {
    window.__WBS_PAINT_LOCK = prev;
    requestAnimationFrame(()=>{ try{ window.updateWBSHighlight?.(); } catch{} });
  }
}

// 외부 저장 스냅샷
export function setSavedTaskData(data) {
  window.savedTaskData = JSON.parse(JSON.stringify(data ?? []));
}

export function initTaskListButtons() {
  window.__ALLOW_WBS_UPDATE = window.__ALLOW_WBS_UPDATE ?? false;

  function withWbsGate(fn){
    const prev = window.__ALLOW_WBS_UPDATE;
    window.__ALLOW_WBS_UPDATE = true;
    try { return fn(); }
    finally { window.__ALLOW_WBS_UPDATE = prev; } // ← 버그 수정 (예: __WBS_PAINT_LOCK 되돌리던 라인 교체)
  }

  function flush(recalc = false) {
    if (recalc && window.requestTaskRecalcAndFlush) {
      window.requestTaskRecalcAndFlush();
    } else if (window.requestTaskTreeFlush) {
      window.requestTaskTreeFlush();
    } else {
      const tree = $.ui.fancytree.getTree("#treegrid");
      tree.render(true, true);
    }
    if (!window.__WBS_PAINT_LOCK) scheduleWbsRepaint();
  }

  // [추가]
  $("#btn-add").off("click").on("click", function () {
    const tree = $.ui.fancytree.getTree("#treegrid");
    const sel = tree.getActiveNode();
    const parentNode = sel || null;
    const baseCat = (parentNode?.data?.selectedOption) || "시공";
    const no = generateNo(parentNode);
    const nodeData = {
      no,
      selectOptions: ["시공", "가설", "철거"],
      selectedOption: baseCat,
      title: "새 작업",
      start: "",
      end: "",
      linkedObjects: []
    };
    if (parentNode) {
      if (Array.isArray(parentNode.data?.linkedObjects) && parentNode.data.linkedObjects.length) {
        parentNode.data.linkedObjects = [];
        parentNode.render && parentNode.render();
      }
      parentNode.addChildren(nodeData);
      parentNode.setExpanded(true);
      parentNode.data.start = "";
      parentNode.data.end = "";
      parentNode.render && parentNode.render();
    } else {
      tree.getRootNode().addChildren(nodeData);
    }
    enforceCategoryInheritance(tree);
    flush(true);
  });

  // [삭제]
  $("#btn-delete").off("click").on("click", function(){
    const tree = $.ui.fancytree.getTree("#treegrid");
    const sel = tree.getActiveNode();
    if (sel && !sel.isRoot()) {
      sel.remove();
      flush(true);
    }
  });

  // [객체선택] → 3D viewer select
  $("#btn-select").off("click").on("click", function() {
    const taskTree = $.ui.fancytree.getTree("#treegrid");
    const selected = taskTree.getActiveNode();
    if (!selected) return alert("Task를 선택하세요!");

    const objects = aggregateTaskFields(selected).objects;
    if (!objects || objects.length === 0) return alert("이 Task(및 하위 Task)에 연결된 객체가 없습니다.");

    const byUrn = {};
    objects.forEach(obj => {
      if (!byUrn[obj.urn]) byUrn[obj.urn] = [];
      byUrn[obj.urn].push(obj.dbId);
    });
    Object.entries(byUrn).forEach(([urn, dbIds]) => {
      if (urn === window.CURRENT_MODEL_URN && window.viewer) {
        window.viewer.select(dbIds);
      }
    });
  });

  // [업데이트] 저장
  $("#btn-update").off("click").on("click", async function () {
    const safeUrnVal = window.CURRENT_MODEL_SAFE_URN;
    const url = `/api/tasks?urn=${safeUrnVal}`;
    const currentTaskData = getCurrentTaskDataFromTree();
    const current = JSON.stringify(currentTaskData ?? []);
    const saved   = JSON.stringify(window.savedTaskData ?? []);

    if (!window.savedTaskData || (Array.isArray(window.savedTaskData) && window.savedTaskData.length === 0 && currentTaskData.length > 0)) {
      // 최초 저장 허용
    } else if (current === saved) {
      alert("수정된 데이터가 없습니다.");
      return;
    }

    try {
      const resp = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        credentials: "include",
        body: JSON.stringify(currentTaskData),
      });
      if (resp.ok) {
        alert("Task 데이터가 저장되었습니다!");
        window.savedTaskData = JSON.parse(JSON.stringify(currentTaskData));
      } else {
        alert("Task 데이터 저장 실패!");
      }
    } catch (err) {
      alert("저장 중 오류 발생: " + err.message);
    }
  });

  // [데이터연결]
  $("#btn-link").off("click").on("click", async function () {
    const taskTree = $.ui.fancytree.getTree("#treegrid");
    const selectedTaskNode = taskTree.getActiveNode();
    if (!selectedTaskNode) return alert("Task를 선택하세요!");
    if (selectedTaskNode.hasChildren && selectedTaskNode.hasChildren()) {
      alert("하위 작업이 있는 Task에는 연결할 수 없습니다.\n 최하위 Task를 선택해 주세요.");
      return;
    }

    const urn = window.CURRENT_MODEL_URN;
    const catSel = normalizeTaskCategory(selectedTaskNode.data?.selectedOption); // "C"|"T"|"D"
    const catLabel = catSel === "C" ? "시공" : (catSel === "T" ? "가설" : "철거");

    // 체크된 노드 → 그룹이면 하위 전체 dbId, 리프는 해당 dbId
    const provider = window.__WBS_PROVIDER;
    const checked = window.wbsTree.checked();
    const dbSet = new Set();

    function pathOfNode(n){
      if (Array.isArray(n.__path)) return n.__path.slice();
      const out=[]; let cur=n; while (cur && cur.text && !cur.isRoot?.()){ out.unshift(cur.text); cur=cur.parent; }
      return out;
    }

    for (const node of checked) {
      if (node.hasChildren && node.hasChildren()) {
        let ids = provider?.getDbIdsForPath(pathOfNode(node), { includeDescendants:true, allowUnbuilt:true });
        if (ids == null) {
          try { await provider?.childrenByPath(pathOfNode(node)); } catch {}
          ids = provider?.getDbIdsForPath(pathOfNode(node), { includeDescendants:true, allowUnbuilt:true });
        }
        if (Array.isArray(ids)) ids.forEach(id => dbSet.add(Number(id)));
      } else {
        dbSet.add(Number(node.dbId));
      }
    }

    const dbIds = Array.from(dbSet).filter(Number.isFinite);
    if (dbIds.length === 0) return alert("WBS에서 객체를 선택하세요!");

    // ElementId 대량 프리페치
    try { await ensureElementIdIndexForDbIds(dbIds); } catch {}

    // 저장 데이터에 ElementId/표시문구 같이 심기
    const checkedObjects = dbIds.map(d => ({
      urn,
      dbId: d,
      elementId: getElementIdFor(urn, d),
      text: formatObjectLabel({ urn, dbId: d })
    }));

    await runWbsHighlightBatch(async () => {
      // 점유 현황
      const occupancy = new Map();
      taskTree.getRootNode().visit(n => {
        const cat = normalizeTaskCategory(n.data?.selectedOption);
        if (!cat) return;
        (n.data?.linkedObjects || []).forEach(o => {
          const key = `${o.urn || urn}:${o.dbId}`;
          const slot = occupancy.get(key) || { C: null, T: null, D: null };
          if (cat === "C" && !slot.C) slot.C = n;
          if (cat === "T" && !slot.T) slot.T = n;
          if (cat === "D" && !slot.D) slot.D = n;
          occupancy.set(key, slot);
        });
      });

      const allowed = [];
      const conflictsForC = [];
      const conflictsC = [];
      const conflictsSame = [];

      checkedObjects.forEach(obj => {
        const key = `${obj.urn}:${obj.dbId}`;
        const slot = occupancy.get(key) || { C: null, T: null, D: null };

        if (catSel === "C") {
          if (!slot.C && !slot.T && !slot.D) allowed.push(obj);
          else conflictsForC.push({ obj, slot });
        } else if (catSel === "T") {
          if (slot.C) conflictsC.push({ obj, slot });
          else if (slot.T) conflictsSame.push({ obj, slot });
          else allowed.push(obj);
        } else if (catSel === "D") {
          if (slot.C) conflictsC.push({ obj, slot });
          else if (slot.D) conflictsSame.push({ obj, slot });
          else allowed.push(obj);
        }
      });

      function unlinkFromNode(node, obj) {
        if (!node) return;
        node.data.linkedObjects = (node.data.linkedObjects || []).filter(
          o => !(String(o.urn || urn) === String(obj.urn) && Number(o.dbId) === Number(obj.dbId))
        );
        node.render && node.render();
      }

      if (catSel === "C" && conflictsForC.length) {
        const res = prompt([
          `선택한 객체 중 ${conflictsForC.length}개는 이미 다른 Task에 연결되어 있습니다.`,
          `규칙상 '시공'은 단독 연결만 가능합니다.`,
          ``,
          `1. 기존 연결 해제 후 이 Task(시공)로 새로 연결`,
          `2. 이미 연결된 객체만 제외하고 진행`,
          `3. 취소`,
          ``,
          `번호를 입력하세요 (1/2/3)`
        ].join("\n"), "2");
        if (res === "3" || res == null) return;
        if (res === "1") {
          conflictsForC.forEach(({ obj, slot }) => {
            unlinkFromNode(slot.C, obj);
            unlinkFromNode(slot.T, obj);
            unlinkFromNode(slot.D, obj);
            allowed.push(obj);
          });
        }
      }

      if ((catSel === "T" || catSel === "D") && conflictsC.length) {
        const res = prompt([
          `다음 객체는 '시공'에 이미 연결되어 있어 ${catLabel}과(와) 병행할 수 없습니다.`,
          ``,
          `1. 시공 연결 해제 후 이 Task(${catLabel})로 새로 연결`,
          `2. 이미 연결된 객체만 제외하고 진행`,
          `3. 취소`,
          ``,
          `번호를 입력하세요 (1/2/3)`
        ].join("\n"), "2");
        if (res === "3" || res == null) return;
        if (res === "1") {
          conflictsC.forEach(({ obj, slot }) => { unlinkFromNode(slot.C, obj); allowed.push(obj); });
        }
      }

      if ((catSel === "T" || catSel === "D") && conflictsSame.length) {
        const label = catLabel;
        const res = prompt([
          `다음 객체는 이미 '${label}'에 연결되어 있습니다.`,
          ``,
          `1. 기존 '${label}' 연결을 이 Task로 교체 (해당 카테고리만 교체)`,
          `2. 이미 연결된 객체만 제외하고 진행`,
          `3. 취소`,
          ``,
          `번호를 입력하세요 (1/2/3)`
        ].join("\n"), "2");
        if (res === "3" || res == null) return;
        if (res === "1") {
          conflictsSame.forEach(({ obj, slot }) => {
            if (catSel === "T") unlinkFromNode(slot.T, obj);
            if (catSel === "D") unlinkFromNode(slot.D, obj);
            allowed.push(obj);
          });
        }
      }

      if (allowed.length > 0) {
        selectedTaskNode.data.linkedObjects = _.uniqBy(
          (selectedTaskNode.data.linkedObjects || []).concat(allowed),
          o => o.urn + ":" + o.dbId
        );
      }

      withWbsGate(() => {
        flush(true);
        try { window.gantt?.renderFromTrees(window.taskTree, window.wbsTree); } catch(_) {}
      });

      // 고정 색칠 갱신
      try { await notifyCoverageDirtyAndRepaint(); } catch {}
    });
    notifyWbsStatusRefresh();
  });

  // [연결 해제]
  $("#btn-unlink").off("click").on("click", async function () {
    const taskTree = $.ui.fancytree.getTree("#treegrid");
    const selectedNode = taskTree.getActiveNode();
    if (!selectedNode) return alert("연결을 해제할 Task를 선택하세요!");

    await runWbsHighlightBatch(async () => {
      (function unlinkAll(node){
        node.data.linkedObjects = [];
        if (node.hasChildren()) node.children.forEach(unlinkAll);
      })(selectedNode);

      withWbsGate(() => {
        flush(true);
        try { window.gantt?.renderFromTrees(window.taskTree, window.wbsTree); } catch(_) {}
      });

      try { await notifyCoverageDirtyAndRepaint(); } catch {}
    });
    notifyWbsStatusRefresh();
  });

  // 공정현황 버튼
  $("#btn-date").off("click").on("click", function(){
    showCurrentTaskModal();
  });

  // TEST 버튼
  $("#btn-test").off("click").on("click", async function() {
    initTaskWbsButtons(window.viewer);
  });
}

function generateNo(parentNode) {
  if (!parentNode || parentNode.isRoot()) {
    const roots = $.ui.fancytree.getTree("#treegrid").getRootNode().children || [];
    return String(roots.length + 1);
  } else {
    const siblings = parentNode.children || [];
    const baseNo = parentNode.data.no || parentNode.title;
    return baseNo + "." + (siblings.length + 1);
  }
}

function getCurrentTaskDataFromTree() {
  const tree = $.ui.fancytree.getTree("#treegrid");
  const urn = window.CURRENT_MODEL_URN;
  function nodeToData(node) {
    const obj = {
      no: node.data.no,
      selectOptions: node.data.selectOptions ?? ["시공", "가설", "철거"],
      selectedOption: node.data.selectedOption ?? "시공",
      title: node.data.title ?? node.title,
      start: node.data.start,
      end: node.data.end,
      linkedObjects: (node.data.linkedObjects || []).map(o => ({
        urn: o.urn ?? urn,
        dbId: o.dbId,
        elementId: o.elementId ?? null, // ElementId 일관 저장
        text: formatObjectLabel(o),      // ← 항상 [ElementId] 우선
      })),
    };
    if (node.hasChildren()) obj.children = node.children.map(nodeToData);
    return obj;
  }
  return tree.getRootNode().children.map(nodeToData);
}


// /wwwroot/js/task-wbs/task-buttons.js
// Test 버튼: (선택 해제) → Z+5m 2초 이동 + 부드러운 페이드아웃 → 1초 정지 → 2초 복귀 + 페이드인
// - 페이드는 시각적으로 균일하게 보이도록 S-커브(easeInOutSine) 적용
// - 모델 단위가 m이 아니면 MOVE_Z 값을 조정하세요. (mm 모델이면 5000 등)

export function initTaskWbsButtons(viewer) {
  let btn = document.getElementById('btn-test');
  if (!btn || !viewer) return;

  // 기존 리스너 중복 방지: 클론 교체
  const clone = btn.cloneNode(true);
  btn.parentNode.replaceChild(clone, btn);
  btn = clone;

  btn.addEventListener('click', async () => {
    try {
      await runTestAnimation(viewer);
    } catch (e) {
      console.error('[test-btn] error:', e);
    }
  });
}

async function runTestAnimation(viewer) {
  const sel = getSelectionSmart(viewer);
  if (!sel || !sel.model || !sel.dbIds.length) {
    console.warn('[test-btn] 먼저 객체를 선택하세요.');
    return;
  }

  const { model, dbIds } = sel;

  // 애니메이션 중 오동작 방지
  viewer.clearSelection();

  const fragIds = collectFragIds(model, dbIds);
  if (!fragIds.length) return;

  const store = prepareFragStates(viewer, model, fragIds);

  // -------- 파라미터 --------
  const MOVE_Z = 5.0; // m 기준
  const D1 = 2000;    // 2초: 이동 + 페이드아웃
  const HOLD = 1000;  // 1초 정지
  const D2 = 2000;    // 2초: 복귀 + 페이드인

  const THREE = window.THREE || Autodesk.Viewing.THREE;
  const FALLBACK_COLOR = new THREE.Color(1.0, 0.45, 0.0); // #FF7300 근처(색 보간 폴백용)

  // -------- OUT(사라짐) 단계 --------
  await animate(D1, (t) => {
    // 시각 균일 S-커브
    const k = easeInOutSine(t);      // 0 -> 1 (초/말 느림, 중간 빠름)
    const alphaOut = 1 - k;          // 1 -> 0
    const dz = lerp(0, MOVE_Z, k);   // 위치도 같은 이징으로 보간

    for (const f of store) {
      // 위치 이동
      f.proxy.position.z = f.startPos.z + dz;
      f.proxy.updateAnimTransform();

      // 불투명도(페이드)
      if (f.cloneMat) {
        f.cloneMat.opacity = alphaOut;
        f.cloneMat.transparent = true;
        f.cloneMat.needsUpdate = true;

        // 색 폴백(원색 -> 주황) : 일부 머티리얼에서 투명이 약할 때 변화 체감용
        if (f.cloneMat.color && f.originalColor) {
          f.cloneMat.color.copy(f.originalColor).lerp(FALLBACK_COLOR, k);
        }
      }
    }
    viewer.impl.invalidate(true, true, true);
  });

  // -------- HOLD(정지) --------
  await delay(HOLD);

  // -------- IN(복귀) 단계 --------
  await animate(D2, (t) => {
    const k = easeInOutSine(t);     // 0 -> 1
    const alphaIn = k;              // 0 -> 1
    const dz = lerp(MOVE_Z, 0, k);  // Z 복귀

    for (const f of store) {
      f.proxy.position.z = f.startPos.z + dz;
      f.proxy.updateAnimTransform();

      if (f.cloneMat) {
        f.cloneMat.opacity = alphaIn;
        f.cloneMat.transparent = true;
        f.cloneMat.needsUpdate = true;

        // 색 복귀(주황 -> 원색)
        if (f.cloneMat.color && f.originalColor) {
          f.cloneMat.color.copy(FALLBACK_COLOR).lerp(f.originalColor, k);
        }
      }
    }
    viewer.impl.invalidate(true, true, true);
  });

  // -------- 상태 복구 --------
  restoreFragStates(viewer, store);
}

// ================= Helpers =================

function getSelectionSmart(viewer) {
  // 집계 선택(멀티 모델) 우선
  const agg = viewer.getAggregateSelection?.();
  if (agg && agg.length > 0) {
    const a = agg[0];
    const ids = (a.selection || []).slice();
    return ids.length ? { model: a.model, dbIds: ids, aggregate: true } : null;
  }
  // 일반 선택
  const ids = viewer.getSelection?.() || [];
  return (ids && ids.length) ? { model: viewer.model, dbIds: ids, aggregate: false } : null;
}

function collectFragIds(model, dbIds) {
  const it = model.getData().instanceTree;
  const fragIds = [];
  dbIds.forEach((dbId) => {
    it.enumNodeFragments(dbId, (fragId) => fragIds.push(fragId), true);
  });
  return fragIds;
}

// cross-version FragmentList getter
function getFragList(viewer, model) {
  if (model?.getFragmentList) return model.getFragmentList();                  // 표준
  if (viewer?.model?.getFragmentList) return viewer.model.getFragmentList();   // 대체
  // 구버전: viewer.impl.getFragmentList()가 있을 수도 있으나 현재 환경엔 없음
  return null;
}

function prepareFragStates(viewer, model, fragIds) {
  const THREE = window.THREE || Autodesk.Viewing.THREE;
  const matman = viewer.impl.matman ? viewer.impl.matman() : null;
  const fragList = getFragList(viewer, model);
  const store = [];

  // fragId -> dbId 매핑
  const fragToDb = {};
  if (fragList) {
    fragIds.forEach((fragId) => {
      try { fragToDb[fragId] = fragList.getDbId(fragId); } catch (_) {}
    });
  } else {
    console.warn('[test-btn] FragmentList not available.');
  }

  for (const fragId of fragIds) {
    const proxy = viewer.impl.getFragmentProxy(model, fragId);
    proxy.getAnimTransform();
    const startPos = new THREE.Vector3(proxy.position.x, proxy.position.y, proxy.position.z);

    const rp = viewer.impl.getRenderProxy(model, fragId);
    const originalMat = rp?.material || null;

    // 원래 색상 저장(폴백용)
    let originalColor = null;
    if (originalMat && originalMat.color) originalColor = originalMat.color.clone();

    // 머티리얼 클론(공유 차단) + 투명 세팅
    let cloneMat = null;
    if (originalMat) {
      cloneMat = (matman && matman.cloneMaterial) ? matman.cloneMaterial(originalMat) : originalMat.clone();
      cloneMat.transparent = true;
      cloneMat.opacity = 1.0;
      cloneMat.depthWrite = false;
      cloneMat.side = originalMat.side;
      cloneMat.needsUpdate = true;

      // 핵심: 공식 경로로 바인딩
      if (viewer.impl.setMaterial) {
        viewer.impl.setMaterial(model, fragId, cloneMat);
      } else if (fragList?.setMaterial) {
        fragList.setMaterial(fragId, cloneMat);
      } else if (viewer.impl.setFragmentMaterial) {
        viewer.impl.setFragmentMaterial(fragId, cloneMat); // 레거시
      }
    }

    store.push({
      model, fragId,
      dbId: fragToDb[fragId],
      proxy, startPos,
      renderProxy: rp,
      originalMat, cloneMat,
      originalColor
    });
  }
  viewer.impl.invalidate(true, true, true);
  return store;
}

function restoreFragStates(viewer, store) {
  if (!store.length) return;
  const model = store[0].model;
  const fragList = getFragList(viewer, model);

  for (const f of store) {
    // 위치 원복
    f.proxy.position.copy(f.startPos);
    f.proxy.updateAnimTransform();

    // 머티리얼 원복
    if (f.originalMat) {
      if (viewer.impl.setMaterial) {
        viewer.impl.setMaterial(f.model, f.fragId, f.originalMat);
      } else if (fragList?.setMaterial) {
        fragList.setMaterial(f.fragId, f.originalMat);
      } else if (viewer.impl.setFragmentMaterial) {
        viewer.impl.setFragmentMaterial(f.fragId, f.originalMat);
      }
    }
    if (f.cloneMat?.dispose) f.cloneMat.dispose();
  }

  viewer.impl.invalidate(true, true, true);
}

function lerp(a, b, t) { return a + (b - a) * t; }
function delay(ms) { return new Promise((res) => setTimeout(res, ms)); }

function animate(duration, step) {
  return new Promise((resolve) => {
    const start = performance.now();
    function frame(now) {
      const t = Math.min(1, (now - start) / duration);
      step(t);
      if (t < 1) requestAnimationFrame(frame);
      else resolve();
    }
    requestAnimationFrame(frame);
  });
}

// 시각적으로 고르게 보이는 S-커브
function easeInOutSine(t){ return 0.5 - 0.5 * Math.cos(Math.PI * t); }

// (옵션) 감마 기반 보정이 필요하면 아래를 사용해도 됩니다.
// function easeGamma(t, gamma = 0.45) { return 1 - Math.pow(1 - t, gamma); }
