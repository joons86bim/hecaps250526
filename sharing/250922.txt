좋아—요구한 5가지 조건에 맞춰 동일 파일(main.js) 을 깔끔히 손봤어.
핵심은: 뷰어 로딩 대기 타임아웃 단축, WBS 준비 작업에 타임아웃(4s), 무거운 워밍업 제거, ProgressOverlay 전부 주석 처리, 추가 코드는 최소화(유틸 1개만 추가).

아래 코드로 /wwwroot/js/main.js 통째로 교체하면 돼.


---

// /wwwroot/js/main.js

import { initTabs } from "./sidebar/init-tabs.js";
import { initTree } from "./sidebar/init-tree.js";
import { initViewer, loadModel } from "./viewer/init-viewer.js";
import { buildWbsProviderLazy } from "./sidebar/task-wbs/wbs/loader.js";
import { bindPanel2Resizer } from "./sidebar/task-wbs/layout/panel-resizer.js";

// ✅ task-wbs 퍼사드(확정 구조)
import {
  initTaskPanel,
  initTaskListButtons,
  setSavedTaskData,
  disableViewerEscReset,
  // requestWbsHighlightGateOn,
  initWbsPanelWithFancytree,   // ✅ 새 WBS 초기화
} from "./sidebar/index.js";

/* ==============================
   상수 & 유틸
============================== */
const SIDEBAR_MIN = 360;
const SIDEBAR_DEFAULT = 900;
const PREVIEW_MIN = 520;

function onceViewer(viewer, type) {
  return new Promise((resolve) => {
    const h = () => {
      viewer.removeEventListener(type, h);
      resolve();
    };
    viewer.addEventListener(type, h);
  });
}
function hasObjectTree(viewer) {
  return !!viewer.model?.getData?.()?.instanceTree;
}
async function waitObjectTree(viewer) {
  if (hasObjectTree(viewer)) return;
  await onceViewer(viewer, Autodesk.Viewing.OBJECT_TREE_CREATED_EVENT);
}

// ⚠️ GEOMETRY_LOADED_EVENT 무한대기 방지: 1.2s 타임아웃
async function waitGeometry(viewer, timeoutMs = 1200) {
  await new Promise((resolve) => {
    let done = false;
    const h = () => {
      if (done) return;
      done = true;
      try { viewer.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, h); } catch {}
      resolve();
    };
    viewer.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, h, { once: true });
    setTimeout(h, timeoutMs); // 비정상 케이스 보호용
  });
}

function waitIdle(timeout = 60) {
  return new Promise((resolve) => {
    if (typeof window.requestIdleCallback === "function") {
      window.requestIdleCallback(() => resolve(), { timeout });
    } else {
      setTimeout(resolve, timeout);
    }
  });
}
async function waitViewerReady(viewer) {
  await waitObjectTree(viewer);
  await waitGeometry(viewer);
  await waitIdle(60);
}

// ✅ (추가) 간단 타임아웃 래퍼 — 최소 추가 코드
async function withTimeout(promise, ms, fallback = null){
  let to;
  try {
    const timeout = new Promise((resolve) => { to = setTimeout(() => resolve({ __t: true }), ms); });
    const res = await Promise.race([promise, timeout]);
    if (res && res.__t) return fallback;
    return res;
  } finally {
    clearTimeout(to);
  }
}

function ensureCss(href) {
  if (![...document.querySelectorAll('link[rel="stylesheet"]')].some(l => l.href.includes(href))) {
    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = href; // 배포 루트 기준: /css/05-hec-progress-overlay.css
    document.head.appendChild(link);
  }
}

/** 초기 사이드바 폭을 1곳에서만 결정 & 반영 */
function initSidebarWidth() {
  const root = document.documentElement;
  const stored = parseInt(localStorage.getItem("sidebarWidthPx") || "0", 10);
  const maxNow = Math.max(SIDEBAR_MIN, window.innerWidth - PREVIEW_MIN);
  const initial = Number.isFinite(stored) && stored >= SIDEBAR_MIN
    ? Math.min(maxNow, stored)
    : Math.min(maxNow, SIDEBAR_DEFAULT);
  root.style.setProperty("--sidebar-width", initial + "px");
  return initial;
}

/** 뷰어 입력/카메라/툴 기본 상태 강제 초기화 */
function resetViewerInputAndCamera(viewer) {
  try {
    const tc = viewer.toolController;

    // 커스텀 툴 해제
    if (tc?.isToolActivated?.("BoxSelectionTool")) {
      tc.deactivateTool("BoxSelectionTool");
    }

    // 네비 복구
    viewer.setNavigationLock(false);
    const fallbackNav = viewer.impl?.is2d ? "pan" : "orbit";
    viewer.setActiveNavigationTool?.(fallbackNav);

    // 선택 모드 + 선택 해제
    viewer.setSelectionMode(Autodesk.Viewing.SelectionMode.MIXED);
    viewer.clearSelection?.();

    // 3D: 월드업 + 피벗/시점 보정
    if (!viewer.impl?.is2d) {
      viewer.navigation.setWorldUpVector(new THREE.Vector3(0, 0, 1), true);
      const bb = viewer.model?.getBoundingBox?.();
      if (bb) {
        const center = bb.getCenter(new THREE.Vector3());
        viewer.navigation.setPivotPoint(center);
        viewer.navigation.setTarget(center);
      }
    }

    viewer.fitToView?.();
  } catch (e) {
    console.warn("[init] resetViewerInputAndCamera failed:", e);
  }
}

/* ==============================
   전역 상태/샘플
============================== */
// 전면 하이라이트 게이트: 초기엔 OFF
window.__ALLOW_WBS_UPDATE = false;

const login = document.getElementById("login");
let taskData = [];

// 샘플 데이터 (서버에 데이터 없을 때 사용)
const SAMPLE_TASK_DATA = [
  {
    no: "1",
    selectOptions: ["시공", "가설", "철거"],
    selectedOption: "시공",
    title: "Task A",
    start: "2024-06-25",
    end: "2024-07-01",
    linkedObjects: [{ urn: "SAMPLE_URN", dbId: 1001, text: "벽체1" }],
    children: [
      {
        no: "1.1",
        selectOptions: ["시공", "가설", "철거"],
        selectedOption: "시공",
        title: "Subtask A1",
        start: "2024-06-26",
        end: "2024-06-30",
        linkedObjects: [{ urn: "SAMPLE_URN", dbId: 1002, text: "벽체2" }],
      },
    ],
  },
  {
    no: "2",
    selectOptions: ["시공", "가설", "철거"],
    selectedOption: "시공",
    title: "Task B",
    start: "",
    end: "",
    linkedObjects: [],
  },
];

// URN을 특수문자 없는 safe key로 변환
function safeUrn(urn) {
  return urn.replace(/[^a-zA-Z0-9]/g, "_");
}
// taskData의 모든 linkedObjects에 urn 채워넣기
function fillUrnRecursive(task, defaultUrn) {
  if (Array.isArray(task.linkedObjects)) {
    task.linkedObjects.forEach((obj) => {
      if (!obj.urn) obj.urn = defaultUrn || window.CURRENT_MODEL_URN;
    });
  }
  if (Array.isArray(task.children)) {
    task.children.forEach((child) => fillUrnRecursive(child, defaultUrn));
  }
}

/* ==============================
   전역 리사이즈(쓰로틀)
============================== */
window.addEventListener(
  "resize",
  _.throttle(() => {
    try {
      // 창이 줄면 사이드바가 최대치 넘지 않도록 보정
      initSidebarWidth();
      // 뷰어 좌표계 붕괴 방지
      window.viewer?.resize?.();
      window.viewer?.impl?.invalidate?.(true, true, true);
      // 간트 재랜더
      if (window.gantt && window.taskTree) {
        window.gantt.renderFromTrees(window.taskTree, window.wbsTree);
      }
    } catch (e) {
      console.warn("[resize] redraw failed", e);
    }
  }, 120)
);

/* ==============================
   앱 전체 초기화
============================== */
(async function () {
  try {
    // 1) 로그인 체크
    const resp = await fetch("/api/auth/profile", { credentials: "include" });
    if (!resp.ok) {
      window.location.replace("/api/auth/login");
      return;
    }
    const user = await resp.json();
    login.innerText = `Logout (${user.name})`;
    login.onclick = () => {
      const iframe = document.createElement("iframe");
      iframe.style.visibility = "hidden";
      iframe.src = "https://accounts.autodesk.com/Authentication/LogOut";
      document.body.appendChild(iframe);
      iframe.onload = () => {
        window.location.replace("/api/auth/logout");
        document.body.removeChild(iframe);
      };
    };

    // 2) 레이아웃 표시 & 사이드바 초기폭 1회 반영
    const Sidebar = document.getElementById("sidebar");
    const Header  = document.getElementById("header");
    const Preview = document.getElementById("preview");
    const sidebarResizer = document.getElementById("sidebar-resizer");
    const Loading = document.getElementById("loading");

    Sidebar.style.display = "";
    sidebarResizer.style.display = "";
    Preview.style.display = "";
    Header.style.display = "";
    Loading.style.display = "none"; // ✅ 로딩(웰컴) 강제 종료
    login.style.visibility = "visible";

    // 인라인 폭/left 제거(전부 CSS 변수로 통일)
    Sidebar.style.removeProperty("width");
    Preview.style.removeProperty("left");
    sidebarResizer.style.removeProperty("left");

    // ★ 반드시 viewer 생성 전, CSS 변수 준비
    initSidebarWidth();

    // 3) 탭/뷰어 초기화
    initTabs("#sidebar");
    const viewerHost = document.getElementById("viewer-host");
    const viewer = await initViewer(viewerHost);
    window.viewer = viewer;               // ✅ 전역 참조
    disableViewerEscReset(viewer);

    // ⚠️ ProgressOverlay 관련(스타일/확장) 전부 비활성화 — freeze 원인 차단
    // ensureCss('/css/05-hec-progress-overlay.css');
    // await import('./viewer/hec.ProgressOverlay.js');
    // const progressOverlay = await viewer.loadExtension('hec.ProgressOverlay', {
    //   startVisible: false,
    //   autoHideOnGeometryLoaded: true,
    //   autoHideDelayMs: 900,
    //   clickToDismiss: true,
    //   useToastOnDone: false,
    //   keepAlive: 'off',
    // });
    // window.progressOverlay = progressOverlay;

    // 리사이저 바인딩(반드시 viewer 전달)
    bindPanel2Resizer(viewer);

    // 초기 좌표 보정
    viewer.resize();
    viewer.impl?.invalidate?.(true, true, true);
    requestAnimationFrame(() => {
      try {
        viewer.resize();
        viewer.impl?.invalidate?.(true, true, true);
      } catch {}
    });

    // 입력/카메라 보정
    resetViewerInputAndCamera(viewer);

    // 혹시 첫 프레임 사이드바가 0이라면 복구
    requestAnimationFrame(() => {
      const sb = document.getElementById("sidebar");
      if (sb && sb.offsetWidth === 0) {
        document.documentElement.style.setProperty("--sidebar-width", SIDEBAR_DEFAULT + "px");
        viewer.resize();
        viewer.impl?.invalidate?.(true, true, true);
      }
    });

    // 4) 프로젝트 트리 초기화(모델 선택 콜백)
    initTree("#tree", async (versionId) => {
      destroyTaskPanel();

      const urn = window.btoa(versionId).replace(/=/g, "");
      window.CURRENT_MODEL_URN = urn;
      window.CURRENT_MODEL_SAFE_URN = safeUrn(urn);

      taskData.length = 0;
      setSavedTaskData([]);
      await loadTaskDataIfExists();
      taskData.forEach((t) => fillUrnRecursive(t, urn));

      console.log("[main.js] 모델 선택!", versionId, urn);

      // 모델 클릭 → 오버레이 사용 안 함
      // const ov = viewer.getExtension('hec.ProgressOverlay');
      // ov?.beginLoadFor(urn, '모델을 로드하는 중입니다…');

      await loadModel(viewer, urn);

      // ✅ 뷰어 로딩 완료 + idle 보장
      await waitViewerReady(viewer);

      // ▶ 모델마다 1회 카메라/피벗/입력 보정
      resetViewerInputAndCamera(viewer);
      viewer.resize();

      // ✅ WBS Provider: 4초 넘으면 건너뜀(프리즈 방지)
      let wbsProvider;
      try {
        const built = await withTimeout(
          buildWbsProviderLazy(viewer, { bucketThreshold: 400, bucketSize: 200, source: 'all' }),
          4000,
          null
        );
        if (built && built.provider) {
          wbsProvider = built.provider;
        } else {
          console.warn("[main.js] WBS provider 타임아웃 → 빈 provider로 대체");
          wbsProvider = { __provider:true, roots: async()=>[], children: async()=>[], countAt: ()=>0 };
        }
      } catch (e) {
        console.warn("[main.js] WBS 데이터 생성 실패!", e);
        wbsProvider = { __provider:true, roots: async()=>[], children: async()=>[], countAt: ()=>0 };
      }

      // Task 패널 초기화
      initTaskPanel(taskData);
      initTaskListButtons();

      window.dispatchEvent(new Event("panel2-ready"));

      // ▶ 로딩 종료 전, 워밍업(사전 펼침)은 과감히 생략 — 프리즈 요인 제거
      // async function warmup(provider, maxDepth=3, hardCap=1200){ ... }
      // try { await warmup(wbsProvider, 3, 1200); } catch {}

      // ✅ WBS 패널(Fancytree) 초기화 (에러 흡수)
      try {
        await initWbsPanelWithFancytree(
          wbsProvider,
          { primaryOrder: ["HEC.WBS","HEC.Level","HEC.Zone"] }
        );
      } catch (e) {
        console.warn("[main.js] initWbsPanelWithFancytree 실패:", e);
      }

      // 간트 1회 렌더(가볍게)
      requestAnimationFrame(() => {
        try {
          window.gantt?.renderFromTrees(window.taskTree, window.wbsTree);
        } catch {}
      });

      // 오버레이 종료 사용 안 함
      // try { progressOverlay.finishFor(urn, '모델 로딩이 완료되었습니다.'); } catch (e) {}
    });
  } catch (err) {
    alert("Could not initialize the application. See console for more details.");
    console.error(err);
  }
})();

/* ==============================
   데이터 로드/파괴 유틸
============================== */
async function loadTaskDataIfExists() {
  try {
    const safeUrnVal = window.CURRENT_MODEL_SAFE_URN;
    const url = `/api/tasks?urn=${safeUrnVal}`;
    const resp = await fetch(url, { credentials: "include" });
    if (resp.ok) {
      const data = await resp.json();
      taskData.length = 0;
      if (Array.isArray(data) && data.length > 0) {
        data.forEach((item) => taskData.push(item));
        setSavedTaskData(taskData);
      } else {
        SAMPLE_TASK_DATA.forEach((item) => taskData.push(structuredClone(item)));
        setSavedTaskData(taskData);
      }
    } else {
      taskData.length = 0;
      SAMPLE_TASK_DATA.forEach((item) => taskData.push(structuredClone(item)));
      setSavedTaskData(taskData);
    }
  } catch (err) {
    taskData.length = 0;
    SAMPLE_TASK_DATA.forEach((item) => taskData.push(structuredClone(item)));
    setSavedTaskData(taskData);
    console.warn("task 데이터를 불러오지 못했습니다. 샘플로 초기화:", err);
  }
}

function destroyTaskPanel() {
  console.log("[destroy] panel2 destroy & 재생성");
  try { $.ui.fancytree.getTree("#treegrid")?.destroy(); } catch {}
  window.taskTree = null;
  window.wbsTree = null;
  try { window.gantt?.drawFromRows?.([]); } catch {}
  $("#wbs-group-content").empty();
  $("#treegrid tbody").empty();
}

변경 핵심 요약

ProgressOverlay 전부 주석 처리 → 로딩창/확장 때문에 대기 걸리지 않음.

waitGeometry 타임아웃 1.2s → 이벤트 누락 시에도 진행.

withTimeout(4s)로 buildWbsProviderLazy 감싸기 → WBS 준비가 길어지면 건너뛰고 계속 진행(프리즈 차단).

WBS 사전 워밍업 제거 → 대량 I/O/계산으로 인한 초기 멈춤 제거.

나머지는 기존 흐름 유지(추가 변경 최소화).


이 상태로 돌려보고, 뷰어 동작이 정상(프리즈 X)인데 WBS가 비어있다면 그건 의도한 안전폴백이야. 그땐 WBS만 따로 재시도 버튼(또는 탭 진입 시 지연 초기화) 붙이면 돼.

