// /wwwroot/js/anim/anim-utils.js
// 공개 API: moveZ(viewer, model, dbIds, opts), fadeIn(viewer, model, dbIds, opts), fadeOut(viewer, model, dbIds, opts)
// - 각 메서드는 내부에서 안전하게 프래그먼트 수집/머티리얼 클론 → 애니메이션 → (옵션)원복까지 처리
// - opts 공통: { duration=2000, easing='sineInOut', restore=true }
// - moveZ 전용: { distance=5, relative=true } // 모델 단위(m) 기준. mm면 distance=5000 등
// - fadeIn 전용: { from=0, to=1, useColorFallback=false, fallbackColor=0xff7300 }
// - fadeOut 전용:{ from=1, to=0, useColorFallback=false, fallbackColor=0xff7300 }

export async function moveZ(viewer, model, dbIds, opts = {}) {
  const {
    distance = 5,
    duration = 2000,
    easing = 'sineInOut',
    restore = true,
    relative = true,
  } = opts;

  const store = prepareFragStates(viewer, model, dbIds);
  const ease = getEasing(easing);

  try {
    await animate(duration, (t) => {
      const k = ease(t);
      const dz = relative ? lerp(0, distance, k) : lerp(store.meta.baseZ, distance, k);

      for (const f of store.items) {
        f.proxy.position.z = f.startPos.z + dz;
        f.proxy.updateAnimTransform();
      }
      viewer.impl.invalidate(true, true, true);
    });
  } finally {
    if (restore) {
      for (const f of store.items) {
        f.proxy.position.copy(f.startPos);
        f.proxy.updateAnimTransform();
      }
      viewer.impl.invalidate(true, true, true);
      // 위치만 원복, 머티리얼은 아래 restoreMaterials로 공통 처리
      restoreMaterials(viewer, store);
    } else {
      // 유지할 때도 머티리얼은 원상복구(투명/클론 제거)하는 게 안전
      restoreMaterials(viewer, store);
    }
  }
}

export async function fadeIn(viewer, model, dbIds, opts = {}) {
  const {
    from = 0,
    to = 1,
    duration = 2000,
    easing = 'sineInOut',
    restore = false,
    useColorFallback = false,
    fallbackColor = 0xff7300
  } = opts;

  const store = prepareFragStates(viewer, model, dbIds, { forceTransparent: true });
  const ease = getEasing(easing);
  const THREE = window.THREE || Autodesk.Viewing.THREE;
  const fb = new THREE.Color(fallbackColor);

  // 시작 α 보정
  for (const f of store.items) {
    if (f.cloneMat) {
      f.cloneMat.opacity = from;
      f.cloneMat.transparent = true;
      f.cloneMat.needsUpdate = true;
    }
  }

  try {
    await animate(duration, (t) => {
      const k = ease(t);
      const a = lerp(from, to, k);

      for (const f of store.items) {
        if (!f.cloneMat) continue;
        f.cloneMat.opacity = a;
        f.cloneMat.transparent = true;
        f.cloneMat.needsUpdate = true;

        if (useColorFallback && f.cloneMat.color && f.originalColor) {
          // 주황→원색
          f.cloneMat.color.copy(fb).lerp(f.originalColor, k);
        }
      }
      viewer.impl.invalidate(true, true, true);
    });
  } finally {
    if (restore) restoreMaterials(viewer, store);
    else cleanupClones(store); // 클론 유지 원치 않으면 해제
  }
}

export async function fadeOut(viewer, model, dbIds, opts = {}) {
  const {
    from = 1,
    to = 0,
    duration = 2000,
    easing = 'sineInOut',
    restore = false,
    useColorFallback = false,
    fallbackColor = 0xff7300
  } = opts;

  const store = prepareFragStates(viewer, model, dbIds, { forceTransparent: true });
  const ease = getEasing(easing);
  const THREE = window.THREE || Autodesk.Viewing.THREE;
  const fb = new THREE.Color(fallbackColor);

  // 시작 α 보정
  for (const f of store.items) {
    if (f.cloneMat) {
      f.cloneMat.opacity = from;
      f.cloneMat.transparent = true;
      f.cloneMat.needsUpdate = true;
    }
  }

  try {
    await animate(duration, (t) => {
      const k = ease(t);
      const a = lerp(from, to, k);

      for (const f of store.items) {
        if (!f.cloneMat) continue;
        f.cloneMat.opacity = a;
        f.cloneMat.transparent = true;
        f.cloneMat.needsUpdate = true;

        if (useColorFallback && f.cloneMat.color && f.originalColor) {
          // 원색→주황
          f.cloneMat.color.copy(f.originalColor).lerp(fb, k);
        }
      }
      viewer.impl.invalidate(true, true, true);
    });
  } finally {
    if (restore) restoreMaterials(viewer, store);
    else cleanupClones(store);
  }
}

/* -------------------- 내부 유틸 -------------------- */

function prepareFragStates(viewer, model, dbIds, opts = {}) {
  const THREE = window.THREE || Autodesk.Viewing.THREE;
  const matman = viewer.impl.matman ? viewer.impl.matman() : null;
  const fragList = getFragList(viewer, model);
  const items = [];

  const it = model.getData().instanceTree;
  const fragIds = [];
  dbIds.forEach((dbId) => {
    it.enumNodeFragments(dbId, (fragId) => fragIds.push(fragId), true);
  });

  for (const fragId of fragIds) {
    const proxy = viewer.impl.getFragmentProxy(model, fragId);
    proxy.getAnimTransform();
    const startPos = new THREE.Vector3(proxy.position.x, proxy.position.y, proxy.position.z);

    const rp = viewer.impl.getRenderProxy(model, fragId);
    const originalMat = rp?.material || null;
    let originalColor = null;
    if (originalMat?.color) originalColor = originalMat.color.clone();

    let cloneMat = null;
    if (originalMat) {
      cloneMat = (matman?.cloneMaterial) ? matman.cloneMaterial(originalMat) : originalMat.clone();
      // 투명 애니메이션을 위한 안전 설정
      cloneMat.transparent = true;
      cloneMat.depthWrite = false;
      cloneMat.side = originalMat.side;
      if (opts.forceTransparent && typeof cloneMat.opacity !== 'number') {
        cloneMat.opacity = 1.0;
      }
      cloneMat.needsUpdate = true;

      // 안전한 바인딩 경로
      if (viewer.impl.setMaterial) {
        viewer.impl.setMaterial(model, fragId, cloneMat);
      } else if (fragList?.setMaterial) {
        fragList.setMaterial(fragId, cloneMat);
      } else if (viewer.impl.setFragmentMaterial) {
        viewer.impl.setFragmentMaterial(fragId, cloneMat);
      }
    }

    items.push({ model, fragId, proxy, startPos, originalMat, cloneMat, originalColor });
  }

  viewer.impl.invalidate(true, true, true);

  // 메타(기준 Z 등 필요 시 확장)
  const meta = { baseZ: 0 };
  return { items, meta, viewer, model };
}

function restoreMaterials(viewer, store) {
  const fragList = getFragList(viewer, store.model);
  for (const f of store.items) {
    if (f.originalMat) {
      if (viewer.impl.setMaterial) {
        viewer.impl.setMaterial(f.model, f.fragId, f.originalMat);
      } else if (fragList?.setMaterial) {
        fragList.setMaterial(f.fragId, f.originalMat);
      } else if (viewer.impl.setFragmentMaterial) {
        viewer.impl.setFragmentMaterial(f.fragId, f.originalMat);
      }
    }
  }
  cleanupClones(store); // 메모리 정리
  viewer.impl.invalidate(true, true, true);
}

function cleanupClones(store) {
  for (const f of store.items) {
    if (f.cloneMat?.dispose) {
      try { f.cloneMat.dispose(); } catch (_) {}
    }
    f.cloneMat = null;
  }
}

function getFragList(viewer, model) {
  if (model?.getFragmentList) return model.getFragmentList();
  if (viewer?.model?.getFragmentList) return viewer.model.getFragmentList();
  return null;
}

/* 애니메이션/이징 공통 */

function animate(duration, step) {
  return new Promise((resolve) => {
    const start = performance.now();
    function frame(now) {
      const t = Math.min(1, (now - start) / duration);
      step(t);
      if (t < 1) requestAnimationFrame(frame);
      else resolve();
    }
    requestAnimationFrame(frame);
  });
}

function getEasing(name) {
  switch ((name || '').toLowerCase()) {
    case 'linear': return (t) => t;
    case 'quad': 
    case 'quadInOut':
    case 'quadinout':
      return (t) => (t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t + 2, 2) / 2);
    case 'sine':
    case 'sineInOut':
    case 'sineinout':
    default:
      return (t) => 0.5 - 0.5 * Math.cos(Math.PI * t); // easeInOutSine
  }
}

function lerp(a, b, t) { return a + (b - a) * t; }